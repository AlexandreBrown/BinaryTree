        -:    0:Source:/home/brownthedev/Documents/uLaval/Hiver2021/IFT-2008 Algorithmes et structures de données/IFT-2008-BinarySearchTreeADT/BinaryTrees/src/main/AvlTree.tpp
        -:    0:Graph:/home/brownthedev/Documents/uLaval/Hiver2021/IFT-2008 Algorithmes et structures de données/IFT-2008-BinarySearchTreeADT/BinaryTrees/cmake-build-debug-coverage/CMakeFiles/BinaryTrees_test.dir/src/test/AvlTreeTest.cpp.gcno
        -:    0:Data:/home/brownthedev/Documents/uLaval/Hiver2021/IFT-2008 Algorithmes et structures de données/IFT-2008-BinarySearchTreeADT/BinaryTrees/cmake-build-debug-coverage/CMakeFiles/BinaryTrees_test.dir/src/test/AvlTreeTest.cpp.gcda
        -:    0:Runs:1
        -:    1:#include "AvlTree.h"
        -:    2:
        -:    3:template<typename Comparable>
    #####:    4:void AvlTree<Comparable>::insert(const Comparable& x, AvlNode<Comparable>*& t) {
        -:    5:
    #####:    6:	BinarySearchTree<Comparable, AvlNode<Comparable>>::insert(x, t);
    %%%%%:    6-block  0
        -:    7:
    #####:    8:	balance(t);
    #####:    9:}
        -:   10:
        -:   11:template<typename Comparable>
    #####:   12:void AvlTree<Comparable>::insert(Comparable&& x, AvlNode<Comparable>*& t) {
        -:   13:
    #####:   14:	BinarySearchTree<Comparable, AvlNode<Comparable>>::insert(std::move(x), t);
    %%%%%:   14-block  0
        -:   15:
    #####:   16:	balance(t);
    #####:   17:}
        -:   18:
        -:   19:template<typename Comparable>
    #####:   20:void AvlTree<Comparable>::balance(AvlNode<Comparable>*& node) {
        -:   21:
    #####:   22:	if (node==nullptr) {
    %%%%%:   22-block  0
    #####:   23:		return;
    %%%%%:   23-block  0
        -:   24:	}
        -:   25:
    #####:   26:	if (height(node->left) - height(node->right) > ALLOWED_IMBALANCE) {
    %%%%%:   26-block  0
    #####:   27:		if (height(node->left->left) >= height(node->left->right)) {
    %%%%%:   27-block  0
    #####:   28:			rotateWithLeftChild(node);
    %%%%%:   28-block  0
        -:   29:		} else {
    #####:   30:			doubleRotateWithLeftChild(node);
    %%%%%:   30-block  0
        -:   31:		}
    #####:   32:	} else if (height(node->right) - height(node->left) > ALLOWED_IMBALANCE) {
    %%%%%:   32-block  0
    #####:   33:		if (height(node->right->right) >= height(node->right->left)) {
    %%%%%:   33-block  0
    #####:   34:			rotateWithRightChild(node);
    %%%%%:   34-block  0
        -:   35:		} else {
    #####:   36:			doubleRotateWithRightChild(node);
    %%%%%:   36-block  0
        -:   37:		}
        -:   38:	}
        -:   39:
    #####:   40:	node->height = std::max(height(node->left), height(node->right)) + 1;
    %%%%%:   40-block  0
        -:   41:}
        -:   42:
        -:   43:template<typename Comparable>
    #####:   44:int AvlTree<Comparable>::height(AvlNode<Comparable>* node) const {
    #####:   45:	return node==nullptr ? -1 : node->height;
    %%%%%:   45-block  0
    %%%%%:   45-block  1
    %%%%%:   45-block  2
    %%%%%:   45-block  3
        -:   46:}
        -:   47:
        -:   48:template<typename Comparable>
    #####:   49:void AvlTree<Comparable>::remove(const Comparable& x, AvlNode<Comparable>*& t) {
        -:   50:
    #####:   51:	BinarySearchTree<Comparable, AvlNode<Comparable>>::remove(x, t);
    %%%%%:   51-block  0
        -:   52:
    #####:   53:	balance(t);
    #####:   54:}
        -:   55:
        -:   56:template<typename Comparable>
    #####:   57:void AvlTree<Comparable>::rotateWithLeftChild(AvlNode<Comparable>*& k2) {
    #####:   58:	AvlNode<Comparable>* k1 = k2->left;
    #####:   59:	k2->left = k1->right;
    #####:   60:	k1->right = k2;
    #####:   61:	k2->height = std::max(height(k2->left), height(k2->right)) + 1;
    %%%%%:   61-block  0
    #####:   62:	k1->height = std::max(height(k1->left), k2->height) + 1;
    #####:   63:	k2 = k1;
    #####:   64:}
        -:   65:
        -:   66:template<typename Comparable>
    #####:   67:void AvlTree<Comparable>::doubleRotateWithLeftChild(AvlNode<Comparable>*& k3) {
    #####:   68:	rotateWithRightChild(k3->left);
    %%%%%:   68-block  0
    #####:   69:	rotateWithLeftChild(k3);
    #####:   70:}
        -:   71:
        -:   72:template<typename Comparable>
    #####:   73:void AvlTree<Comparable>::rotateWithRightChild(AvlNode<Comparable>*& k2) {
    #####:   74:	AvlNode<Comparable>* k1 = k2->right;
    #####:   75:	k2->right = k1->left;
    #####:   76:	k1->left = k2;
    #####:   77:	k2->height = std::max(height(k2->right), height(k2->left)) + 1;
    %%%%%:   77-block  0
    #####:   78:	k1->height = std::max(height(k1->right), k2->height) + 1;
    #####:   79:	k2 = k1;
    #####:   80:}
        -:   81:
        -:   82:template<typename Comparable>
    #####:   83:void AvlTree<Comparable>::doubleRotateWithRightChild(AvlNode<Comparable>*& k3) {
    #####:   84:	rotateWithLeftChild(k3->right);
    %%%%%:   84-block  0
    #####:   85:	rotateWithRightChild(k3);
    #####:   86:}
