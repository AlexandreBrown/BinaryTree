        -:    0:Source:/home/brownthedev/Documents/uLaval/Hiver2021/IFT-2008 Algorithmes et structures de données/IFT-2008-BinarySearchTreeADT/BinaryTrees/src/main/BinarySearchTree.tpp
        -:    0:Graph:/home/brownthedev/Documents/uLaval/Hiver2021/IFT-2008 Algorithmes et structures de données/IFT-2008-BinarySearchTreeADT/BinaryTrees/cmake-build-debug-coverage/CMakeFiles/BinaryTrees_test.dir/src/test/AvlTreeTest.cpp.gcno
        -:    0:Data:/home/brownthedev/Documents/uLaval/Hiver2021/IFT-2008 Algorithmes et structures de données/IFT-2008-BinarySearchTreeADT/BinaryTrees/cmake-build-debug-coverage/CMakeFiles/BinaryTrees_test.dir/src/test/AvlTreeTest.cpp.gcda
        -:    0:Runs:1
        -:    1:#include "BinarySearchTree.h"
        -:    2:
        -:    3:template<typename Comparable, typename NodeType>
    #####:    4:BinarySearchTree<Comparable, NodeType>::BinarySearchTree() : root{nullptr} {}
        -:    5:
        -:    6:template<typename Comparable, typename NodeType>
        -:    7:BinarySearchTree<Comparable, NodeType>::BinarySearchTree(const BinarySearchTree& rhs) : root{nullptr} {
        -:    8:	root = clone(rhs.root);
        -:    9:}
        -:   10:
        -:   11:template<typename Comparable, typename NodeType>
        -:   12:NodeType* BinarySearchTree<Comparable, NodeType>::clone(NodeType* t) const {
        -:   13:	if (t==nullptr) {
        -:   14:		return nullptr;
        -:   15:	}
        -:   16:	return new NodeType(
        -:   17:		t->element,
        -:   18:		clone(t->left),
        -:   19:		clone(t->right)
        -:   20:	);
        -:   21:}
        -:   22:
        -:   23:template<typename Comparable, typename NodeType>
        -:   24:BinarySearchTree<Comparable, NodeType>::BinarySearchTree(BinarySearchTree<Comparable, NodeType>&& rhs): root{nullptr} {
        -:   25:	root = clone(rhs.root);
        -:   26:}
        -:   27:
        -:   28:template<typename Comparable, typename NodeType>
    #####:   29:BinarySearchTree<Comparable, NodeType>::~BinarySearchTree() {
    #####:   30:	makeEmpty();
    #####:   31:}
------------------
_ZN16BinarySearchTreeIi7AvlNodeIiEED0Ev:
    #####:   29:BinarySearchTree<Comparable, NodeType>::~BinarySearchTree() {
        -:   30:	makeEmpty();
    #####:   31:}
    %%%%%:   31-block  0
------------------
_ZN16BinarySearchTreeIi7AvlNodeIiEED2Ev:
    #####:   29:BinarySearchTree<Comparable, NodeType>::~BinarySearchTree() {
    #####:   30:	makeEmpty();
    #####:   31:}
    %%%%%:   31-block  0
------------------
        -:   32:
        -:   33:template<typename Comparable, typename NodeType>
    #####:   34:void BinarySearchTree<Comparable, NodeType>::makeEmpty() {
    #####:   35:	makeEmpty(root);
    %%%%%:   35-block  0
    #####:   36:}
        -:   37:
        -:   38:template<typename Comparable, typename NodeType>
    #####:   39:void BinarySearchTree<Comparable, NodeType>::makeEmpty(NodeType*& t) {
    #####:   40:	if (t!=nullptr) {
    %%%%%:   40-block  0
    #####:   41:		makeEmpty(t->left);
    %%%%%:   41-block  0
    #####:   42:		makeEmpty(t->right);
    #####:   43:		delete t;
    %%%%%:   43-block  0
        -:   44:	}
        -:   45:
    #####:   46:	t = nullptr;
    #####:   47:}
        -:   48:
        -:   49:template<typename Comparable, typename NodeType>
    #####:   50:bool BinarySearchTree<Comparable, NodeType>::contains(const Comparable& x) const {
    #####:   51:	return contains(x, root);
    %%%%%:   51-block  0
        -:   52:}
        -:   53:
        -:   54:template<typename Comparable, typename NodeType>
    #####:   55:bool BinarySearchTree<Comparable, NodeType>::contains(const Comparable& x, NodeType* t) const {
    #####:   56:	if (t==nullptr) {
    %%%%%:   56-block  0
    #####:   57:		return false;
    %%%%%:   57-block  0
        -:   58:	}
    #####:   59:	if (x < t->element) {
    %%%%%:   59-block  0
    #####:   60:		return contains(x, t->left);
    %%%%%:   60-block  0
        -:   61:	}
    #####:   62:	if (t->element < x) {
    %%%%%:   62-block  0
    #####:   63:		return contains(x, t->right);
    %%%%%:   63-block  0
        -:   64:	}
    #####:   65:	return true;
    %%%%%:   65-block  0
        -:   66:}
        -:   67:
        -:   68:template<typename Comparable, typename NodeType>
        -:   69:const Comparable& BinarySearchTree<Comparable, NodeType>::findMin() const {
        -:   70:	if (root==nullptr) {
        -:   71:		throw std::logic_error{"Could not find min element of empty tree!"};
        -:   72:	}
        -:   73:
        -:   74:	return findMin(root)->element;
        -:   75:}
        -:   76:
        -:   77:template<typename Comparable, typename NodeType>
    #####:   78:NodeType* BinarySearchTree<Comparable, NodeType>::findMin(NodeType* t) const {
    #####:   79:	if (t->left==nullptr) {
    %%%%%:   79-block  0
    #####:   80:		return t;
    %%%%%:   80-block  0
        -:   81:	}
    #####:   82:	return findMin(t->left);
    %%%%%:   82-block  0
        -:   83:}
        -:   84:
        -:   85:template<typename Comparable, typename NodeType>
        -:   86:const Comparable& BinarySearchTree<Comparable, NodeType>::findMax() const {
        -:   87:	if (root==nullptr) {
        -:   88:		throw std::logic_error{"Could not find max element of empty tree!"};
        -:   89:	}
        -:   90:
        -:   91:	return findMax(root)->element;
        -:   92:}
        -:   93:
        -:   94:template<typename Comparable, typename NodeType>
        -:   95:NodeType* BinarySearchTree<Comparable, NodeType>::findMax(NodeType* t) const {
        -:   96:	while (t->right!=nullptr) {
        -:   97:		t = t->right;
        -:   98:	}
        -:   99:	return t;
        -:  100:}
        -:  101:
        -:  102:template<typename Comparable, typename NodeType>
    #####:  103:void BinarySearchTree<Comparable, NodeType>::insert(const Comparable& x) {
    #####:  104:	insert(x, root);
    %%%%%:  104-block  0
    #####:  105:}
        -:  106:
        -:  107:template<typename Comparable, typename NodeType>
    #####:  108:void BinarySearchTree<Comparable, NodeType>::insert(const Comparable& x, NodeType*& t) {
    #####:  109:	if (t==nullptr) {
    %%%%%:  109-block  0
    #####:  110:		t = new NodeType(x);
    %%%%%:  110-block  0
    #####:  111:	} else if (x < t->element) {
    %%%%%:  111-block  0
    #####:  112:		insert(x, t->left);
    %%%%%:  112-block  0
    #####:  113:	} else if (t->element < x) {
    %%%%%:  113-block  0
    #####:  114:		insert(x, t->right);
    %%%%%:  114-block  0
        -:  115:	} else {
    #####:  116:		throw std::logic_error{"Element is already present in the tree!"};
    %%%%%:  116-block  0
    %%%%%:  116-block  1
    $$$$$:  116-block  2
        -:  117:	}
    #####:  118:}
    %%%%%:  118-block  0
        -:  119:
        -:  120:template<typename Comparable, typename NodeType>
    #####:  121:void BinarySearchTree<Comparable, NodeType>::insert(Comparable&& x) {
    #####:  122:	insert(std::move(x), root);
    %%%%%:  122-block  0
    #####:  123:}
        -:  124:
        -:  125:template<typename Comparable, typename NodeType>
    #####:  126:void BinarySearchTree<Comparable, NodeType>::insert(Comparable&& x, NodeType*& t) {
    #####:  127:	if (t==nullptr) {
    %%%%%:  127-block  0
    #####:  128:		t = new NodeType(std::move(x));
    %%%%%:  128-block  0
    #####:  129:	} else if (x < t->element) {
    %%%%%:  129-block  0
    #####:  130:		insert(std::move(x), t->left);
    %%%%%:  130-block  0
    #####:  131:	} else if (t->element < x) {
    %%%%%:  131-block  0
    #####:  132:		insert(std::move(x), t->right);
    %%%%%:  132-block  0
        -:  133:	} else {
    #####:  134:		throw std::logic_error{"Element is already present in the tree!"};
    %%%%%:  134-block  0
    %%%%%:  134-block  1
    $$$$$:  134-block  2
        -:  135:	}
    #####:  136:}
    %%%%%:  136-block  0
        -:  137:
        -:  138:template<typename Comparable, typename NodeType>
    #####:  139:void BinarySearchTree<Comparable, NodeType>::remove(const Comparable& x) {
    #####:  140:	remove(x, root);
    %%%%%:  140-block  0
    #####:  141:}
        -:  142:
        -:  143:template<typename Comparable, typename NodeType>
    #####:  144:void BinarySearchTree<Comparable, NodeType>::remove(const Comparable& x, NodeType*& t) {
    #####:  145:	if (t==nullptr) {
    %%%%%:  145-block  0
    #####:  146:		return;
    %%%%%:  146-block  0
        -:  147:	}
        -:  148:
    #####:  149:	if (x < t->element) {
    %%%%%:  149-block  0
    #####:  150:		remove(x, t->left);
    %%%%%:  150-block  0
    #####:  151:	} else if (t->element < x) {
    %%%%%:  151-block  0
    #####:  152:		remove(x, t->right);
    %%%%%:  152-block  0
    #####:  153:	} else if (has2Children(t)) {
    %%%%%:  153-block  0
    #####:  154:		t->element = findMin(t->right)->element;
    %%%%%:  154-block  0
    #####:  155:		remove(t->element, t->right);
        -:  156:	} else {
    #####:  157:		NodeType* oldNode = t;
    #####:  158:		t = (t->left!=nullptr) ? t->left : t->right;
    %%%%%:  158-block  0
    %%%%%:  158-block  1
    %%%%%:  158-block  2
    #####:  159:		delete oldNode;
    %%%%%:  159-block  0
    %%%%%:  159-block  1
        -:  160:	}
        -:  161:}
        -:  162:
        -:  163:template<typename Comparable, typename NodeType>
    #####:  164:bool BinarySearchTree<Comparable, NodeType>::has2Children(NodeType* const& t) const {
    #####:  165:	return t->left!=nullptr && t->right!=nullptr;
    %%%%%:  165-block  0
    %%%%%:  165-block  1
    %%%%%:  165-block  2
    %%%%%:  165-block  3
    %%%%%:  165-block  4
        -:  166:}
        -:  167:
        -:  168:template<typename Comparable, typename NodeType>
        -:  169:bool BinarySearchTree<Comparable, NodeType>::isEmpty() const {
        -:  170:	return root==nullptr;
        -:  171:}
        -:  172:
        -:  173:template<typename Comparable, typename NodeType>
        -:  174:BinarySearchTree<Comparable, NodeType>& BinarySearchTree<Comparable, NodeType>::operator=(const BinarySearchTree& rhs) {
        -:  175:
        -:  176:	if (this->root!=rhs.root) {
        -:  177:		makeEmpty();
        -:  178:		root = clone(rhs.root);
        -:  179:	}
        -:  180:
        -:  181:	return *this;
        -:  182:}
        -:  183:
        -:  184:template<typename Comparable, typename NodeType>
        -:  185:BinarySearchTree<Comparable, NodeType>& BinarySearchTree<Comparable, NodeType>::operator=(BinarySearchTree&& rhs) {
        -:  186:
        -:  187:	if (this->root!=rhs.root) {
        -:  188:		makeEmpty();
        -:  189:		root = clone(rhs.root);
        -:  190:	}
        -:  191:
        -:  192:	return *this;
        -:  193:}
        -:  194:
        -:  195:template<typename Comparable, typename NodeType>
        -:  196:void BinarySearchTree<Comparable, NodeType>::printTreeInSymmetricOrder(std::ostream& out) const {
        -:  197:	printTreeInSymmetricOrder(root, out);
        -:  198:}
        -:  199:
        -:  200:template<typename Comparable, typename NodeType>
        -:  201:void BinarySearchTree<Comparable, NodeType>::printTreeInSymmetricOrder(NodeType* t, std::ostream& out) const {
        -:  202:	if (t==nullptr) {
        -:  203:		return;
        -:  204:	}
        -:  205:
        -:  206:	printTreeInSymmetricOrder(t->left, out);
        -:  207:
        -:  208:	out << t->element << ";";
        -:  209:
        -:  210:	printTreeInSymmetricOrder(t->right, out);
        -:  211:}
        -:  212:
        -:  213:template<typename Comparable, typename NodeType>
    #####:  214:void BinarySearchTree<Comparable, NodeType>::printTreeInPreOrder(std::ostream& out) const {
    #####:  215:	printTreeInPreOrder(root, out);
    %%%%%:  215-block  0
    #####:  216:}
        -:  217:
        -:  218:template<typename Comparable, typename NodeType>
    #####:  219:void BinarySearchTree<Comparable, NodeType>::printTreeInPreOrder(NodeType* t, std::ostream& out) const {
    #####:  220:	if (t==nullptr) {
    %%%%%:  220-block  0
    #####:  221:		return;
    %%%%%:  221-block  0
        -:  222:	}
        -:  223:
    #####:  224:	out << t->element << ";";
    %%%%%:  224-block  0
        -:  225:
    #####:  226:	printTreeInPreOrder(t->left, out);
        -:  227:
    #####:  228:	printTreeInPreOrder(t->right, out);
        -:  229:}
        -:  230:
        -:  231:template<typename Comparable, typename NodeType>
        -:  232:void BinarySearchTree<Comparable, NodeType>::printTreeInPostOrder(std::ostream& out) const {
        -:  233:	printTreeInPostOrder(root, out);
        -:  234:}
        -:  235:
        -:  236:template<typename Comparable, typename NodeType>
        -:  237:void BinarySearchTree<Comparable, NodeType>::printTreeInPostOrder(NodeType* t, std::ostream& out) const {
        -:  238:	if (t==nullptr) {
        -:  239:		return;
        -:  240:	}
        -:  241:
        -:  242:	printTreeInPostOrder(t->left, out);
        -:  243:
        -:  244:	printTreeInPostOrder(t->right, out);
        -:  245:
        -:  246:	out << t->element << ";";
        -:  247:}
