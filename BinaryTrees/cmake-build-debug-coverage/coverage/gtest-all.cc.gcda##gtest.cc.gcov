        -:    0:Source:/home/brownthedev/Documents/uLaval/Hiver2021/IFT-2008 Algorithmes et structures de données/IFT-2008-BinarySearchTreeADT/BinaryTrees/lib/googletest/googletest/src/gtest.cc
        -:    0:Graph:/home/brownthedev/Documents/uLaval/Hiver2021/IFT-2008 Algorithmes et structures de données/IFT-2008-BinarySearchTreeADT/BinaryTrees/cmake-build-debug-coverage/lib/googletest/googletest/CMakeFiles/gtest.dir/src/gtest-all.cc.gcno
        -:    0:Data:/home/brownthedev/Documents/uLaval/Hiver2021/IFT-2008 Algorithmes et structures de données/IFT-2008-BinarySearchTreeADT/BinaryTrees/cmake-build-debug-coverage/lib/googletest/googletest/CMakeFiles/gtest.dir/src/gtest-all.cc.gcda
        -:    0:Runs:1
        -:    1:// Copyright 2005, Google Inc.
        -:    2:// All rights reserved.
        -:    3://
        -:    4:// Redistribution and use in source and binary forms, with or without
        -:    5:// modification, are permitted provided that the following conditions are
        -:    6:// met:
        -:    7://
        -:    8://     * Redistributions of source code must retain the above copyright
        -:    9:// notice, this list of conditions and the following disclaimer.
        -:   10://     * Redistributions in binary form must reproduce the above
        -:   11:// copyright notice, this list of conditions and the following disclaimer
        -:   12:// in the documentation and/or other materials provided with the
        -:   13:// distribution.
        -:   14://     * Neither the name of Google Inc. nor the names of its
        -:   15:// contributors may be used to endorse or promote products derived from
        -:   16:// this software without specific prior written permission.
        -:   17://
        -:   18:// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        -:   19:// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        -:   20:// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
        -:   21:// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
        -:   22:// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        -:   23:// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
        -:   24:// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        -:   25:// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
        -:   26:// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   27:// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
        -:   28:// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   29:
        -:   30://
        -:   31:// The Google C++ Testing and Mocking Framework (Google Test)
        -:   32:
        -:   33:#include "gtest/gtest.h"
        -:   34:#include "gtest/internal/custom/gtest.h"
        -:   35:#include "gtest/gtest-spi.h"
        -:   36:
        -:   37:#include <ctype.h>
        -:   38:#include <stdarg.h>
        -:   39:#include <stdio.h>
        -:   40:#include <stdlib.h>
        -:   41:#include <time.h>
        -:   42:#include <wchar.h>
        -:   43:#include <wctype.h>
        -:   44:
        -:   45:#include <algorithm>
        -:   46:#include <chrono>  // NOLINT
        -:   47:#include <cmath>
        -:   48:#include <cstdint>
        -:   49:#include <iomanip>
        -:   50:#include <limits>
        -:   51:#include <list>
        -:   52:#include <map>
        -:   53:#include <ostream>  // NOLINT
        -:   54:#include <sstream>
        -:   55:#include <vector>
        -:   56:
        -:   57:#if GTEST_OS_LINUX
        -:   58:
        -:   59:# include <fcntl.h>  // NOLINT
        -:   60:# include <limits.h>  // NOLINT
        -:   61:# include <sched.h>  // NOLINT
        -:   62:// Declares vsnprintf().  This header is not available on Windows.
        -:   63:# include <strings.h>  // NOLINT
        -:   64:# include <sys/mman.h>  // NOLINT
        -:   65:# include <sys/time.h>  // NOLINT
        -:   66:# include <unistd.h>  // NOLINT
        -:   67:# include <string>
        -:   68:
        -:   69:#elif GTEST_OS_ZOS
        -:   70:# include <sys/time.h>  // NOLINT
        -:   71:
        -:   72:// On z/OS we additionally need strings.h for strcasecmp.
        -:   73:# include <strings.h>  // NOLINT
        -:   74:
        -:   75:#elif GTEST_OS_WINDOWS_MOBILE  // We are on Windows CE.
        -:   76:
        -:   77:# include <windows.h>  // NOLINT
        -:   78:# undef min
        -:   79:
        -:   80:#elif GTEST_OS_WINDOWS  // We are on Windows proper.
        -:   81:
        -:   82:# include <windows.h>  // NOLINT
        -:   83:# undef min
        -:   84:
        -:   85:#ifdef _MSC_VER
        -:   86:# include <crtdbg.h>  // NOLINT
        -:   87:#endif
        -:   88:
        -:   89:# include <io.h>  // NOLINT
        -:   90:# include <sys/timeb.h>  // NOLINT
        -:   91:# include <sys/types.h>  // NOLINT
        -:   92:# include <sys/stat.h>  // NOLINT
        -:   93:
        -:   94:# if GTEST_OS_WINDOWS_MINGW
        -:   95:#  include <sys/time.h>  // NOLINT
        -:   96:# endif  // GTEST_OS_WINDOWS_MINGW
        -:   97:
        -:   98:#else
        -:   99:
        -:  100:// cpplint thinks that the header is already included, so we want to
        -:  101:// silence it.
        -:  102:# include <sys/time.h>  // NOLINT
        -:  103:# include <unistd.h>  // NOLINT
        -:  104:
        -:  105:#endif  // GTEST_OS_LINUX
        -:  106:
        -:  107:#if GTEST_HAS_EXCEPTIONS
        -:  108:# include <stdexcept>
        -:  109:#endif
        -:  110:
        -:  111:#if GTEST_CAN_STREAM_RESULTS_
        -:  112:# include <arpa/inet.h>  // NOLINT
        -:  113:# include <netdb.h>  // NOLINT
        -:  114:# include <sys/socket.h>  // NOLINT
        -:  115:# include <sys/types.h>  // NOLINT
        -:  116:#endif
        -:  117:
        -:  118:#include "src/gtest-internal-inl.h"
        -:  119:
        -:  120:#if GTEST_OS_WINDOWS
        -:  121:# define vsnprintf _vsnprintf
        -:  122:#endif  // GTEST_OS_WINDOWS
        -:  123:
        -:  124:#if GTEST_OS_MAC
        -:  125:#ifndef GTEST_OS_IOS
        -:  126:#include <crt_externs.h>
        -:  127:#endif
        -:  128:#endif
        -:  129:
        -:  130:#if GTEST_HAS_ABSL
        -:  131:#include "absl/debugging/failure_signal_handler.h"
        -:  132:#include "absl/debugging/stacktrace.h"
        -:  133:#include "absl/debugging/symbolize.h"
        -:  134:#include "absl/strings/str_cat.h"
        -:  135:#endif  // GTEST_HAS_ABSL
        -:  136:
        -:  137:namespace testing {
        -:  138:
        -:  139:using internal::CountIf;
        -:  140:using internal::ForEach;
        -:  141:using internal::GetElementOr;
        -:  142:using internal::Shuffle;
        -:  143:
        -:  144:// Constants.
        -:  145:
        -:  146:// A test whose test suite name or test name matches this filter is
        -:  147:// disabled and not run.
        -:  148:static const char kDisableTestFilter[] = "DISABLED_*:*/DISABLED_*";
        -:  149:
        -:  150:// A test suite whose name matches this filter is considered a death
        -:  151:// test suite and will be run before test suites whose name doesn't
        -:  152:// match this filter.
        -:  153:static const char kDeathTestSuiteFilter[] = "*DeathTest:*DeathTest/*";
        -:  154:
        -:  155:// A test filter that matches everything.
        -:  156:static const char kUniversalFilter[] = "*";
        -:  157:
        -:  158:// The default output format.
        -:  159:static const char kDefaultOutputFormat[] = "xml";
        -:  160:// The default output file.
        -:  161:static const char kDefaultOutputFile[] = "test_detail";
        -:  162:
        -:  163:// The environment variable name for the test shard index.
        -:  164:static const char kTestShardIndex[] = "GTEST_SHARD_INDEX";
        -:  165:// The environment variable name for the total number of test shards.
        -:  166:static const char kTestTotalShards[] = "GTEST_TOTAL_SHARDS";
        -:  167:// The environment variable name for the test shard status file.
        -:  168:static const char kTestShardStatusFile[] = "GTEST_SHARD_STATUS_FILE";
        -:  169:
        -:  170:namespace internal {
        -:  171:
        -:  172:// The text used in failure messages to indicate the start of the
        -:  173:// stack trace.
        -:  174:const char kStackTraceMarker[] = "\nStack trace:\n";
        -:  175:
        -:  176:// g_help_flag is true if and only if the --help flag or an equivalent form
        -:  177:// is specified on the command line.
        -:  178:bool g_help_flag = false;
        -:  179:
        -:  180:// Utilty function to Open File for Writing
    #####:  181:static FILE* OpenFileForWriting(const std::string& output_file) {
    #####:  182:  FILE* fileout = nullptr;
    #####:  183:  FilePath output_file_path(output_file);
    %%%%%:  183-block  0
    $$$$$:  183-block  1
    #####:  184:  FilePath output_dir(output_file_path.RemoveFileName());
    %%%%%:  184-block  0
    $$$$$:  184-block  1
        -:  185:
    #####:  186:  if (output_dir.CreateDirectoriesRecursively()) {
    %%%%%:  186-block  0
    %%%%%:  186-block  1
    #####:  187:    fileout = posix::FOpen(output_file.c_str(), "w");
    %%%%%:  187-block  0
    %%%%%:  187-block  1
        -:  188:  }
    #####:  189:  if (fileout == nullptr) {
    %%%%%:  189-block  0
    #####:  190:    GTEST_LOG_(FATAL) << "Unable to open file \"" << output_file << "\"";
    %%%%%:  190-block  0
    %%%%%:  190-block  1
    %%%%%:  190-block  2
    %%%%%:  190-block  3
    %%%%%:  190-block  4
    $$$$$:  190-block  5
    $$$$$:  190-block  6
        -:  191:  }
    #####:  192:  return fileout;
    %%%%%:  192-block  0
    %%%%%:  192-block  1
        -:  193:}
        -:  194:
        -:  195:}  // namespace internal
        -:  196:
        -:  197:// Bazel passes in the argument to '--test_filter' via the TESTBRIDGE_TEST_ONLY
        -:  198:// environment variable.
        1:  199:static const char* GetDefaultFilter() {
        -:  200:  const char* const testbridge_test_only =
        1:  201:      internal::posix::GetEnv("TESTBRIDGE_TEST_ONLY");
        1:  201-block  0
        1:  202:  if (testbridge_test_only != nullptr) {
    #####:  203:    return testbridge_test_only;
    %%%%%:  203-block  0
        -:  204:  }
        1:  205:  return kUniversalFilter;
        1:  205-block  0
        -:  206:}
        -:  207:
        -:  208:// Bazel passes in the argument to '--test_runner_fail_fast' via the
        -:  209:// TESTBRIDGE_TEST_RUNNER_FAIL_FAST environment variable.
        1:  210:static bool GetDefaultFailFast() {
        -:  211:  const char* const testbridge_test_runner_fail_fast =
        1:  212:      internal::posix::GetEnv("TESTBRIDGE_TEST_RUNNER_FAIL_FAST");
        1:  212-block  0
        1:  213:  if (testbridge_test_runner_fail_fast != nullptr) {
    #####:  214:    return strcmp(testbridge_test_runner_fail_fast, "1") == 0;
    %%%%%:  214-block  0
        -:  215:  }
        1:  216:  return false;
        1:  216-block  0
        -:  217:}
        -:  218:
        -:  219:GTEST_DEFINE_bool_(
        -:  220:    fail_fast, internal::BoolFromGTestEnv("fail_fast", GetDefaultFailFast()),
        -:  221:    "True if and only if a test failure should stop further test execution.");
        -:  222:
        -:  223:GTEST_DEFINE_bool_(
        -:  224:    also_run_disabled_tests,
        -:  225:    internal::BoolFromGTestEnv("also_run_disabled_tests", false),
        -:  226:    "Run disabled tests too, in addition to the tests normally being run.");
        -:  227:
        -:  228:GTEST_DEFINE_bool_(
        -:  229:    break_on_failure, internal::BoolFromGTestEnv("break_on_failure", false),
        -:  230:    "True if and only if a failed assertion should be a debugger "
        -:  231:    "break-point.");
        -:  232:
        -:  233:GTEST_DEFINE_bool_(catch_exceptions,
        -:  234:                   internal::BoolFromGTestEnv("catch_exceptions", true),
        -:  235:                   "True if and only if " GTEST_NAME_
        -:  236:                   " should catch exceptions and treat them as test failures.");
        -:  237:
        -:  238:GTEST_DEFINE_string_(
        -:  239:    color,
        -:  240:    internal::StringFromGTestEnv("color", "auto"),
        -:  241:    "Whether to use colors in the output.  Valid values: yes, no, "
        -:  242:    "and auto.  'auto' means to use colors if the output is "
        -:  243:    "being sent to a terminal and the TERM environment variable "
        -:  244:    "is set to a terminal type that supports colors.");
        -:  245:
        -:  246:GTEST_DEFINE_string_(
        -:  247:    filter,
        -:  248:    internal::StringFromGTestEnv("filter", GetDefaultFilter()),
        -:  249:    "A colon-separated list of glob (not regex) patterns "
        -:  250:    "for filtering the tests to run, optionally followed by a "
        -:  251:    "'-' and a : separated list of negative patterns (tests to "
        -:  252:    "exclude).  A test is run if it matches one of the positive "
        -:  253:    "patterns and does not match any of the negative patterns.");
        -:  254:
        -:  255:GTEST_DEFINE_bool_(
        -:  256:    install_failure_signal_handler,
        -:  257:    internal::BoolFromGTestEnv("install_failure_signal_handler", false),
        -:  258:    "If true and supported on the current platform, " GTEST_NAME_ " should "
        -:  259:    "install a signal handler that dumps debugging information when fatal "
        -:  260:    "signals are raised.");
        -:  261:
        -:  262:GTEST_DEFINE_bool_(list_tests, false,
        -:  263:                   "List all tests without running them.");
        -:  264:
        -:  265:// The net priority order after flag processing is thus:
        -:  266://   --gtest_output command line flag
        -:  267://   GTEST_OUTPUT environment variable
        -:  268://   XML_OUTPUT_FILE environment variable
        -:  269://   ''
        -:  270:GTEST_DEFINE_string_(
        -:  271:    output,
        -:  272:    internal::StringFromGTestEnv("output",
        -:  273:      internal::OutputFlagAlsoCheckEnvVar().c_str()),
        -:  274:    "A format (defaults to \"xml\" but can be specified to be \"json\"), "
        -:  275:    "optionally followed by a colon and an output file name or directory. "
        -:  276:    "A directory is indicated by a trailing pathname separator. "
        -:  277:    "Examples: \"xml:filename.xml\", \"xml::directoryname/\". "
        -:  278:    "If a directory is specified, output files will be created "
        -:  279:    "within that directory, with file-names based on the test "
        -:  280:    "executable's name and, if necessary, made unique by adding "
        -:  281:    "digits.");
        -:  282:
        -:  283:GTEST_DEFINE_bool_(
        -:  284:    brief, internal::BoolFromGTestEnv("brief", false),
        -:  285:    "True if only test failures should be displayed in text output.");
        -:  286:
        -:  287:GTEST_DEFINE_bool_(print_time, internal::BoolFromGTestEnv("print_time", true),
        -:  288:                   "True if and only if " GTEST_NAME_
        -:  289:                   " should display elapsed time in text output.");
        -:  290:
        -:  291:GTEST_DEFINE_bool_(print_utf8, internal::BoolFromGTestEnv("print_utf8", true),
        -:  292:                   "True if and only if " GTEST_NAME_
        -:  293:                   " prints UTF8 characters as text.");
        -:  294:
        -:  295:GTEST_DEFINE_int32_(
        -:  296:    random_seed,
        -:  297:    internal::Int32FromGTestEnv("random_seed", 0),
        -:  298:    "Random number seed to use when shuffling test orders.  Must be in range "
        -:  299:    "[1, 99999], or 0 to use a seed based on the current time.");
        -:  300:
        -:  301:GTEST_DEFINE_int32_(
        -:  302:    repeat,
        -:  303:    internal::Int32FromGTestEnv("repeat", 1),
        -:  304:    "How many times to repeat each test.  Specify a negative number "
        -:  305:    "for repeating forever.  Useful for shaking out flaky tests.");
        -:  306:
        -:  307:GTEST_DEFINE_bool_(show_internal_stack_frames, false,
        -:  308:                   "True if and only if " GTEST_NAME_
        -:  309:                   " should include internal stack frames when "
        -:  310:                   "printing test failure stack traces.");
        -:  311:
        -:  312:GTEST_DEFINE_bool_(shuffle, internal::BoolFromGTestEnv("shuffle", false),
        -:  313:                   "True if and only if " GTEST_NAME_
        -:  314:                   " should randomize tests' order on every run.");
        -:  315:
        -:  316:GTEST_DEFINE_int32_(
        -:  317:    stack_trace_depth,
        -:  318:    internal::Int32FromGTestEnv("stack_trace_depth", kMaxStackTraceDepth),
        -:  319:    "The maximum number of stack frames to print when an "
        -:  320:    "assertion fails.  The valid range is 0 through 100, inclusive.");
        -:  321:
        -:  322:GTEST_DEFINE_string_(
        -:  323:    stream_result_to,
        -:  324:    internal::StringFromGTestEnv("stream_result_to", ""),
        -:  325:    "This flag specifies the host name and the port number on which to stream "
        -:  326:    "test results. Example: \"localhost:555\". The flag is effective only on "
        -:  327:    "Linux.");
        -:  328:
        -:  329:GTEST_DEFINE_bool_(
        -:  330:    throw_on_failure,
        -:  331:    internal::BoolFromGTestEnv("throw_on_failure", false),
        -:  332:    "When this flag is specified, a failed assertion will throw an exception "
        -:  333:    "if exceptions are enabled or exit the program with a non-zero code "
        -:  334:    "otherwise. For use with an external test framework.");
        -:  335:
        -:  336:#if GTEST_USE_OWN_FLAGFILE_FLAG_
        -:  337:GTEST_DEFINE_string_(
        -:  338:    flagfile,
        -:  339:    internal::StringFromGTestEnv("flagfile", ""),
        -:  340:    "This flag specifies the flagfile to read command-line flags from.");
        -:  341:#endif  // GTEST_USE_OWN_FLAGFILE_FLAG_
        -:  342:
        -:  343:namespace internal {
        -:  344:
        -:  345:// Generates a random number from [0, range), using a Linear
        -:  346:// Congruential Generator (LCG).  Crashes if 'range' is 0 or greater
        -:  347:// than kMaxRange.
    #####:  348:uint32_t Random::Generate(uint32_t range) {
        -:  349:  // These constants are the same as are used in glibc's rand(3).
        -:  350:  // Use wider types than necessary to prevent unsigned overflow diagnostics.
    #####:  351:  state_ = static_cast<uint32_t>(1103515245ULL*state_ + 12345U) % kMaxRange;
        -:  352:
    #####:  353:  GTEST_CHECK_(range > 0)
    %%%%%:  353-block  0
    %%%%%:  353-block  1
    %%%%%:  353-block  2
    $$$$$:  353-block  3
    $$$$$:  353-block  4
    #####:  354:      << "Cannot generate a number in the range [0, 0).";
    %%%%%:  354-block  0
    #####:  355:  GTEST_CHECK_(range <= kMaxRange)
    %%%%%:  355-block  0
    %%%%%:  355-block  1
    %%%%%:  355-block  2
    $$$$$:  355-block  3
    #####:  356:      << "Generation of a number in [0, " << range << ") was requested, "
    %%%%%:  356-block  0
    %%%%%:  356-block  1
    #####:  357:      << "but this can only generate numbers in [0, " << kMaxRange << ").";
    %%%%%:  357-block  0
    %%%%%:  357-block  1
    %%%%%:  357-block  2
    %%%%%:  357-block  3
        -:  358:
        -:  359:  // Converting via modulus introduces a bit of downward bias, but
        -:  360:  // it's simple, and a linear congruential generator isn't too good
        -:  361:  // to begin with.
    #####:  362:  return state_ % range;
    %%%%%:  362-block  0
    %%%%%:  362-block  1
        -:  363:}
        -:  364:
        -:  365:// GTestIsInitialized() returns true if and only if the user has initialized
        -:  366:// Google Test.  Useful for catching the user mistake of not initializing
        -:  367:// Google Test before calling RUN_ALL_TESTS().
        2:  368:static bool GTestIsInitialized() { return GetArgvs().size() > 0; }
        2:  368-block  0
        -:  369:
        -:  370:// Iterates over a vector of TestSuites, keeping a running sum of the
        -:  371:// results of calling a given int-returning method on each.
        -:  372:// Returns the sum.
        5:  373:static int SumOverTestSuiteList(const std::vector<TestSuite*>& case_list,
        -:  374:                                int (TestSuite::*method)() const) {
        5:  375:  int sum = 0;
       15:  376:  for (size_t i = 0; i < case_list.size(); i++) {
        5:  376-block  0
       15:  376-block  1
      10*:  377:    sum += (case_list[i]->*method)();
       10:  377-block  0
    %%%%%:  377-block  1
       10:  377-block  2
       10:  377-block  3
        -:  378:  }
        5:  379:  return sum;
        5:  379-block  0
        -:  380:}
        -:  381:
        -:  382:// Returns true if and only if the test suite passed.
    #####:  383:static bool TestSuitePassed(const TestSuite* test_suite) {
    #####:  384:  return test_suite->should_run() && test_suite->Passed();
    %%%%%:  384-block  0
    %%%%%:  384-block  1
    %%%%%:  384-block  2
    %%%%%:  384-block  3
    %%%%%:  384-block  4
        -:  385:}
        -:  386:
        -:  387:// Returns true if and only if the test suite failed.
        4:  388:static bool TestSuiteFailed(const TestSuite* test_suite) {
       4*:  389:  return test_suite->should_run() && test_suite->Failed();
        4:  389-block  0
        2:  389-block  1
    %%%%%:  389-block  2
        4:  389-block  3
        4:  389-block  4
        -:  390:}
        -:  391:
        -:  392:// Returns true if and only if test_suite contains at least one test that
        -:  393:// should run.
        4:  394:static bool ShouldRunTestSuite(const TestSuite* test_suite) {
        4:  395:  return test_suite->should_run();
        4:  395-block  0
        -:  396:}
        -:  397:
        -:  398:// AssertHelper constructor.
    #####:  399:AssertHelper::AssertHelper(TestPartResult::Type type,
        -:  400:                           const char* file,
        -:  401:                           int line,
    #####:  402:                           const char* message)
    #####:  403:    : data_(new AssertHelperData(type, file, line, message)) {
    %%%%%:  403-block  0
    $$$$$:  403-block  1
    #####:  404:}
    %%%%%:  404-block  0
        -:  405:
    #####:  406:AssertHelper::~AssertHelper() {
    #####:  407:  delete data_;
    %%%%%:  407-block  0
    %%%%%:  407-block  1
    #####:  408:}
        -:  409:
        -:  410:// Message assignment, for assertion streaming support.
    #####:  411:void AssertHelper::operator=(const Message& message) const {
        -:  412:  UnitTest::GetInstance()->
    #####:  413:    AddTestPartResult(data_->type, data_->file, data_->line,
    %%%%%:  413-block  0
    %%%%%:  413-block  1
    #####:  414:                      AppendUserMessage(data_->message, message),
    %%%%%:  414-block  0
    $$$$$:  414-block  1
    $$$$$:  414-block  2
        -:  415:                      UnitTest::GetInstance()->impl()
    #####:  416:                      ->CurrentOsStackTraceExceptTop(1)
    $$$$$:  416-block  0
        -:  417:                      // Skips the stack frame for this function itself.
        -:  418:                      );  // NOLINT
    #####:  419:}
        -:  420:
        -:  421:namespace {
        -:  422:
        -:  423:// When TEST_P is found without a matching INSTANTIATE_TEST_SUITE_P
        -:  424:// to creates test cases for it, a syntetic test case is
        -:  425:// inserted to report ether an error or a log message.
        -:  426://
        -:  427:// This configuration bit will likely be removed at some point.
        -:  428:constexpr bool kErrorOnUninstantiatedParameterizedTest = true;
        -:  429:constexpr bool kErrorOnUninstantiatedTypeParameterizedTest = true;
        -:  430:
        -:  431:// A test that fails at a given file/line location with a given message.
        -:  432:class FailureTest : public Test {
        -:  433: public:
    #####:  434:  explicit FailureTest(const CodeLocation& loc, std::string error_message,
        -:  435:                       bool as_error)
    #####:  436:      : loc_(loc),
    #####:  437:        error_message_(std::move(error_message)),
    #####:  438:        as_error_(as_error) {}
    %%%%%:  438-block  0
    %%%%%:  438-block  1
    $$$$$:  438-block  2
        -:  439:
    #####:  440:  void TestBody() override {
    #####:  441:    if (as_error_) {
    %%%%%:  441-block  0
    #####:  442:      AssertHelper(TestPartResult::kNonFatalFailure, loc_.file.c_str(),
    %%%%%:  442-block  0
    $$$$$:  442-block  1
    $$$$$:  442-block  2
    #####:  443:                   loc_.line, "") = Message() << error_message_;
    %%%%%:  443-block  0
    %%%%%:  443-block  1
    %%%%%:  443-block  2
    $$$$$:  443-block  3
        -:  444:    } else {
    #####:  445:      std::cout << error_message_ << std::endl;
    %%%%%:  445-block  0
        -:  446:    }
    #####:  447:  }
    %%%%%:  447-block  0
        -:  448:
        -:  449: private:
        -:  450:  const CodeLocation loc_;
        -:  451:  const std::string error_message_;
        -:  452:  const bool as_error_;
        -:  453:};
        -:  454:
        -:  455:
        -:  456:}  // namespace
        -:  457:
        1:  458:std::set<std::string>* GetIgnoredParameterizedTestSuites() {
        1:  459:  return UnitTest::GetInstance()->impl()->ignored_parameterized_test_suites();
        1:  459-block  0
        -:  460:}
        -:  461:
        -:  462:// Add a given test_suit to the list of them allow to go un-instantiated.
    #####:  463:MarkAsIgnored::MarkAsIgnored(const char* test_suite) {
    #####:  464:  GetIgnoredParameterizedTestSuites()->insert(test_suite);
    %%%%%:  464-block  0
    %%%%%:  464-block  1
    %%%%%:  464-block  2
    $$$$$:  464-block  3
    $$$$$:  464-block  4
    $$$$$:  464-block  5
    #####:  465:}
        -:  466:
        -:  467:// If this parameterized test suite has no instantiations (and that
        -:  468:// has not been marked as okay), emit a test case reporting that.
    #####:  469:void InsertSyntheticTestCase(const std::string& name, CodeLocation location,
        -:  470:                             bool has_test_p) {
    #####:  471:  const auto& ignored = *GetIgnoredParameterizedTestSuites();
    %%%%%:  471-block  0
    #####:  472:  if (ignored.find(name) != ignored.end()) return;
    %%%%%:  472-block  0
    %%%%%:  472-block  1
    %%%%%:  472-block  2
    $$$$$:  472-block  3
        -:  473:
    #####:  474:  const char kMissingInstantiation[] =  //
        -:  475:      " is defined via TEST_P, but never instantiated. None of the test cases "
        -:  476:      "will run. Either no INSTANTIATE_TEST_SUITE_P is provided or the only "
        -:  477:      "ones provided expand to nothing."
        -:  478:      "\n\n"
        -:  479:      "Ideally, TEST_P definitions should only ever be included as part of "
        -:  480:      "binaries that intend to use them. (As opposed to, for example, being "
        -:  481:      "placed in a library that may be linked in to get other utilities.)";
        -:  482:
    #####:  483:  const char kMissingTestCase[] =  //
        -:  484:      " is instantiated via INSTANTIATE_TEST_SUITE_P, but no tests are "
        -:  485:      "defined via TEST_P . No test cases will run."
        -:  486:      "\n\n"
        -:  487:      "Ideally, INSTANTIATE_TEST_SUITE_P should only ever be invoked from "
        -:  488:      "code that always depend on code that provides TEST_P. Failing to do "
        -:  489:      "so is often an indication of dead code, e.g. the last TEST_P was "
        -:  490:      "removed but the rest got left behind.";
        -:  491:
        -:  492:  std::string message =
    #####:  493:      "Parameterized test suite " + name +
    %%%%%:  493-block  0
    %%%%%:  493-block  1
    %%%%%:  493-block  2
    %%%%%:  493-block  3
    %%%%%:  493-block  4
    $$$$$:  493-block  5
    $$$$$:  493-block  6
    #####:  494:      (has_test_p ? kMissingInstantiation : kMissingTestCase) +
    %%%%%:  494-block  0
    $$$$$:  494-block  1
        -:  495:      "\n\n"
        -:  496:      "To suppress this error for this test suite, insert the following line "
        -:  497:      "(in a non-header) in the namespace it is defined in:"
        -:  498:      "\n\n"
    #####:  499:      "GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(" + name + ");";
    %%%%%:  499-block  0
    %%%%%:  499-block  1
    $$$$$:  499-block  2
    $$$$$:  499-block  3
        -:  500:
    #####:  501:  std::string full_name = "UninstantiatedParameterizedTestSuite<" + name + ">";
    %%%%%:  501-block  0
    $$$$$:  501-block  1
    $$$$$:  501-block  2
    #####:  502:  RegisterTest(  //
    %%%%%:  502-block  0
    %%%%%:  502-block  1
    %%%%%:  502-block  2
    $$$$$:  502-block  3
    $$$$$:  502-block  4
        -:  503:      "GoogleTestVerification", full_name.c_str(),
        -:  504:      nullptr,  // No type parameter.
        -:  505:      nullptr,  // No value parameter.
    #####:  506:      location.file.c_str(), location.line, [message, location] {
    #####:  507:        return new FailureTest(location, message,
    #####:  508:                               kErrorOnUninstantiatedParameterizedTest);
    %%%%%:  508-block  0
    %%%%%:  508-block  1
    %%%%%:  508-block  2
    %%%%%:  508-block  3
    $$$$$:  508-block  4
    $$$$$:  508-block  5
        -:  509:      });
        -:  510:}
        -:  511:
    #####:  512:void RegisterTypeParameterizedTestSuite(const char* test_suite_name,
        -:  513:                                        CodeLocation code_location) {
    #####:  514:  GetUnitTestImpl()->type_parameterized_test_registry().RegisterTestSuite(
    %%%%%:  514-block  0
    %%%%%:  514-block  1
    $$$$$:  514-block  2
        -:  515:      test_suite_name, code_location);
    #####:  516:}
        -:  517:
    #####:  518:void RegisterTypeParameterizedTestSuiteInstantiation(const char* case_name) {
        -:  519:  GetUnitTestImpl()
    #####:  520:      ->type_parameterized_test_registry()
    %%%%%:  520-block  0
    #####:  521:      .RegisterInstantiation(case_name);
    #####:  522:}
        -:  523:
    #####:  524:void TypeParameterizedTestSuiteRegistry::RegisterTestSuite(
        -:  525:    const char* test_suite_name, CodeLocation code_location) {
    #####:  526:  suites_.emplace(std::string(test_suite_name),
    %%%%%:  526-block  0
    %%%%%:  526-block  1
    $$$$$:  526-block  2
    $$$$$:  526-block  3
    $$$$$:  526-block  4
    $$$$$:  526-block  5
    #####:  527:                 TypeParameterizedTestSuiteInfo(code_location));
    %%%%%:  527-block  0
    %%%%%:  527-block  1
    $$$$$:  527-block  2
    $$$$$:  527-block  3
    $$$$$:  527-block  4
    #####:  528:}
        -:  529:
    #####:  530:void TypeParameterizedTestSuiteRegistry::RegisterInstantiation(
        -:  531:        const char* test_suite_name) {
    #####:  532:  auto it = suites_.find(std::string(test_suite_name));
    %%%%%:  532-block  0
    %%%%%:  532-block  1
    %%%%%:  532-block  2
    $$$$$:  532-block  3
    $$$$$:  532-block  4
    $$$$$:  532-block  5
    $$$$$:  532-block  6
    #####:  533:  if (it != suites_.end()) {
    #####:  534:    it->second.instantiated = true;
    %%%%%:  534-block  0
        -:  535:  } else {
    #####:  536:    GTEST_LOG_(ERROR) << "Unknown type parameterized test suit '"
    %%%%%:  536-block  0
    %%%%%:  536-block  1
    %%%%%:  536-block  2
    $$$$$:  536-block  3
    $$$$$:  536-block  4
    #####:  537:                      << test_suite_name << "'";
    %%%%%:  537-block  0
    %%%%%:  537-block  1
        -:  538:  }
    #####:  539:}
    %%%%%:  539-block  0
        -:  540:
        1:  541:void TypeParameterizedTestSuiteRegistry::CheckForInstantiations() {
        1:  542:  const auto& ignored = *GetIgnoredParameterizedTestSuites();
        1:  542-block  0
       1*:  543:  for (const auto& testcase : suites_) {
        1:  543-block  0
    %%%%%:  543-block  1
    %%%%%:  543-block  2
    #####:  544:    if (testcase.second.instantiated) continue;
    %%%%%:  544-block  0
    %%%%%:  544-block  1
    #####:  545:    if (ignored.find(testcase.first) != ignored.end()) continue;
    %%%%%:  545-block  0
    %%%%%:  545-block  1
    %%%%%:  545-block  2
    $$$$$:  545-block  3
        -:  546:
        -:  547:    std::string message =
    #####:  548:        "Type parameterized test suite " + testcase.first +
    %%%%%:  548-block  0
    $$$$$:  548-block  1
    $$$$$:  548-block  2
        -:  549:        " is defined via REGISTER_TYPED_TEST_SUITE_P, but never instantiated "
        -:  550:        "via INSTANTIATE_TYPED_TEST_SUITE_P. None of the test cases will run."
        -:  551:        "\n\n"
        -:  552:        "Ideally, TYPED_TEST_P definitions should only ever be included as "
        -:  553:        "part of binaries that intend to use them. (As opposed to, for "
        -:  554:        "example, being placed in a library that may be linked in to get other "
        -:  555:        "utilities.)"
        -:  556:        "\n\n"
        -:  557:        "To suppress this error for this test suite, insert the following line "
        -:  558:        "(in a non-header) in the namespace it is defined in:"
        -:  559:        "\n\n"
    #####:  560:        "GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(" +
    %%%%%:  560-block  0
    $$$$$:  560-block  1
    #####:  561:        testcase.first + ");";
    %%%%%:  561-block  0
    %%%%%:  561-block  1
    $$$$$:  561-block  2
        -:  562:
        -:  563:    std::string full_name =
    #####:  564:        "UninstantiatedTypeParameterizedTestSuite<" + testcase.first + ">";
    %%%%%:  564-block  0
    $$$$$:  564-block  1
    $$$$$:  564-block  2
    #####:  565:    RegisterTest(  //
    %%%%%:  565-block  0
    %%%%%:  565-block  1
    $$$$$:  565-block  2
    $$$$$:  565-block  3
        -:  566:        "GoogleTestVerification", full_name.c_str(),
        -:  567:        nullptr,  // No type parameter.
        -:  568:        nullptr,  // No value parameter.
        -:  569:        testcase.second.code_location.file.c_str(),
    #####:  570:        testcase.second.code_location.line, [message, testcase] {
    %%%%%:  570-block  0
    #####:  571:          return new FailureTest(testcase.second.code_location, message,
    #####:  572:                                 kErrorOnUninstantiatedTypeParameterizedTest);
    %%%%%:  572-block  0
    %%%%%:  572-block  1
    %%%%%:  572-block  2
    %%%%%:  572-block  3
    $$$$$:  572-block  4
    $$$$$:  572-block  5
        -:  573:        });
        -:  574:  }
        1:  575:}
        1:  575-block  0
        -:  576:
        -:  577:// A copy of all command line arguments.  Set by InitGoogleTest().
        -:  578:static ::std::vector<std::string> g_argvs;
        -:  579:
        2:  580:::std::vector<std::string> GetArgvs() {
        -:  581:#if defined(GTEST_CUSTOM_GET_ARGVS_)
        -:  582:  // GTEST_CUSTOM_GET_ARGVS_() may return a container of std::string or
        -:  583:  // ::string. This code converts it to the appropriate type.
        -:  584:  const auto& custom = GTEST_CUSTOM_GET_ARGVS_();
        -:  585:  return ::std::vector<std::string>(custom.begin(), custom.end());
        -:  586:#else   // defined(GTEST_CUSTOM_GET_ARGVS_)
        2:  587:  return g_argvs;
        2:  587-block  0
        -:  588:#endif  // defined(GTEST_CUSTOM_GET_ARGVS_)
        -:  589:}
        -:  590:
        -:  591:// Returns the current application's name, removing directory path if that
        -:  592:// is present.
    #####:  593:FilePath GetCurrentExecutableName() {
    #####:  594:  FilePath result;
    %%%%%:  594-block  0
    %%%%%:  594-block  1
    $$$$$:  594-block  2
        -:  595:
        -:  596:#if GTEST_OS_WINDOWS || GTEST_OS_OS2
        -:  597:  result.Set(FilePath(GetArgvs()[0]).RemoveExtension("exe"));
        -:  598:#else
    #####:  599:  result.Set(FilePath(GetArgvs()[0]));
    %%%%%:  599-block  0
    %%%%%:  599-block  1
    %%%%%:  599-block  2
    %%%%%:  599-block  3
    $$$$$:  599-block  4
    $$$$$:  599-block  5
    $$$$$:  599-block  6
    $$$$$:  599-block  7
        -:  600:#endif  // GTEST_OS_WINDOWS
        -:  601:
    #####:  602:  return result.RemoveDirectoryName();
    %%%%%:  602-block  0
        -:  603:}
        -:  604:
        -:  605:// Functions for processing the gtest_output flag.
        -:  606:
        -:  607:// Returns the output format, or "" for normal printed output.
        1:  608:std::string UnitTestOptions::GetOutputFormat() {
        1:  609:  const char* const gtest_output_flag = GTEST_FLAG(output).c_str();
        1:  609-block  0
        1:  610:  const char* const colon = strchr(gtest_output_flag, ':');
        -:  611:  return (colon == nullptr)
        -:  612:             ? std::string(gtest_output_flag)
        -:  613:             : std::string(gtest_output_flag,
       1*:  614:                           static_cast<size_t>(colon - gtest_output_flag));
        1:  614-block  0
    %%%%%:  614-block  1
        1:  614-block  2
    %%%%%:  614-block  3
        1:  614-block  4
        1:  614-block  5
        1:  614-block  6
        1:  614-block  7
    $$$$$:  614-block  8
    $$$$$:  614-block  9
    $$$$$:  614-block 10
    $$$$$:  614-block 11
    $$$$$:  614-block 12
        -:  615:}
        -:  616:
        -:  617:// Returns the name of the requested output file, or the default if none
        -:  618:// was explicitly specified.
    #####:  619:std::string UnitTestOptions::GetAbsolutePathToOutputFile() {
    #####:  620:  const char* const gtest_output_flag = GTEST_FLAG(output).c_str();
    %%%%%:  620-block  0
        -:  621:
    #####:  622:  std::string format = GetOutputFormat();
    %%%%%:  622-block  0
    $$$$$:  622-block  1
    #####:  623:  if (format.empty())
    %%%%%:  623-block  0
    #####:  624:    format = std::string(kDefaultOutputFormat);
    %%%%%:  624-block  0
    %%%%%:  624-block  1
    $$$$$:  624-block  2
    $$$$$:  624-block  3
        -:  625:
    #####:  626:  const char* const colon = strchr(gtest_output_flag, ':');
    #####:  627:  if (colon == nullptr)
    %%%%%:  627-block  0
    #####:  628:    return internal::FilePath::MakeFileName(
    %%%%%:  628-block  0
    %%%%%:  628-block  1
    %%%%%:  628-block  2
    $$$$$:  628-block  3
    $$$$$:  628-block  4
    #####:  629:        internal::FilePath(
    %%%%%:  629-block  0
    %%%%%:  629-block  1
    %%%%%:  629-block  2
    $$$$$:  629-block  3
    $$$$$:  629-block  4
    $$$$$:  629-block  5
    $$$$$:  629-block  6
    $$$$$:  629-block  7
    $$$$$:  629-block  8
        -:  630:            UnitTest::GetInstance()->original_working_dir()),
    #####:  631:        internal::FilePath(kDefaultOutputFile), 0,
    %%%%%:  631-block  0
    $$$$$:  631-block  1
    $$$$$:  631-block  2
    $$$$$:  631-block  3
    $$$$$:  631-block  4
    $$$$$:  631-block  5
    $$$$$:  631-block  6
    #####:  632:        format.c_str()).string();
    %%%%%:  632-block  0
        -:  633:
    #####:  634:  internal::FilePath output_name(colon + 1);
    %%%%%:  634-block  0
    %%%%%:  634-block  1
    %%%%%:  634-block  2
    $$$$$:  634-block  3
    $$$$$:  634-block  4
    $$$$$:  634-block  5
    #####:  635:  if (!output_name.IsAbsolutePath())
    #####:  636:    output_name = internal::FilePath::ConcatPaths(
    %%%%%:  636-block  0
    %%%%%:  636-block  1
    $$$$$:  636-block  2
    $$$$$:  636-block  3
    #####:  637:        internal::FilePath(UnitTest::GetInstance()->original_working_dir()),
    %%%%%:  637-block  0
    %%%%%:  637-block  1
    %%%%%:  637-block  2
    $$$$$:  637-block  3
    $$$$$:  637-block  4
    $$$$$:  637-block  5
    $$$$$:  637-block  6
    $$$$$:  637-block  7
    $$$$$:  637-block  8
    #####:  638:        internal::FilePath(colon + 1));
    %%%%%:  638-block  0
    %%%%%:  638-block  1
    %%%%%:  638-block  2
    $$$$$:  638-block  3
    $$$$$:  638-block  4
    $$$$$:  638-block  5
    $$$$$:  638-block  6
    $$$$$:  638-block  7
    $$$$$:  638-block  8
        -:  639:
    #####:  640:  if (!output_name.IsDirectory())
    %%%%%:  640-block  0
    #####:  641:    return output_name.string();
    %%%%%:  641-block  0
        -:  642:
        -:  643:  internal::FilePath result(internal::FilePath::GenerateUniqueFileName(
    #####:  644:      output_name, internal::GetCurrentExecutableName(),
    $$$$$:  644-block  0
    #####:  645:      GetOutputFormat().c_str()));
    %%%%%:  645-block  0
    %%%%%:  645-block  1
    %%%%%:  645-block  2
    %%%%%:  645-block  3
    $$$$$:  645-block  4
    $$$$$:  645-block  5
    #####:  646:  return result.string();
        -:  647:}
        -:  648:
        -:  649:// Returns true if and only if the wildcard pattern matches the string. Each
        -:  650:// pattern consists of regular characters, single-character wildcards (?), and
        -:  651:// multi-character wildcards (*).
        -:  652://
        -:  653:// This function implements a linear-time string globbing algorithm based on
        -:  654:// https://research.swtch.com/glob.
      270:  655:static bool PatternMatchesString(const std::string& name_str,
        -:  656:                                 const char* pattern, const char* pattern_end) {
      270:  657:  const char* name = name_str.c_str();
      270:  657-block  0
      270:  658:  const char* const name_begin = name;
      270:  659:  const char* const name_end = name + name_str.size();
        -:  660:
      270:  661:  const char* pattern_next = pattern;
      270:  662:  const char* name_next = name;
        -:  663:
    12260:  664:  while (pattern < pattern_end || name < name_end) {
    12260:  664-block  0
     1523:  664-block  1
    11990:  664-block  2
    12229:  665:    if (pattern < pattern_end) {
    12229:  665-block  0
    10737:  666:      switch (*pattern) {
    10737:  666-block  0
     4999:  667:        default:  // Match an ordinary character.
     4999:  668:          if (name < name_end && *name == *pattern) {
     4999:  668-block  0
     4893:  668-block  1
      651:  669:            ++pattern;
      651:  670:            ++name;
      651:  671:            continue;
      651:  671-block  0
        -:  672:          }
     4348:  673:          break;
     4348:  673-block  0
    #####:  674:        case '?':  // Match any single character.
    #####:  675:          if (name < name_end) {
    %%%%%:  675-block  0
    #####:  676:            ++pattern;
    #####:  677:            ++name;
    #####:  678:            continue;
    %%%%%:  678-block  0
        -:  679:          }
    #####:  680:          break;
    %%%%%:  680-block  0
     5738:  681:        case '*':
        -:  682:          // Match zero or more characters. Start by skipping over the wildcard
        -:  683:          // and matching zero characters from name. If that fails, restart and
        -:  684:          // match one more character than the last attempt.
     5738:  685:          pattern_next = pattern;
     5738:  686:          name_next = name + 1;
     5738:  687:          ++pattern;
     5738:  688:          continue;
     5738:  688-block  0
        -:  689:      }
        -:  690:    }
        -:  691:    // Failed to match a character. Restart if possible.
     5840:  692:    if (name_begin < name_next && name_next <= name_end) {
     5840:  692-block  0
     5707:  692-block  1
     5601:  693:      pattern = pattern_next;
     5601:  694:      name = name_next;
     5601:  695:      continue;
     5601:  695-block  0
        -:  696:    }
      239:  697:    return false;
      239:  697-block  0
        -:  698:  }
       31:  699:  return true;
       31:  699-block  0
        -:  700:}
        -:  701:
      156:  702:bool UnitTestOptions::MatchesFilter(const std::string& name_str,
        -:  703:                                    const char* filter) {
        -:  704:  // The filter is a list of patterns separated by colons (:).
      156:  705:  const char* pattern = filter;
      156:  705-block  0
        -:  706:  while (true) {
        -:  707:    // Find the bounds of this pattern.
      270:  708:    const char* const next_sep = strchr(pattern, ':');
      270:  709:    const char* const pattern_end =
      270:  710:        next_sep != nullptr ? next_sep : pattern + strlen(pattern);
      270:  710-block  0
      125:  710-block  1
      145:  710-block  2
        -:  711:
        -:  712:    // Check if this pattern matches name_str.
      270:  713:    if (PatternMatchesString(name_str, pattern, pattern_end)) {
      270:  713-block  0
       31:  714:      return true;
       31:  714-block  0
        -:  715:    }
        -:  716:
        -:  717:    // Give up on this pattern. However, if we found a pattern separator (:),
        -:  718:    // advance to the next pattern (skipping over the separator) and restart.
      239:  719:    if (next_sep == nullptr) {
      239:  719-block  0
      125:  720:      return false;
      125:  720-block  0
        -:  721:    }
      114:  722:    pattern = next_sep + 1;
      114:  723:  }
      114:  723-block  0
        -:  724:  return true;
        -:  725:}
        -:  726:
        -:  727:// Returns true if and only if the user-specified filter matches the test
        -:  728:// suite name and the test name.
       41:  729:bool UnitTestOptions::FilterMatchesTest(const std::string& test_suite_name,
        -:  730:                                        const std::string& test_name) {
       82:  731:  const std::string& full_name = test_suite_name + "." + test_name.c_str();
       41:  731-block  0
       41:  731-block  1
       41:  731-block  2
    $$$$$:  731-block  3
    $$$$$:  731-block  4
    $$$$$:  731-block  5
        -:  732:
        -:  733:  // Split --gtest_filter at '-', if there is one, to separate into
        -:  734:  // positive filter and negative filter portions
       41:  735:  const char* const p = GTEST_FLAG(filter).c_str();
       41:  736:  const char* const dash = strchr(p, '-');
       82:  737:  std::string positive;
    $$$$$:  737-block  0
       41:  738:  std::string negative;
    $$$$$:  738-block  0
       41:  739:  if (dash == nullptr) {
       41:  740:    positive = GTEST_FLAG(filter).c_str();  // Whole string is a positive filter
       41:  740-block  0
       41:  741:    negative = "";
       41:  741-block  0
        -:  742:  } else {
    #####:  743:    positive = std::string(p, dash);   // Everything up to the dash
    %%%%%:  743-block  0
    %%%%%:  743-block  1
    $$$$$:  743-block  2
    $$$$$:  743-block  3
    #####:  744:    negative = std::string(dash + 1);  // Everything after the dash
    %%%%%:  744-block  0
    $$$$$:  744-block  1
    $$$$$:  744-block  2
    #####:  745:    if (positive.empty()) {
        -:  746:      // Treat '-test1' as the same as '*-test1'
    #####:  747:      positive = kUniversalFilter;
    %%%%%:  747-block  0
        -:  748:    }
        -:  749:  }
        -:  750:
        -:  751:  // A filter is a colon-separated list of patterns.  It matches a
        -:  752:  // test if any pattern in it matches the test.
       72:  753:  return (MatchesFilter(full_name, positive.c_str()) &&
       41:  753-block  0
       31:  753-block  1
       10:  753-block  2
      113:  754:          !MatchesFilter(full_name, negative.c_str()));
       31:  754-block  0
       41:  754-block  1
       41:  754-block  2
        -:  755:}
        -:  756:
        -:  757:#if GTEST_HAS_SEH
        -:  758:// Returns EXCEPTION_EXECUTE_HANDLER if Google Test should handle the
        -:  759:// given SEH exception, or EXCEPTION_CONTINUE_SEARCH otherwise.
        -:  760:// This function is useful as an __except condition.
        -:  761:int UnitTestOptions::GTestShouldProcessSEH(DWORD exception_code) {
        -:  762:  // Google Test should handle a SEH exception if:
        -:  763:  //   1. the user wants it to, AND
        -:  764:  //   2. this is not a breakpoint exception, AND
        -:  765:  //   3. this is not a C++ exception (VC++ implements them via SEH,
        -:  766:  //      apparently).
        -:  767:  //
        -:  768:  // SEH exception code for C++ exceptions.
        -:  769:  // (see http://support.microsoft.com/kb/185294 for more information).
        -:  770:  const DWORD kCxxExceptionCode = 0xe06d7363;
        -:  771:
        -:  772:  bool should_handle = true;
        -:  773:
        -:  774:  if (!GTEST_FLAG(catch_exceptions))
        -:  775:    should_handle = false;
        -:  776:  else if (exception_code == EXCEPTION_BREAKPOINT)
        -:  777:    should_handle = false;
        -:  778:  else if (exception_code == kCxxExceptionCode)
        -:  779:    should_handle = false;
        -:  780:
        -:  781:  return should_handle ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH;
        -:  782:}
        -:  783:#endif  // GTEST_HAS_SEH
        -:  784:
        -:  785:}  // namespace internal
        -:  786:
        -:  787:// The c'tor sets this object as the test part result reporter used by
        -:  788:// Google Test.  The 'result' parameter specifies where to report the
        -:  789:// results. Intercepts only failures from the current thread.
    #####:  790:ScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter(
    #####:  791:    TestPartResultArray* result)
        -:  792:    : intercept_mode_(INTERCEPT_ONLY_CURRENT_THREAD),
    #####:  793:      result_(result) {
    %%%%%:  793-block  0
    $$$$$:  793-block  1
    #####:  794:  Init();
    #####:  795:}
    %%%%%:  795-block  0
        -:  796:
        -:  797:// The c'tor sets this object as the test part result reporter used by
        -:  798:// Google Test.  The 'result' parameter specifies where to report the
        -:  799:// results.
    #####:  800:ScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter(
    #####:  801:    InterceptMode intercept_mode, TestPartResultArray* result)
        -:  802:    : intercept_mode_(intercept_mode),
    #####:  803:      result_(result) {
    %%%%%:  803-block  0
    $$$$$:  803-block  1
    #####:  804:  Init();
    #####:  805:}
    %%%%%:  805-block  0
        -:  806:
    #####:  807:void ScopedFakeTestPartResultReporter::Init() {
    #####:  808:  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
    %%%%%:  808-block  0
    #####:  809:  if (intercept_mode_ == INTERCEPT_ALL_THREADS) {
    #####:  810:    old_reporter_ = impl->GetGlobalTestPartResultReporter();
    %%%%%:  810-block  0
    #####:  811:    impl->SetGlobalTestPartResultReporter(this);
        -:  812:  } else {
    #####:  813:    old_reporter_ = impl->GetTestPartResultReporterForCurrentThread();
    %%%%%:  813-block  0
    #####:  814:    impl->SetTestPartResultReporterForCurrentThread(this);
        -:  815:  }
    #####:  816:}
        -:  817:
        -:  818:// The d'tor restores the test part result reporter used by Google Test
        -:  819:// before.
    #####:  820:ScopedFakeTestPartResultReporter::~ScopedFakeTestPartResultReporter() {
    #####:  821:  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
    #####:  822:  if (intercept_mode_ == INTERCEPT_ALL_THREADS) {
    #####:  823:    impl->SetGlobalTestPartResultReporter(old_reporter_);
        -:  824:  } else {
    #####:  825:    impl->SetTestPartResultReporterForCurrentThread(old_reporter_);
        -:  826:  }
    #####:  827:}
------------------
_ZN7testing32ScopedFakeTestPartResultReporterD0Ev:
    #####:  820:ScopedFakeTestPartResultReporter::~ScopedFakeTestPartResultReporter() {
        -:  821:  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
        -:  822:  if (intercept_mode_ == INTERCEPT_ALL_THREADS) {
        -:  823:    impl->SetGlobalTestPartResultReporter(old_reporter_);
        -:  824:  } else {
        -:  825:    impl->SetTestPartResultReporterForCurrentThread(old_reporter_);
        -:  826:  }
    #####:  827:}
    %%%%%:  827-block  0
------------------
_ZN7testing32ScopedFakeTestPartResultReporterD2Ev:
    #####:  820:ScopedFakeTestPartResultReporter::~ScopedFakeTestPartResultReporter() {
    %%%%%:  820-block  0
    #####:  821:  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
    %%%%%:  821-block  0
    #####:  822:  if (intercept_mode_ == INTERCEPT_ALL_THREADS) {
    #####:  823:    impl->SetGlobalTestPartResultReporter(old_reporter_);
    %%%%%:  823-block  0
        -:  824:  } else {
    #####:  825:    impl->SetTestPartResultReporterForCurrentThread(old_reporter_);
    %%%%%:  825-block  0
        -:  826:  }
    #####:  827:}
------------------
        -:  828:
        -:  829:// Increments the test part result count and remembers the result.
        -:  830:// This method is from the TestPartResultReporterInterface interface.
    #####:  831:void ScopedFakeTestPartResultReporter::ReportTestPartResult(
        -:  832:    const TestPartResult& result) {
    #####:  833:  result_->Append(result);
    %%%%%:  833-block  0
    #####:  834:}
        -:  835:
        -:  836:namespace internal {
        -:  837:
        -:  838:// Returns the type ID of ::testing::Test.  We should always call this
        -:  839:// instead of GetTypeId< ::testing::Test>() to get the type ID of
        -:  840:// testing::Test.  This is to work around a suspected linker bug when
        -:  841:// using Google Test as a framework on Mac OS X.  The bug causes
        -:  842:// GetTypeId< ::testing::Test>() to return different values depending
        -:  843:// on whether the call is from the Google Test framework itself or
        -:  844:// from user test code.  GetTestTypeId() is guaranteed to always
        -:  845:// return the same value, as it always calls GetTypeId<>() from the
        -:  846:// gtest.cc, which is within the Google Test framework.
        1:  847:TypeId GetTestTypeId() {
        1:  848:  return GetTypeId<Test>();
        1:  848-block  0
        -:  849:}
        -:  850:
        -:  851:// The value of GetTestTypeId() as seen from within the Google Test
        -:  852:// library.  This is solely for testing GetTestTypeId().
        -:  853:extern const TypeId kTestTypeIdInGoogleTest = GetTestTypeId();
        -:  854:
        -:  855:// This predicate-formatter checks that 'results' contains a test part
        -:  856:// failure of the given type and that the failure message contains the
        -:  857:// given substring.
    #####:  858:static AssertionResult HasOneFailure(const char* /* results_expr */,
        -:  859:                                     const char* /* type_expr */,
        -:  860:                                     const char* /* substr_expr */,
        -:  861:                                     const TestPartResultArray& results,
        -:  862:                                     TestPartResult::Type type,
        -:  863:                                     const std::string& substr) {
        -:  864:  const std::string expected(type == TestPartResult::kFatalFailure ?
        -:  865:                        "1 fatal failure" :
    #####:  866:                        "1 non-fatal failure");
    %%%%%:  866-block  0
    %%%%%:  866-block  1
    %%%%%:  866-block  2
    %%%%%:  866-block  3
    $$$$$:  866-block  4
    $$$$$:  866-block  5
    #####:  867:  Message msg;
    %%%%%:  867-block  0
    $$$$$:  867-block  1
    #####:  868:  if (results.size() != 1) {
    %%%%%:  868-block  0
    #####:  869:    msg << "Expected: " << expected << "\n"
    %%%%%:  869-block  0
    %%%%%:  869-block  1
    %%%%%:  869-block  2
    #####:  870:        << "  Actual: " << results.size() << " failures";
    %%%%%:  870-block  0
    %%%%%:  870-block  1
    %%%%%:  870-block  2
    $$$$$:  870-block  3
    #####:  871:    for (int i = 0; i < results.size(); i++) {
    %%%%%:  871-block  0
    %%%%%:  871-block  1
    %%%%%:  871-block  2
    #####:  872:      msg << "\n" << results.GetTestPartResult(i);
    %%%%%:  872-block  0
    %%%%%:  872-block  1
    %%%%%:  872-block  2
        -:  873:    }
    #####:  874:    return AssertionFailure() << msg;
    %%%%%:  874-block  0
    %%%%%:  874-block  1
    %%%%%:  874-block  2
    %%%%%:  874-block  3
    $$$$$:  874-block  4
    $$$$$:  874-block  5
        -:  875:  }
        -:  876:
    #####:  877:  const TestPartResult& r = results.GetTestPartResult(0);
    %%%%%:  877-block  0
    #####:  878:  if (r.type() != type) {
    %%%%%:  878-block  0
    #####:  879:    return AssertionFailure() << "Expected: " << expected << "\n"
    %%%%%:  879-block  0
    %%%%%:  879-block  1
    %%%%%:  879-block  2
    %%%%%:  879-block  3
    %%%%%:  879-block  4
    $$$$$:  879-block  5
    $$$$$:  879-block  6
    #####:  880:                              << "  Actual:\n"
    %%%%%:  880-block  0
    #####:  881:                              << r;
    %%%%%:  881-block  0
    %%%%%:  881-block  1
        -:  882:  }
        -:  883:
    #####:  884:  if (strstr(r.message(), substr.c_str()) == nullptr) {
    %%%%%:  884-block  0
    #####:  885:    return AssertionFailure() << "Expected: " << expected << " containing \""
    %%%%%:  885-block  0
    %%%%%:  885-block  1
    %%%%%:  885-block  2
    %%%%%:  885-block  3
    %%%%%:  885-block  4
    $$$$$:  885-block  5
    $$$$$:  885-block  6
    #####:  886:                              << substr << "\"\n"
    %%%%%:  886-block  0
    %%%%%:  886-block  1
    #####:  887:                              << "  Actual:\n"
    %%%%%:  887-block  0
    #####:  888:                              << r;
    %%%%%:  888-block  0
    %%%%%:  888-block  1
        -:  889:  }
        -:  890:
    #####:  891:  return AssertionSuccess();
    %%%%%:  891-block  0
        -:  892:}
        -:  893:
        -:  894:// The constructor of SingleFailureChecker remembers where to look up
        -:  895:// test part results, what type of failure we expect, and what
        -:  896:// substring the failure message should contain.
    #####:  897:SingleFailureChecker::SingleFailureChecker(const TestPartResultArray* results,
        -:  898:                                           TestPartResult::Type type,
    #####:  899:                                           const std::string& substr)
    #####:  900:    : results_(results), type_(type), substr_(substr) {}
    %%%%%:  900-block  0
        -:  901:
        -:  902:// The destructor of SingleFailureChecker verifies that the given
        -:  903:// TestPartResultArray contains exactly one failure that has the given
        -:  904:// type and contains the given substring.  If that's not the case, a
        -:  905:// non-fatal failure will be generated.
    #####:  906:SingleFailureChecker::~SingleFailureChecker() {
    #####:  907:  EXPECT_PRED_FORMAT3(HasOneFailure, *results_, type_, substr_);
    %%%%%:  907-block  0
    %%%%%:  907-block  1
    %%%%%:  907-block  2
    #####:  908:}
        -:  909:
        1:  910:DefaultGlobalTestPartResultReporter::DefaultGlobalTestPartResultReporter(
        1:  911:    UnitTestImpl* unit_test) : unit_test_(unit_test) {}
        1:  911-block  0
        -:  912:
    #####:  913:void DefaultGlobalTestPartResultReporter::ReportTestPartResult(
        -:  914:    const TestPartResult& result) {
    #####:  915:  unit_test_->current_test_result()->AddTestPartResult(result);
    %%%%%:  915-block  0
    #####:  916:  unit_test_->listeners()->repeater()->OnTestPartResult(result);
    #####:  917:}
        -:  918:
        1:  919:DefaultPerThreadTestPartResultReporter::DefaultPerThreadTestPartResultReporter(
        1:  920:    UnitTestImpl* unit_test) : unit_test_(unit_test) {}
        1:  920-block  0
        -:  921:
    #####:  922:void DefaultPerThreadTestPartResultReporter::ReportTestPartResult(
        -:  923:    const TestPartResult& result) {
    #####:  924:  unit_test_->GetGlobalTestPartResultReporter()->ReportTestPartResult(result);
    %%%%%:  924-block  0
    #####:  925:}
        -:  926:
        -:  927:// Returns the global test part result reporter.
        -:  928:TestPartResultReporterInterface*
    #####:  929:UnitTestImpl::GetGlobalTestPartResultReporter() {
    #####:  930:  internal::MutexLock lock(&global_test_part_result_reporter_mutex_);
    %%%%%:  930-block  0
    #####:  931:  return global_test_part_result_repoter_;
    %%%%%:  931-block  0
    %%%%%:  931-block  1
        -:  932:}
        -:  933:
        -:  934:// Sets the global test part result reporter.
    #####:  935:void UnitTestImpl::SetGlobalTestPartResultReporter(
        -:  936:    TestPartResultReporterInterface* reporter) {
    #####:  937:  internal::MutexLock lock(&global_test_part_result_reporter_mutex_);
    %%%%%:  937-block  0
    #####:  938:  global_test_part_result_repoter_ = reporter;
    %%%%%:  938-block  0
    #####:  939:}
        -:  940:
        -:  941:// Returns the test part result reporter for the current thread.
        -:  942:TestPartResultReporterInterface*
    #####:  943:UnitTestImpl::GetTestPartResultReporterForCurrentThread() {
    #####:  944:  return per_thread_test_part_result_reporter_.get();
    %%%%%:  944-block  0
        -:  945:}
        -:  946:
        -:  947:// Sets the test part result reporter for the current thread.
    #####:  948:void UnitTestImpl::SetTestPartResultReporterForCurrentThread(
        -:  949:    TestPartResultReporterInterface* reporter) {
    #####:  950:  per_thread_test_part_result_reporter_.set(reporter);
    %%%%%:  950-block  0
    #####:  951:}
        -:  952:
        -:  953:// Gets the number of successful test suites.
    #####:  954:int UnitTestImpl::successful_test_suite_count() const {
    #####:  955:  return CountIf(test_suites_, TestSuitePassed);
    %%%%%:  955-block  0
        -:  956:}
        -:  957:
        -:  958:// Gets the number of failed test suites.
        2:  959:int UnitTestImpl::failed_test_suite_count() const {
        2:  960:  return CountIf(test_suites_, TestSuiteFailed);
        2:  960-block  0
        -:  961:}
        -:  962:
        -:  963:// Gets the number of all test suites.
        3:  964:int UnitTestImpl::total_test_suite_count() const {
        3:  965:  return static_cast<int>(test_suites_.size());
        3:  965-block  0
        -:  966:}
        -:  967:
        -:  968:// Gets the number of all test suites that contain at least one test
        -:  969:// that should run.
        2:  970:int UnitTestImpl::test_suite_to_run_count() const {
        2:  971:  return CountIf(test_suites_, ShouldRunTestSuite);
        2:  971-block  0
        -:  972:}
        -:  973:
        -:  974:// Gets the number of successful tests.
        1:  975:int UnitTestImpl::successful_test_count() const {
        1:  976:  return SumOverTestSuiteList(test_suites_, &TestSuite::successful_test_count);
        1:  976-block  0
        -:  977:}
        -:  978:
        -:  979:// Gets the number of skipped tests.
        1:  980:int UnitTestImpl::skipped_test_count() const {
        1:  981:  return SumOverTestSuiteList(test_suites_, &TestSuite::skipped_test_count);
        1:  981-block  0
        -:  982:}
        -:  983:
        -:  984:// Gets the number of failed tests.
    #####:  985:int UnitTestImpl::failed_test_count() const {
    #####:  986:  return SumOverTestSuiteList(test_suites_, &TestSuite::failed_test_count);
    %%%%%:  986-block  0
        -:  987:}
        -:  988:
        -:  989:// Gets the number of disabled tests that will be reported in the XML report.
        1:  990:int UnitTestImpl::reportable_disabled_test_count() const {
        1:  991:  return SumOverTestSuiteList(test_suites_,
        1:  991-block  0
        1:  992:                              &TestSuite::reportable_disabled_test_count);
        -:  993:}
        -:  994:
        -:  995:// Gets the number of disabled tests.
    #####:  996:int UnitTestImpl::disabled_test_count() const {
    #####:  997:  return SumOverTestSuiteList(test_suites_, &TestSuite::disabled_test_count);
    %%%%%:  997-block  0
        -:  998:}
        -:  999:
        -: 1000:// Gets the number of tests to be printed in the XML report.
    #####: 1001:int UnitTestImpl::reportable_test_count() const {
    #####: 1002:  return SumOverTestSuiteList(test_suites_, &TestSuite::reportable_test_count);
    %%%%%: 1002-block  0
        -: 1003:}
        -: 1004:
        -: 1005:// Gets the number of all tests.
    #####: 1006:int UnitTestImpl::total_test_count() const {
    #####: 1007:  return SumOverTestSuiteList(test_suites_, &TestSuite::total_test_count);
    %%%%%: 1007-block  0
        -: 1008:}
        -: 1009:
        -: 1010:// Gets the number of tests that should run.
        2: 1011:int UnitTestImpl::test_to_run_count() const {
        2: 1012:  return SumOverTestSuiteList(test_suites_, &TestSuite::test_to_run_count);
        2: 1012-block  0
        -: 1013:}
        -: 1014:
        -: 1015:// Returns the current OS stack trace as an std::string.
        -: 1016://
        -: 1017:// The maximum number of stack frames to be included is specified by
        -: 1018:// the gtest_stack_trace_depth flag.  The skip_count parameter
        -: 1019:// specifies the number of top frames to be skipped, which doesn't
        -: 1020:// count against the number of frames to be included.
        -: 1021://
        -: 1022:// For example, if Foo() calls Bar(), which in turn calls
        -: 1023:// CurrentOsStackTraceExceptTop(1), Foo() will be included in the
        -: 1024:// trace but Bar() and CurrentOsStackTraceExceptTop() won't.
    #####: 1025:std::string UnitTestImpl::CurrentOsStackTraceExceptTop(int skip_count) {
    #####: 1026:  return os_stack_trace_getter()->CurrentStackTrace(
    %%%%%: 1026-block  0
        -: 1027:      static_cast<int>(GTEST_FLAG(stack_trace_depth)),
        -: 1028:      skip_count + 1
        -: 1029:      // Skips the user-specified number of frames plus this function
        -: 1030:      // itself.
    #####: 1031:      );  // NOLINT
        -: 1032:}
        -: 1033:
        -: 1034:// A helper class for measuring elapsed times.
        -: 1035:class Timer {
        -: 1036: public:
       33: 1037:  Timer() : start_(std::chrono::steady_clock::now()) {}
       33: 1037-block  0
        -: 1038:
        -: 1039:  // Return time elapsed in milliseconds since the timer was created.
       33: 1040:  TimeInMillis Elapsed() {
       33: 1041:    return std::chrono::duration_cast<std::chrono::milliseconds>(
       66: 1042:               std::chrono::steady_clock::now() - start_)
       33: 1042-block  0
       33: 1042-block  1
    $$$$$: 1042-block  2
       66: 1043:        .count();
       33: 1043-block  0
       33: 1043-block  1
        -: 1044:  }
        -: 1045:
        -: 1046: private:
        -: 1047:  std::chrono::time_point<std::chrono::steady_clock> start_;
        -: 1048:};
        -: 1049:
        -: 1050:// Returns a timestamp as milliseconds since the epoch. Note this time may jump
        -: 1051:// around subject to adjustments by the system, to measure elapsed time use
        -: 1052:// Timer instead.
       33: 1053:TimeInMillis GetTimeInMillis() {
       33: 1054:  return std::chrono::duration_cast<std::chrono::milliseconds>(
       33: 1055:             std::chrono::system_clock::now() -
    $$$$$: 1055-block  0
    $$$$$: 1055-block  1
       99: 1056:             std::chrono::system_clock::from_time_t(0))
       33: 1056-block  0
       33: 1056-block  1
       66: 1057:      .count();
       33: 1057-block  0
       33: 1057-block  1
        -: 1058:}
        -: 1059:
        -: 1060:// Utilities
        -: 1061:
        -: 1062:// class String.
        -: 1063:
        -: 1064:#if GTEST_OS_WINDOWS_MOBILE
        -: 1065:// Creates a UTF-16 wide string from the given ANSI string, allocating
        -: 1066:// memory using new. The caller is responsible for deleting the return
        -: 1067:// value using delete[]. Returns the wide string, or NULL if the
        -: 1068:// input is NULL.
        -: 1069:LPCWSTR String::AnsiToUtf16(const char* ansi) {
        -: 1070:  if (!ansi) return nullptr;
        -: 1071:  const int length = strlen(ansi);
        -: 1072:  const int unicode_length =
        -: 1073:      MultiByteToWideChar(CP_ACP, 0, ansi, length, nullptr, 0);
        -: 1074:  WCHAR* unicode = new WCHAR[unicode_length + 1];
        -: 1075:  MultiByteToWideChar(CP_ACP, 0, ansi, length,
        -: 1076:                      unicode, unicode_length);
        -: 1077:  unicode[unicode_length] = 0;
        -: 1078:  return unicode;
        -: 1079:}
        -: 1080:
        -: 1081:// Creates an ANSI string from the given wide string, allocating
        -: 1082:// memory using new. The caller is responsible for deleting the return
        -: 1083:// value using delete[]. Returns the ANSI string, or NULL if the
        -: 1084:// input is NULL.
        -: 1085:const char* String::Utf16ToAnsi(LPCWSTR utf16_str)  {
        -: 1086:  if (!utf16_str) return nullptr;
        -: 1087:  const int ansi_length = WideCharToMultiByte(CP_ACP, 0, utf16_str, -1, nullptr,
        -: 1088:                                              0, nullptr, nullptr);
        -: 1089:  char* ansi = new char[ansi_length + 1];
        -: 1090:  WideCharToMultiByte(CP_ACP, 0, utf16_str, -1, ansi, ansi_length, nullptr,
        -: 1091:                      nullptr);
        -: 1092:  ansi[ansi_length] = 0;
        -: 1093:  return ansi;
        -: 1094:}
        -: 1095:
        -: 1096:#endif  // GTEST_OS_WINDOWS_MOBILE
        -: 1097:
        -: 1098:// Compares two C strings.  Returns true if and only if they have the same
        -: 1099:// content.
        -: 1100://
        -: 1101:// Unlike strcmp(), this function can handle NULL argument(s).  A NULL
        -: 1102:// C string is considered different to any non-NULL C string,
        -: 1103:// including the empty string.
        2: 1104:bool String::CStringEquals(const char * lhs, const char * rhs) {
       2*: 1105:  if (lhs == nullptr) return rhs == nullptr;
        2: 1105-block  0
    %%%%%: 1105-block  1
        -: 1106:
       2*: 1107:  if (rhs == nullptr) return false;
        2: 1107-block  0
    %%%%%: 1107-block  1
        -: 1108:
        2: 1109:  return strcmp(lhs, rhs) == 0;
        2: 1109-block  0
        -: 1110:}
        -: 1111:
        -: 1112:#if GTEST_HAS_STD_WSTRING
        -: 1113:
        -: 1114:// Converts an array of wide chars to a narrow string using the UTF-8
        -: 1115:// encoding, and streams the result to the given Message object.
    #####: 1116:static void StreamWideCharsToMessage(const wchar_t* wstr, size_t length,
        -: 1117:                                     Message* msg) {
    #####: 1118:  for (size_t i = 0; i != length; ) {  // NOLINT
    %%%%%: 1118-block  0
    %%%%%: 1118-block  1
    %%%%%: 1118-block  2
    #####: 1119:    if (wstr[i] != L'\0') {
    %%%%%: 1119-block  0
    #####: 1120:      *msg << WideStringToUtf8(wstr + i, static_cast<int>(length - i));
    %%%%%: 1120-block  0
    %%%%%: 1120-block  1
    $$$$$: 1120-block  2
    $$$$$: 1120-block  3
    #####: 1121:      while (i != length && wstr[i] != L'\0')
    %%%%%: 1121-block  0
    %%%%%: 1121-block  1
    #####: 1122:        i++;
    %%%%%: 1122-block  0
        -: 1123:    } else {
    #####: 1124:      *msg << '\0';
    %%%%%: 1124-block  0
    #####: 1125:      i++;
    %%%%%: 1125-block  0
        -: 1126:    }
        -: 1127:  }
    #####: 1128:}
    %%%%%: 1128-block  0
        -: 1129:
        -: 1130:#endif  // GTEST_HAS_STD_WSTRING
        -: 1131:
    #####: 1132:void SplitString(const ::std::string& str, char delimiter,
        -: 1133:                 ::std::vector< ::std::string>* dest) {
    #####: 1134:  ::std::vector< ::std::string> parsed;
    %%%%%: 1134-block  0
    $$$$$: 1134-block  1
    #####: 1135:  ::std::string::size_type pos = 0;
    #####: 1136:  while (::testing::internal::AlwaysTrue()) {
    %%%%%: 1136-block  0
    %%%%%: 1136-block  1
    #####: 1137:    const ::std::string::size_type colon = str.find(delimiter, pos);
    %%%%%: 1137-block  0
    #####: 1138:    if (colon == ::std::string::npos) {
    #####: 1139:      parsed.push_back(str.substr(pos));
    %%%%%: 1139-block  0
    %%%%%: 1139-block  1
    %%%%%: 1139-block  2
    $$$$$: 1139-block  3
    $$$$$: 1139-block  4
    #####: 1140:      break;
        -: 1141:    } else {
    #####: 1142:      parsed.push_back(str.substr(pos, colon - pos));
    %%%%%: 1142-block  0
    %%%%%: 1142-block  1
    %%%%%: 1142-block  2
    $$$$$: 1142-block  3
    $$$$$: 1142-block  4
    #####: 1143:      pos = colon + 1;
        -: 1144:    }
        -: 1145:  }
    #####: 1146:  dest->swap(parsed);
    %%%%%: 1146-block  0
    #####: 1147:}
        -: 1148:
        -: 1149:}  // namespace internal
        -: 1150:
        -: 1151:// Constructs an empty Message.
        -: 1152:// We allocate the stringstream separately because otherwise each use of
        -: 1153:// ASSERT/EXPECT in a procedure adds over 200 bytes to the procedure's
        -: 1154:// stack frame leading to huge stack frames in some cases; gcc does not reuse
        -: 1155:// the stack space.
       85: 1156:Message::Message() : ss_(new ::std::stringstream) {
       85: 1156-block  0
       85: 1156-block  1
    $$$$$: 1156-block  2
    $$$$$: 1156-block  3
        -: 1157:  // By default, we want there to be enough precision when printing
        -: 1158:  // a double to a Message.
       85: 1159:  *ss_ << std::setprecision(std::numeric_limits<double>::digits10 + 2);
       85: 1160:}
       85: 1160-block  0
        -: 1161:
        -: 1162:// These two overloads allow streaming a wide C string to a Message
        -: 1163:// using the UTF-8 encoding.
    #####: 1164:Message& Message::operator <<(const wchar_t* wide_c_str) {
    #####: 1165:  return *this << internal::String::ShowWideCString(wide_c_str);
    %%%%%: 1165-block  0
    %%%%%: 1165-block  1
    %%%%%: 1165-block  2
    $$$$$: 1165-block  3
        -: 1166:}
    #####: 1167:Message& Message::operator <<(wchar_t* wide_c_str) {
    #####: 1168:  return *this << internal::String::ShowWideCString(wide_c_str);
    %%%%%: 1168-block  0
    %%%%%: 1168-block  1
    %%%%%: 1168-block  2
    $$$$$: 1168-block  3
        -: 1169:}
        -: 1170:
        -: 1171:#if GTEST_HAS_STD_WSTRING
        -: 1172:// Converts the given wide string to a narrow string using the UTF-8
        -: 1173:// encoding, and streams the result to this Message object.
    #####: 1174:Message& Message::operator <<(const ::std::wstring& wstr) {
    #####: 1175:  internal::StreamWideCharsToMessage(wstr.c_str(), wstr.length(), this);
    %%%%%: 1175-block  0
    #####: 1176:  return *this;
        -: 1177:}
        -: 1178:#endif  // GTEST_HAS_STD_WSTRING
        -: 1179:
        -: 1180:// Gets the text streamed to this object so far as an std::string.
        -: 1181:// Each '\0' character in the buffer is replaced with "\\0".
       85: 1182:std::string Message::GetString() const {
       85: 1183:  return internal::StringStreamToString(ss_.get());
       85: 1183-block  0
        -: 1184:}
        -: 1185:
        -: 1186:// AssertionResult constructors.
        -: 1187:// Used in EXPECT_TRUE/FALSE(assertion_result).
    #####: 1188:AssertionResult::AssertionResult(const AssertionResult& other)
    #####: 1189:    : success_(other.success_),
    #####: 1190:      message_(other.message_.get() != nullptr
    #####: 1191:                   ? new ::std::string(*other.message_)
    %%%%%: 1191-block  0
    $$$$$: 1191-block  1
    #####: 1192:                   : static_cast< ::std::string*>(nullptr)) {}
    %%%%%: 1192-block  0
    %%%%%: 1192-block  1
    %%%%%: 1192-block  2
    %%%%%: 1192-block  3
        -: 1193:
        -: 1194:// Swaps two AssertionResults.
    #####: 1195:void AssertionResult::swap(AssertionResult& other) {
        -: 1196:  using std::swap;
    #####: 1197:  swap(success_, other.success_);
    %%%%%: 1197-block  0
    #####: 1198:  swap(message_, other.message_);
    #####: 1199:}
        -: 1200:
        -: 1201:// Returns the assertion's negation. Used with EXPECT/ASSERT_FALSE.
    #####: 1202:AssertionResult AssertionResult::operator!() const {
    #####: 1203:  AssertionResult negation(!success_);
    %%%%%: 1203-block  0
    #####: 1204:  if (message_.get() != nullptr) negation << *message_;
    %%%%%: 1204-block  0
    #####: 1205:  return negation;
    %%%%%: 1205-block  0
    %%%%%: 1205-block  1
        -: 1206:}
        -: 1207:
        -: 1208:// Makes a successful assertion result.
        7: 1209:AssertionResult AssertionSuccess() {
        7: 1210:  return AssertionResult(true);
        7: 1210-block  0
        -: 1211:}
        -: 1212:
        -: 1213:// Makes a failed assertion result.
    #####: 1214:AssertionResult AssertionFailure() {
    #####: 1215:  return AssertionResult(false);
    %%%%%: 1215-block  0
        -: 1216:}
        -: 1217:
        -: 1218:// Makes a failed assertion result with the given failure message.
        -: 1219:// Deprecated; use AssertionFailure() << message.
    #####: 1220:AssertionResult AssertionFailure(const Message& message) {
    #####: 1221:  return AssertionFailure() << message;
    %%%%%: 1221-block  0
    %%%%%: 1221-block  1
    %%%%%: 1221-block  2
    %%%%%: 1221-block  3
    $$$$$: 1221-block  4
        -: 1222:}
        -: 1223:
        -: 1224:namespace internal {
        -: 1225:
        -: 1226:namespace edit_distance {
    #####: 1227:std::vector<EditType> CalculateOptimalEdits(const std::vector<size_t>& left,
        -: 1228:                                            const std::vector<size_t>& right) {
        -: 1229:  std::vector<std::vector<double> > costs(
    #####: 1230:      left.size() + 1, std::vector<double>(right.size() + 1));
    %%%%%: 1230-block  0
    %%%%%: 1230-block  1
    $$$$$: 1230-block  2
    $$$$$: 1230-block  3
    $$$$$: 1230-block  4
    $$$$$: 1230-block  5
        -: 1231:  std::vector<std::vector<EditType> > best_move(
    #####: 1232:      left.size() + 1, std::vector<EditType>(right.size() + 1));
    %%%%%: 1232-block  0
    %%%%%: 1232-block  1
    $$$$$: 1232-block  2
    $$$$$: 1232-block  3
    $$$$$: 1232-block  4
    $$$$$: 1232-block  5
        -: 1233:
        -: 1234:  // Populate for empty right.
    #####: 1235:  for (size_t l_i = 0; l_i < costs.size(); ++l_i) {
    %%%%%: 1235-block  0
    #####: 1236:    costs[l_i][0] = static_cast<double>(l_i);
    %%%%%: 1236-block  0
    #####: 1237:    best_move[l_i][0] = kRemove;
        -: 1238:  }
        -: 1239:  // Populate for empty left.
    #####: 1240:  for (size_t r_i = 1; r_i < costs[0].size(); ++r_i) {
    %%%%%: 1240-block  0
    %%%%%: 1240-block  1
    #####: 1241:    costs[0][r_i] = static_cast<double>(r_i);
    %%%%%: 1241-block  0
    #####: 1242:    best_move[0][r_i] = kAdd;
        -: 1243:  }
        -: 1244:
    #####: 1245:  for (size_t l_i = 0; l_i < left.size(); ++l_i) {
    %%%%%: 1245-block  0
    %%%%%: 1245-block  1
    %%%%%: 1245-block  2
    #####: 1246:    for (size_t r_i = 0; r_i < right.size(); ++r_i) {
    %%%%%: 1246-block  0
    %%%%%: 1246-block  1
    %%%%%: 1246-block  2
    #####: 1247:      if (left[l_i] == right[r_i]) {
    %%%%%: 1247-block  0
        -: 1248:        // Found a match. Consume it.
    #####: 1249:        costs[l_i + 1][r_i + 1] = costs[l_i][r_i];
    %%%%%: 1249-block  0
    #####: 1250:        best_move[l_i + 1][r_i + 1] = kMatch;
    #####: 1251:        continue;
        -: 1252:      }
        -: 1253:
    #####: 1254:      const double add = costs[l_i + 1][r_i];
    %%%%%: 1254-block  0
    #####: 1255:      const double remove = costs[l_i][r_i + 1];
    #####: 1256:      const double replace = costs[l_i][r_i];
    #####: 1257:      if (add < remove && add < replace) {
    %%%%%: 1257-block  0
    #####: 1258:        costs[l_i + 1][r_i + 1] = add + 1;
    %%%%%: 1258-block  0
    #####: 1259:        best_move[l_i + 1][r_i + 1] = kAdd;
    #####: 1260:      } else if (remove < add && remove < replace) {
    %%%%%: 1260-block  0
    %%%%%: 1260-block  1
    #####: 1261:        costs[l_i + 1][r_i + 1] = remove + 1;
    %%%%%: 1261-block  0
    #####: 1262:        best_move[l_i + 1][r_i + 1] = kRemove;
        -: 1263:      } else {
        -: 1264:        // We make replace a little more expensive than add/remove to lower
        -: 1265:        // their priority.
    #####: 1266:        costs[l_i + 1][r_i + 1] = replace + 1.00001;
    %%%%%: 1266-block  0
    #####: 1267:        best_move[l_i + 1][r_i + 1] = kReplace;
        -: 1268:      }
        -: 1269:    }
        -: 1270:  }
        -: 1271:
        -: 1272:  // Reconstruct the best path. We do it in reverse order.
    #####: 1273:  std::vector<EditType> best_path;
    %%%%%: 1273-block  0
    #####: 1274:  for (size_t l_i = left.size(), r_i = right.size(); l_i > 0 || r_i > 0;) {
    %%%%%: 1274-block  0
    %%%%%: 1274-block  1
    #####: 1275:    EditType move = best_move[l_i][r_i];
    %%%%%: 1275-block  0
    #####: 1276:    best_path.push_back(move);
    #####: 1277:    l_i -= move != kAdd;
    #####: 1278:    r_i -= move != kRemove;
    %%%%%: 1278-block  0
        -: 1279:  }
    #####: 1280:  std::reverse(best_path.begin(), best_path.end());
    %%%%%: 1280-block  0
    #####: 1281:  return best_path;
    %%%%%: 1281-block  0
    %%%%%: 1281-block  1
        -: 1282:}
        -: 1283:
        -: 1284:namespace {
        -: 1285:
        -: 1286:// Helper class to convert string into ids with deduplication.
        -: 1287:class InternalStrings {
        -: 1288: public:
    #####: 1289:  size_t GetId(const std::string& str) {
    #####: 1290:    IdMap::iterator it = ids_.find(str);
    %%%%%: 1290-block  0
    #####: 1291:    if (it != ids_.end()) return it->second;
    %%%%%: 1291-block  0
    %%%%%: 1291-block  1
    #####: 1292:    size_t id = ids_.size();
    %%%%%: 1292-block  0
    #####: 1293:    return ids_[str] = id;
    %%%%%: 1293-block  0
        -: 1294:  }
        -: 1295:
        -: 1296: private:
        -: 1297:  typedef std::map<std::string, size_t> IdMap;
        -: 1298:  IdMap ids_;
        -: 1299:};
        -: 1300:
        -: 1301:}  // namespace
        -: 1302:
    #####: 1303:std::vector<EditType> CalculateOptimalEdits(
        -: 1304:    const std::vector<std::string>& left,
        -: 1305:    const std::vector<std::string>& right) {
    #####: 1306:  std::vector<size_t> left_ids, right_ids;
    %%%%%: 1306-block  0
    %%%%%: 1306-block  1
    $$$$$: 1306-block  2
    $$$$$: 1306-block  3
        -: 1307:  {
    #####: 1308:    InternalStrings intern_table;
    %%%%%: 1308-block  0
    $$$$$: 1308-block  1
    #####: 1309:    for (size_t i = 0; i < left.size(); ++i) {
    %%%%%: 1309-block  0
    #####: 1310:      left_ids.push_back(intern_table.GetId(left[i]));
    %%%%%: 1310-block  0
    %%%%%: 1310-block  1
    %%%%%: 1310-block  2
    $$$$$: 1310-block  3
        -: 1311:    }
    #####: 1312:    for (size_t i = 0; i < right.size(); ++i) {
    %%%%%: 1312-block  0
    %%%%%: 1312-block  1
    #####: 1313:      right_ids.push_back(intern_table.GetId(right[i]));
    %%%%%: 1313-block  0
    %%%%%: 1313-block  1
    %%%%%: 1313-block  2
    $$$$$: 1313-block  3
        -: 1314:    }
        -: 1315:  }
    #####: 1316:  return CalculateOptimalEdits(left_ids, right_ids);
    %%%%%: 1316-block  0
        -: 1317:}
        -: 1318:
        -: 1319:namespace {
        -: 1320:
        -: 1321:// Helper class that holds the state for one hunk and prints it out to the
        -: 1322:// stream.
        -: 1323:// It reorders adds/removes when possible to group all removes before all
        -: 1324:// adds. It also adds the hunk header before printint into the stream.
        -: 1325:class Hunk {
        -: 1326: public:
    #####: 1327:  Hunk(size_t left_start, size_t right_start)
    #####: 1328:      : left_start_(left_start),
        -: 1329:        right_start_(right_start),
        -: 1330:        adds_(),
        -: 1331:        removes_(),
    #####: 1332:        common_() {}
    %%%%%: 1332-block  0
        -: 1333:
    #####: 1334:  void PushLine(char edit, const char* line) {
    #####: 1335:    switch (edit) {
    %%%%%: 1335-block  0
    #####: 1336:      case ' ':
    #####: 1337:        ++common_;
    #####: 1338:        FlushEdits();
    %%%%%: 1338-block  0
    #####: 1339:        hunk_.push_back(std::make_pair(' ', line));
    %%%%%: 1339-block  0
    $$$$$: 1339-block  1
    $$$$$: 1339-block  2
    #####: 1340:        break;
    %%%%%: 1340-block  0
    #####: 1341:      case '-':
    #####: 1342:        ++removes_;
    #####: 1343:        hunk_removes_.push_back(std::make_pair('-', line));
    %%%%%: 1343-block  0
    %%%%%: 1343-block  1
    $$$$$: 1343-block  2
    $$$$$: 1343-block  3
    #####: 1344:        break;
    %%%%%: 1344-block  0
    #####: 1345:      case '+':
    #####: 1346:        ++adds_;
    #####: 1347:        hunk_adds_.push_back(std::make_pair('+', line));
    %%%%%: 1347-block  0
    %%%%%: 1347-block  1
    $$$$$: 1347-block  2
    #####: 1348:        break;
    %%%%%: 1348-block  0
        -: 1349:    }
    #####: 1350:  }
    %%%%%: 1350-block  0
        -: 1351:
    #####: 1352:  void PrintTo(std::ostream* os) {
    #####: 1353:    PrintHeader(os);
    %%%%%: 1353-block  0
    #####: 1354:    FlushEdits();
    #####: 1355:    for (std::list<std::pair<char, const char*> >::const_iterator it =
    #####: 1356:             hunk_.begin();
    #####: 1357:         it != hunk_.end(); ++it) {
    %%%%%: 1357-block  0
    %%%%%: 1357-block  1
    #####: 1358:      *os << it->first << it->second << "\n";
    %%%%%: 1358-block  0
    %%%%%: 1358-block  1
    %%%%%: 1358-block  2
        -: 1359:    }
    #####: 1360:  }
    %%%%%: 1360-block  0
        -: 1361:
    #####: 1362:  bool has_edits() const { return adds_ || removes_; }
    %%%%%: 1362-block  0
    %%%%%: 1362-block  1
    %%%%%: 1362-block  2
    %%%%%: 1362-block  3
    %%%%%: 1362-block  4
        -: 1363:
        -: 1364: private:
    #####: 1365:  void FlushEdits() {
    #####: 1366:    hunk_.splice(hunk_.end(), hunk_removes_);
    %%%%%: 1366-block  0
    #####: 1367:    hunk_.splice(hunk_.end(), hunk_adds_);
    #####: 1368:  }
        -: 1369:
        -: 1370:  // Print a unified diff header for one hunk.
        -: 1371:  // The format is
        -: 1372:  //   "@@ -<left_start>,<left_length> +<right_start>,<right_length> @@"
        -: 1373:  // where the left/right parts are omitted if unnecessary.
    #####: 1374:  void PrintHeader(std::ostream* ss) const {
    #####: 1375:    *ss << "@@ ";
    %%%%%: 1375-block  0
    #####: 1376:    if (removes_) {
    #####: 1377:      *ss << "-" << left_start_ << "," << (removes_ + common_);
    %%%%%: 1377-block  0
        -: 1378:    }
    #####: 1379:    if (removes_ && adds_) {
    %%%%%: 1379-block  0
    %%%%%: 1379-block  1
    #####: 1380:      *ss << " ";
    %%%%%: 1380-block  0
        -: 1381:    }
    #####: 1382:    if (adds_) {
    %%%%%: 1382-block  0
    #####: 1383:      *ss << "+" << right_start_ << "," << (adds_ + common_);
    %%%%%: 1383-block  0
        -: 1384:    }
    #####: 1385:    *ss << " @@\n";
    %%%%%: 1385-block  0
    #####: 1386:  }
        -: 1387:
        -: 1388:  size_t left_start_, right_start_;
        -: 1389:  size_t adds_, removes_, common_;
        -: 1390:  std::list<std::pair<char, const char*> > hunk_, hunk_adds_, hunk_removes_;
        -: 1391:};
        -: 1392:
        -: 1393:}  // namespace
        -: 1394:
        -: 1395:// Create a list of diff hunks in Unified diff format.
        -: 1396:// Each hunk has a header generated by PrintHeader above plus a body with
        -: 1397:// lines prefixed with ' ' for no change, '-' for deletion and '+' for
        -: 1398:// addition.
        -: 1399:// 'context' represents the desired unchanged prefix/suffix around the diff.
        -: 1400:// If two hunks are close enough that their contexts overlap, then they are
        -: 1401:// joined into one hunk.
    #####: 1402:std::string CreateUnifiedDiff(const std::vector<std::string>& left,
        -: 1403:                              const std::vector<std::string>& right,
        -: 1404:                              size_t context) {
    #####: 1405:  const std::vector<EditType> edits = CalculateOptimalEdits(left, right);
    %%%%%: 1405-block  0
    $$$$$: 1405-block  1
        -: 1406:
    #####: 1407:  size_t l_i = 0, r_i = 0, edit_i = 0;
    #####: 1408:  std::stringstream ss;
    %%%%%: 1408-block  0
    %%%%%: 1408-block  1
    $$$$$: 1408-block  2
    #####: 1409:  while (edit_i < edits.size()) {
    %%%%%: 1409-block  0
    %%%%%: 1409-block  1
        -: 1410:    // Find first edit.
    #####: 1411:    while (edit_i < edits.size() && edits[edit_i] == kMatch) {
    %%%%%: 1411-block  0
    %%%%%: 1411-block  1
    %%%%%: 1411-block  2
    %%%%%: 1411-block  3
    %%%%%: 1411-block  4
    #####: 1412:      ++l_i;
    #####: 1413:      ++r_i;
    #####: 1414:      ++edit_i;
    %%%%%: 1414-block  0
        -: 1415:    }
        -: 1416:
        -: 1417:    // Find the first line to include in the hunk.
    #####: 1418:    const size_t prefix_context = std::min(l_i, context);
    %%%%%: 1418-block  0
    #####: 1419:    Hunk hunk(l_i - prefix_context + 1, r_i - prefix_context + 1);
    $$$$$: 1419-block  0
    #####: 1420:    for (size_t i = prefix_context; i > 0; --i) {
    %%%%%: 1420-block  0
    %%%%%: 1420-block  1
    #####: 1421:      hunk.PushLine(' ', left[l_i - i].c_str());
    %%%%%: 1421-block  0
        -: 1422:    }
        -: 1423:
        -: 1424:    // Iterate the edits until we found enough suffix for the hunk or the input
        -: 1425:    // is over.
    #####: 1426:    size_t n_suffix = 0;
    %%%%%: 1426-block  0
    #####: 1427:    for (; edit_i < edits.size(); ++edit_i) {
    %%%%%: 1427-block  0
    #####: 1428:      if (n_suffix >= context) {
    %%%%%: 1428-block  0
        -: 1429:        // Continue only if the next hunk is very close.
    #####: 1430:        auto it = edits.begin() + static_cast<int>(edit_i);
    %%%%%: 1430-block  0
    #####: 1431:        while (it != edits.end() && *it == kMatch) ++it;
    %%%%%: 1431-block  0
    %%%%%: 1431-block  1
    %%%%%: 1431-block  2
    %%%%%: 1431-block  3
    %%%%%: 1431-block  4
    %%%%%: 1431-block  5
    #####: 1432:        if (it == edits.end() ||
    %%%%%: 1432-block  0
    %%%%%: 1432-block  1
    %%%%%: 1432-block  2
    #####: 1433:            static_cast<size_t>(it - edits.begin()) - edit_i >= context) {
    %%%%%: 1433-block  0
    %%%%%: 1433-block  1
        -: 1434:          // There is no next edit or it is too far away.
    #####: 1435:          break;
    %%%%%: 1435-block  0
        -: 1436:        }
        -: 1437:      }
        -: 1438:
    #####: 1439:      EditType edit = edits[edit_i];
    %%%%%: 1439-block  0
        -: 1440:      // Reset count when a non match is found.
    #####: 1441:      n_suffix = edit == kMatch ? n_suffix + 1 : 0;
    %%%%%: 1441-block  0
    %%%%%: 1441-block  1
        -: 1442:
    #####: 1443:      if (edit == kMatch || edit == kRemove || edit == kReplace) {
    %%%%%: 1443-block  0
    %%%%%: 1443-block  1
    %%%%%: 1443-block  2
    #####: 1444:        hunk.PushLine(edit == kMatch ? ' ' : '-', left[l_i].c_str());
    %%%%%: 1444-block  0
    %%%%%: 1444-block  1
    %%%%%: 1444-block  2
    %%%%%: 1444-block  3
        -: 1445:      }
    #####: 1446:      if (edit == kAdd || edit == kReplace) {
    %%%%%: 1446-block  0
    %%%%%: 1446-block  1
    #####: 1447:        hunk.PushLine('+', right[r_i].c_str());
    %%%%%: 1447-block  0
        -: 1448:      }
        -: 1449:
        -: 1450:      // Advance indices, depending on edit type.
    #####: 1451:      l_i += edit != kAdd;
    #####: 1452:      r_i += edit != kRemove;
    %%%%%: 1452-block  0
        -: 1453:    }
        -: 1454:
    #####: 1455:    if (!hunk.has_edits()) {
    %%%%%: 1455-block  0
        -: 1456:      // We are done. We don't want this hunk.
    #####: 1457:      break;
    %%%%%: 1457-block  0
        -: 1458:    }
        -: 1459:
    #####: 1460:    hunk.PrintTo(&ss);
    %%%%%: 1460-block  0
        -: 1461:  }
    #####: 1462:  return ss.str();
    %%%%%: 1462-block  0
    %%%%%: 1462-block  1
        -: 1463:}
        -: 1464:
        -: 1465:}  // namespace edit_distance
        -: 1466:
        -: 1467:namespace {
        -: 1468:
        -: 1469:// The string representation of the values received in EqFailure() are already
        -: 1470:// escaped. Split them on escaped '\n' boundaries. Leave all other escaped
        -: 1471:// characters the same.
    #####: 1472:std::vector<std::string> SplitEscapedString(const std::string& str) {
    #####: 1473:  std::vector<std::string> lines;
    %%%%%: 1473-block  0
    #####: 1474:  size_t start = 0, end = str.size();
    #####: 1475:  if (end > 2 && str[0] == '"' && str[end - 1] == '"') {
    %%%%%: 1475-block  0
    %%%%%: 1475-block  1
    %%%%%: 1475-block  2
    %%%%%: 1475-block  3
    %%%%%: 1475-block  4
    #####: 1476:    ++start;
    #####: 1477:    --end;
    %%%%%: 1477-block  0
        -: 1478:  }
    #####: 1479:  bool escaped = false;
    #####: 1480:  for (size_t i = start; i + 1 < end; ++i) {
    %%%%%: 1480-block  0
    %%%%%: 1480-block  1
    %%%%%: 1480-block  2
    #####: 1481:    if (escaped) {
    %%%%%: 1481-block  0
    #####: 1482:      escaped = false;
    #####: 1483:      if (str[i] == 'n') {
    %%%%%: 1483-block  0
    #####: 1484:        lines.push_back(str.substr(start, i - start - 1));
    %%%%%: 1484-block  0
    %%%%%: 1484-block  1
    %%%%%: 1484-block  2
    $$$$$: 1484-block  3
    $$$$$: 1484-block  4
    #####: 1485:        start = i + 1;
        -: 1486:      }
        -: 1487:    } else {
    #####: 1488:      escaped = str[i] == '\\';
    %%%%%: 1488-block  0
        -: 1489:    }
        -: 1490:  }
    #####: 1491:  lines.push_back(str.substr(start, end - start));
    %%%%%: 1491-block  0
    %%%%%: 1491-block  1
    %%%%%: 1491-block  2
    $$$$$: 1491-block  3
    $$$$$: 1491-block  4
    #####: 1492:  return lines;
    %%%%%: 1492-block  0
        -: 1493:}
        -: 1494:
        -: 1495:}  // namespace
        -: 1496:
        -: 1497:// Constructs and returns the message for an equality assertion
        -: 1498:// (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.
        -: 1499://
        -: 1500:// The first four parameters are the expressions used in the assertion
        -: 1501:// and their values, as strings.  For example, for ASSERT_EQ(foo, bar)
        -: 1502:// where foo is 5 and bar is 6, we have:
        -: 1503://
        -: 1504://   lhs_expression: "foo"
        -: 1505://   rhs_expression: "bar"
        -: 1506://   lhs_value:      "5"
        -: 1507://   rhs_value:      "6"
        -: 1508://
        -: 1509:// The ignoring_case parameter is true if and only if the assertion is a
        -: 1510:// *_STRCASEEQ*.  When it's true, the string "Ignoring case" will
        -: 1511:// be inserted into the message.
    #####: 1512:AssertionResult EqFailure(const char* lhs_expression,
        -: 1513:                          const char* rhs_expression,
        -: 1514:                          const std::string& lhs_value,
        -: 1515:                          const std::string& rhs_value,
        -: 1516:                          bool ignoring_case) {
    #####: 1517:  Message msg;
    %%%%%: 1517-block  0
    $$$$$: 1517-block  1
    #####: 1518:  msg << "Expected equality of these values:";
    %%%%%: 1518-block  0
    #####: 1519:  msg << "\n  " << lhs_expression;
    %%%%%: 1519-block  0
    %%%%%: 1519-block  1
    #####: 1520:  if (lhs_value != lhs_expression) {
    %%%%%: 1520-block  0
    %%%%%: 1520-block  1
    #####: 1521:    msg << "\n    Which is: " << lhs_value;
    %%%%%: 1521-block  0
    %%%%%: 1521-block  1
        -: 1522:  }
    #####: 1523:  msg << "\n  " << rhs_expression;
    %%%%%: 1523-block  0
    %%%%%: 1523-block  1
    #####: 1524:  if (rhs_value != rhs_expression) {
    %%%%%: 1524-block  0
    %%%%%: 1524-block  1
    #####: 1525:    msg << "\n    Which is: " << rhs_value;
    %%%%%: 1525-block  0
    %%%%%: 1525-block  1
        -: 1526:  }
        -: 1527:
    #####: 1528:  if (ignoring_case) {
    %%%%%: 1528-block  0
    #####: 1529:    msg << "\nIgnoring case";
    %%%%%: 1529-block  0
        -: 1530:  }
        -: 1531:
    #####: 1532:  if (!lhs_value.empty() && !rhs_value.empty()) {
    %%%%%: 1532-block  0
    %%%%%: 1532-block  1
    %%%%%: 1532-block  2
    %%%%%: 1532-block  3
    %%%%%: 1532-block  4
        -: 1533:    const std::vector<std::string> lhs_lines =
    #####: 1534:        SplitEscapedString(lhs_value);
    %%%%%: 1534-block  0
    $$$$$: 1534-block  1
        -: 1535:    const std::vector<std::string> rhs_lines =
    #####: 1536:        SplitEscapedString(rhs_value);
    %%%%%: 1536-block  0
    %%%%%: 1536-block  1
    $$$$$: 1536-block  2
    #####: 1537:    if (lhs_lines.size() > 1 || rhs_lines.size() > 1) {
    %%%%%: 1537-block  0
    %%%%%: 1537-block  1
    %%%%%: 1537-block  2
    %%%%%: 1537-block  3
    %%%%%: 1537-block  4
    #####: 1538:      msg << "\nWith diff:\n"
    %%%%%: 1538-block  0
    #####: 1539:          << edit_distance::CreateUnifiedDiff(lhs_lines, rhs_lines);
    %%%%%: 1539-block  0
    %%%%%: 1539-block  1
    %%%%%: 1539-block  2
    $$$$$: 1539-block  3
    $$$$$: 1539-block  4
        -: 1540:    }
        -: 1541:  }
        -: 1542:
    #####: 1543:  return AssertionFailure() << msg;
    %%%%%: 1543-block  0
    %%%%%: 1543-block  1
    %%%%%: 1543-block  2
    %%%%%: 1543-block  3
    %%%%%: 1543-block  4
    $$$$$: 1543-block  5
    $$$$$: 1543-block  6
        -: 1544:}
        -: 1545:
        -: 1546:// Constructs a failure message for Boolean assertions such as EXPECT_TRUE.
    #####: 1547:std::string GetBoolAssertionFailureMessage(
        -: 1548:    const AssertionResult& assertion_result,
        -: 1549:    const char* expression_text,
        -: 1550:    const char* actual_predicate_value,
        -: 1551:    const char* expected_predicate_value) {
    #####: 1552:  const char* actual_message = assertion_result.message();
    %%%%%: 1552-block  0
    #####: 1553:  Message msg;
    %%%%%: 1553-block  0
    $$$$$: 1553-block  1
    #####: 1554:  msg << "Value of: " << expression_text
    %%%%%: 1554-block  0
    %%%%%: 1554-block  1
    #####: 1555:      << "\n  Actual: " << actual_predicate_value;
    %%%%%: 1555-block  0
    %%%%%: 1555-block  1
    #####: 1556:  if (actual_message[0] != '\0')
    %%%%%: 1556-block  0
    #####: 1557:    msg << " (" << actual_message << ")";
    %%%%%: 1557-block  0
    %%%%%: 1557-block  1
    %%%%%: 1557-block  2
    #####: 1558:  msg << "\nExpected: " << expected_predicate_value;
    %%%%%: 1558-block  0
    %%%%%: 1558-block  1
    #####: 1559:  return msg.GetString();
    %%%%%: 1559-block  0
    %%%%%: 1559-block  1
        -: 1560:}
        -: 1561:
        -: 1562:// Helper function for implementing ASSERT_NEAR.
    #####: 1563:AssertionResult DoubleNearPredFormat(const char* expr1,
        -: 1564:                                     const char* expr2,
        -: 1565:                                     const char* abs_error_expr,
        -: 1566:                                     double val1,
        -: 1567:                                     double val2,
        -: 1568:                                     double abs_error) {
    #####: 1569:  const double diff = fabs(val1 - val2);
    #####: 1570:  if (diff <= abs_error) return AssertionSuccess();
    %%%%%: 1570-block  0
    %%%%%: 1570-block  1
        -: 1571:
        -: 1572:  // Find the value which is closest to zero.
    #####: 1573:  const double min_abs = std::min(fabs(val1), fabs(val2));
    %%%%%: 1573-block  0
        -: 1574:  // Find the distance to the next double from that value.
        -: 1575:  const double epsilon =
    #####: 1576:      nextafter(min_abs, std::numeric_limits<double>::infinity()) - min_abs;
        -: 1577:  // Detect the case where abs_error is so small that EXPECT_NEAR is
        -: 1578:  // effectively the same as EXPECT_EQUAL, and give an informative error
        -: 1579:  // message so that the situation can be more easily understood without
        -: 1580:  // requiring exotic floating-point knowledge.
        -: 1581:  // Don't do an epsilon check if abs_error is zero because that implies
        -: 1582:  // that an equality check was actually intended.
    #####: 1583:  if (!(std::isnan)(val1) && !(std::isnan)(val2) && abs_error > 0 &&
    %%%%%: 1583-block  0
    %%%%%: 1583-block  1
    %%%%%: 1583-block  2
    %%%%%: 1583-block  3
    %%%%%: 1583-block  4
    #####: 1584:      abs_error < epsilon) {
    %%%%%: 1584-block  0
    #####: 1585:    return AssertionFailure()
    %%%%%: 1585-block  0
    %%%%%: 1585-block  1
    $$$$$: 1585-block  2
    $$$$$: 1585-block  3
    #####: 1586:           << "The difference between " << expr1 << " and " << expr2 << " is "
    %%%%%: 1586-block  0
    %%%%%: 1586-block  1
    %%%%%: 1586-block  2
    %%%%%: 1586-block  3
    %%%%%: 1586-block  4
    #####: 1587:           << diff << ", where\n"
    %%%%%: 1587-block  0
    %%%%%: 1587-block  1
    #####: 1588:           << expr1 << " evaluates to " << val1 << ",\n"
    %%%%%: 1588-block  0
    %%%%%: 1588-block  1
    %%%%%: 1588-block  2
    %%%%%: 1588-block  3
    #####: 1589:           << expr2 << " evaluates to " << val2 << ".\nThe abs_error parameter "
    %%%%%: 1589-block  0
    %%%%%: 1589-block  1
    %%%%%: 1589-block  2
    %%%%%: 1589-block  3
    #####: 1590:           << abs_error_expr << " evaluates to " << abs_error
    %%%%%: 1590-block  0
    %%%%%: 1590-block  1
    %%%%%: 1590-block  2
        -: 1591:           << " which is smaller than the minimum distance between doubles for "
    #####: 1592:              "numbers of this magnitude which is "
    %%%%%: 1592-block  0
    #####: 1593:           << epsilon
    %%%%%: 1593-block  0
        -: 1594:           << ", thus making this EXPECT_NEAR check equivalent to "
    #####: 1595:              "EXPECT_EQUAL. Consider using EXPECT_DOUBLE_EQ instead.";
    %%%%%: 1595-block  0
    %%%%%: 1595-block  1
        -: 1596:  }
    #####: 1597:  return AssertionFailure()
    %%%%%: 1597-block  0
    %%%%%: 1597-block  1
    $$$$$: 1597-block  2
    $$$$$: 1597-block  3
    #####: 1598:      << "The difference between " << expr1 << " and " << expr2
    %%%%%: 1598-block  0
    %%%%%: 1598-block  1
    %%%%%: 1598-block  2
    %%%%%: 1598-block  3
    #####: 1599:      << " is " << diff << ", which exceeds " << abs_error_expr << ", where\n"
    %%%%%: 1599-block  0
    %%%%%: 1599-block  1
    %%%%%: 1599-block  2
    %%%%%: 1599-block  3
    %%%%%: 1599-block  4
    #####: 1600:      << expr1 << " evaluates to " << val1 << ",\n"
    %%%%%: 1600-block  0
    %%%%%: 1600-block  1
    %%%%%: 1600-block  2
    %%%%%: 1600-block  3
    #####: 1601:      << expr2 << " evaluates to " << val2 << ", and\n"
    %%%%%: 1601-block  0
    %%%%%: 1601-block  1
    %%%%%: 1601-block  2
    %%%%%: 1601-block  3
    #####: 1602:      << abs_error_expr << " evaluates to " << abs_error << ".";
    %%%%%: 1602-block  0
    %%%%%: 1602-block  1
    %%%%%: 1602-block  2
    %%%%%: 1602-block  3
    %%%%%: 1602-block  4
        -: 1603:}
        -: 1604:
        -: 1605:
        -: 1606:// Helper template for implementing FloatLE() and DoubleLE().
        -: 1607:template <typename RawType>
    #####: 1608:AssertionResult FloatingPointLE(const char* expr1,
        -: 1609:                                const char* expr2,
        -: 1610:                                RawType val1,
        -: 1611:                                RawType val2) {
        -: 1612:  // Returns success if val1 is less than val2,
    #####: 1613:  if (val1 < val2) {
    #####: 1614:    return AssertionSuccess();
        -: 1615:  }
        -: 1616:
        -: 1617:  // or if val1 is almost equal to val2.
    #####: 1618:  const FloatingPoint<RawType> lhs(val1), rhs(val2);
    #####: 1619:  if (lhs.AlmostEquals(rhs)) {
    #####: 1620:    return AssertionSuccess();
        -: 1621:  }
        -: 1622:
        -: 1623:  // Note that the above two checks will both fail if either val1 or
        -: 1624:  // val2 is NaN, as the IEEE floating-point standard requires that
        -: 1625:  // any predicate involving a NaN must return false.
        -: 1626:
    #####: 1627:  ::std::stringstream val1_ss;
    #####: 1628:  val1_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)
    #####: 1629:          << val1;
        -: 1630:
    #####: 1631:  ::std::stringstream val2_ss;
    #####: 1632:  val2_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)
    #####: 1633:          << val2;
        -: 1634:
        -: 1635:  return AssertionFailure()
    #####: 1636:      << "Expected: (" << expr1 << ") <= (" << expr2 << ")\n"
    #####: 1637:      << "  Actual: " << StringStreamToString(&val1_ss) << " vs "
    #####: 1638:      << StringStreamToString(&val2_ss);
        -: 1639:}
------------------
_ZN7testing8internal15FloatingPointLEIdEENS_15AssertionResultEPKcS4_T_S5_:
    #####: 1608:AssertionResult FloatingPointLE(const char* expr1,
        -: 1609:                                const char* expr2,
        -: 1610:                                RawType val1,
        -: 1611:                                RawType val2) {
        -: 1612:  // Returns success if val1 is less than val2,
    #####: 1613:  if (val1 < val2) {
    %%%%%: 1613-block  0
    #####: 1614:    return AssertionSuccess();
    %%%%%: 1614-block  0
        -: 1615:  }
        -: 1616:
        -: 1617:  // or if val1 is almost equal to val2.
    #####: 1618:  const FloatingPoint<RawType> lhs(val1), rhs(val2);
    %%%%%: 1618-block  0
    #####: 1619:  if (lhs.AlmostEquals(rhs)) {
    %%%%%: 1619-block  0
    #####: 1620:    return AssertionSuccess();
    %%%%%: 1620-block  0
        -: 1621:  }
        -: 1622:
        -: 1623:  // Note that the above two checks will both fail if either val1 or
        -: 1624:  // val2 is NaN, as the IEEE floating-point standard requires that
        -: 1625:  // any predicate involving a NaN must return false.
        -: 1626:
    #####: 1627:  ::std::stringstream val1_ss;
    %%%%%: 1627-block  0
    $$$$$: 1627-block  1
    #####: 1628:  val1_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)
    %%%%%: 1628-block  0
    #####: 1629:          << val1;
    %%%%%: 1629-block  0
        -: 1630:
    #####: 1631:  ::std::stringstream val2_ss;
    %%%%%: 1631-block  0
    $$$$$: 1631-block  1
    #####: 1632:  val2_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)
    %%%%%: 1632-block  0
    #####: 1633:          << val2;
    %%%%%: 1633-block  0
        -: 1634:
        -: 1635:  return AssertionFailure()
    #####: 1636:      << "Expected: (" << expr1 << ") <= (" << expr2 << ")\n"
    %%%%%: 1636-block  0
    %%%%%: 1636-block  1
    %%%%%: 1636-block  2
    %%%%%: 1636-block  3
    %%%%%: 1636-block  4
    %%%%%: 1636-block  5
    $$$$$: 1636-block  6
    $$$$$: 1636-block  7
    #####: 1637:      << "  Actual: " << StringStreamToString(&val1_ss) << " vs "
    %%%%%: 1637-block  0
    %%%%%: 1637-block  1
    %%%%%: 1637-block  2
    %%%%%: 1637-block  3
    $$$$$: 1637-block  4
    $$$$$: 1637-block  5
    #####: 1638:      << StringStreamToString(&val2_ss);
    %%%%%: 1638-block  0
    %%%%%: 1638-block  1
    %%%%%: 1638-block  2
    %%%%%: 1638-block  3
    $$$$$: 1638-block  4
    $$$$$: 1638-block  5
        -: 1639:}
------------------
_ZN7testing8internal15FloatingPointLEIfEENS_15AssertionResultEPKcS4_T_S5_:
    #####: 1608:AssertionResult FloatingPointLE(const char* expr1,
        -: 1609:                                const char* expr2,
        -: 1610:                                RawType val1,
        -: 1611:                                RawType val2) {
        -: 1612:  // Returns success if val1 is less than val2,
    #####: 1613:  if (val1 < val2) {
    %%%%%: 1613-block  0
    #####: 1614:    return AssertionSuccess();
    %%%%%: 1614-block  0
        -: 1615:  }
        -: 1616:
        -: 1617:  // or if val1 is almost equal to val2.
    #####: 1618:  const FloatingPoint<RawType> lhs(val1), rhs(val2);
    %%%%%: 1618-block  0
    #####: 1619:  if (lhs.AlmostEquals(rhs)) {
    %%%%%: 1619-block  0
    #####: 1620:    return AssertionSuccess();
    %%%%%: 1620-block  0
        -: 1621:  }
        -: 1622:
        -: 1623:  // Note that the above two checks will both fail if either val1 or
        -: 1624:  // val2 is NaN, as the IEEE floating-point standard requires that
        -: 1625:  // any predicate involving a NaN must return false.
        -: 1626:
    #####: 1627:  ::std::stringstream val1_ss;
    %%%%%: 1627-block  0
    $$$$$: 1627-block  1
    #####: 1628:  val1_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)
    %%%%%: 1628-block  0
    #####: 1629:          << val1;
    %%%%%: 1629-block  0
        -: 1630:
    #####: 1631:  ::std::stringstream val2_ss;
    %%%%%: 1631-block  0
    $$$$$: 1631-block  1
    #####: 1632:  val2_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)
    %%%%%: 1632-block  0
    #####: 1633:          << val2;
    %%%%%: 1633-block  0
        -: 1634:
        -: 1635:  return AssertionFailure()
    #####: 1636:      << "Expected: (" << expr1 << ") <= (" << expr2 << ")\n"
    %%%%%: 1636-block  0
    %%%%%: 1636-block  1
    %%%%%: 1636-block  2
    %%%%%: 1636-block  3
    %%%%%: 1636-block  4
    %%%%%: 1636-block  5
    $$$$$: 1636-block  6
    $$$$$: 1636-block  7
    #####: 1637:      << "  Actual: " << StringStreamToString(&val1_ss) << " vs "
    %%%%%: 1637-block  0
    %%%%%: 1637-block  1
    %%%%%: 1637-block  2
    %%%%%: 1637-block  3
    $$$$$: 1637-block  4
    $$$$$: 1637-block  5
    #####: 1638:      << StringStreamToString(&val2_ss);
    %%%%%: 1638-block  0
    %%%%%: 1638-block  1
    %%%%%: 1638-block  2
    %%%%%: 1638-block  3
    $$$$$: 1638-block  4
    $$$$$: 1638-block  5
        -: 1639:}
------------------
        -: 1640:
        -: 1641:}  // namespace internal
        -: 1642:
        -: 1643:// Asserts that val1 is less than, or almost equal to, val2.  Fails
        -: 1644:// otherwise.  In particular, it fails if either val1 or val2 is NaN.
    #####: 1645:AssertionResult FloatLE(const char* expr1, const char* expr2,
        -: 1646:                        float val1, float val2) {
    #####: 1647:  return internal::FloatingPointLE<float>(expr1, expr2, val1, val2);
    %%%%%: 1647-block  0
        -: 1648:}
        -: 1649:
        -: 1650:// Asserts that val1 is less than, or almost equal to, val2.  Fails
        -: 1651:// otherwise.  In particular, it fails if either val1 or val2 is NaN.
    #####: 1652:AssertionResult DoubleLE(const char* expr1, const char* expr2,
        -: 1653:                         double val1, double val2) {
    #####: 1654:  return internal::FloatingPointLE<double>(expr1, expr2, val1, val2);
    %%%%%: 1654-block  0
        -: 1655:}
        -: 1656:
        -: 1657:namespace internal {
        -: 1658:
        -: 1659:// The helper function for {ASSERT|EXPECT}_STREQ.
    #####: 1660:AssertionResult CmpHelperSTREQ(const char* lhs_expression,
        -: 1661:                               const char* rhs_expression,
        -: 1662:                               const char* lhs,
        -: 1663:                               const char* rhs) {
    #####: 1664:  if (String::CStringEquals(lhs, rhs)) {
    %%%%%: 1664-block  0
    #####: 1665:    return AssertionSuccess();
    %%%%%: 1665-block  0
        -: 1666:  }
        -: 1667:
        -: 1668:  return EqFailure(lhs_expression,
        -: 1669:                   rhs_expression,
    #####: 1670:                   PrintToString(lhs),
    %%%%%: 1670-block  0
    $$$$$: 1670-block  1
    $$$$$: 1670-block  2
    #####: 1671:                   PrintToString(rhs),
    %%%%%: 1671-block  0
    $$$$$: 1671-block  1
    #####: 1672:                   false);
    %%%%%: 1672-block  0
        -: 1673:}
        -: 1674:
        -: 1675:// The helper function for {ASSERT|EXPECT}_STRCASEEQ.
    #####: 1676:AssertionResult CmpHelperSTRCASEEQ(const char* lhs_expression,
        -: 1677:                                   const char* rhs_expression,
        -: 1678:                                   const char* lhs,
        -: 1679:                                   const char* rhs) {
    #####: 1680:  if (String::CaseInsensitiveCStringEquals(lhs, rhs)) {
    %%%%%: 1680-block  0
    #####: 1681:    return AssertionSuccess();
    %%%%%: 1681-block  0
        -: 1682:  }
        -: 1683:
        -: 1684:  return EqFailure(lhs_expression,
        -: 1685:                   rhs_expression,
    #####: 1686:                   PrintToString(lhs),
    %%%%%: 1686-block  0
    $$$$$: 1686-block  1
    $$$$$: 1686-block  2
    #####: 1687:                   PrintToString(rhs),
    %%%%%: 1687-block  0
    $$$$$: 1687-block  1
    #####: 1688:                   true);
    %%%%%: 1688-block  0
        -: 1689:}
        -: 1690:
        -: 1691:// The helper function for {ASSERT|EXPECT}_STRNE.
    #####: 1692:AssertionResult CmpHelperSTRNE(const char* s1_expression,
        -: 1693:                               const char* s2_expression,
        -: 1694:                               const char* s1,
        -: 1695:                               const char* s2) {
    #####: 1696:  if (!String::CStringEquals(s1, s2)) {
    %%%%%: 1696-block  0
    #####: 1697:    return AssertionSuccess();
    %%%%%: 1697-block  0
        -: 1698:  } else {
    #####: 1699:    return AssertionFailure() << "Expected: (" << s1_expression << ") != ("
    %%%%%: 1699-block  0
    %%%%%: 1699-block  1
    %%%%%: 1699-block  2
    %%%%%: 1699-block  3
    $$$$$: 1699-block  4
    #####: 1700:                              << s2_expression << "), actual: \""
    %%%%%: 1700-block  0
    %%%%%: 1700-block  1
    #####: 1701:                              << s1 << "\" vs \"" << s2 << "\"";
    %%%%%: 1701-block  0
    %%%%%: 1701-block  1
    %%%%%: 1701-block  2
    %%%%%: 1701-block  3
    %%%%%: 1701-block  4
        -: 1702:  }
        -: 1703:}
        -: 1704:
        -: 1705:// The helper function for {ASSERT|EXPECT}_STRCASENE.
    #####: 1706:AssertionResult CmpHelperSTRCASENE(const char* s1_expression,
        -: 1707:                                   const char* s2_expression,
        -: 1708:                                   const char* s1,
        -: 1709:                                   const char* s2) {
    #####: 1710:  if (!String::CaseInsensitiveCStringEquals(s1, s2)) {
    %%%%%: 1710-block  0
    #####: 1711:    return AssertionSuccess();
    %%%%%: 1711-block  0
        -: 1712:  } else {
    #####: 1713:    return AssertionFailure()
    %%%%%: 1713-block  0
    %%%%%: 1713-block  1
    $$$$$: 1713-block  2
    #####: 1714:        << "Expected: (" << s1_expression << ") != ("
    %%%%%: 1714-block  0
    %%%%%: 1714-block  1
    #####: 1715:        << s2_expression << ") (ignoring case), actual: \""
    %%%%%: 1715-block  0
    %%%%%: 1715-block  1
    #####: 1716:        << s1 << "\" vs \"" << s2 << "\"";
    %%%%%: 1716-block  0
    %%%%%: 1716-block  1
    %%%%%: 1716-block  2
    %%%%%: 1716-block  3
    %%%%%: 1716-block  4
        -: 1717:  }
        -: 1718:}
        -: 1719:
        -: 1720:}  // namespace internal
        -: 1721:
        -: 1722:namespace {
        -: 1723:
        -: 1724:// Helper functions for implementing IsSubString() and IsNotSubstring().
        -: 1725:
        -: 1726:// This group of overloaded functions return true if and only if needle
        -: 1727:// is a substring of haystack.  NULL is considered a substring of
        -: 1728:// itself only.
        -: 1729:
    #####: 1730:bool IsSubstringPred(const char* needle, const char* haystack) {
    #####: 1731:  if (needle == nullptr || haystack == nullptr) return needle == haystack;
    %%%%%: 1731-block  0
    %%%%%: 1731-block  1
    %%%%%: 1731-block  2
        -: 1732:
    #####: 1733:  return strstr(haystack, needle) != nullptr;
    %%%%%: 1733-block  0
        -: 1734:}
        -: 1735:
    #####: 1736:bool IsSubstringPred(const wchar_t* needle, const wchar_t* haystack) {
    #####: 1737:  if (needle == nullptr || haystack == nullptr) return needle == haystack;
    %%%%%: 1737-block  0
    %%%%%: 1737-block  1
    %%%%%: 1737-block  2
        -: 1738:
    #####: 1739:  return wcsstr(haystack, needle) != nullptr;
    %%%%%: 1739-block  0
        -: 1740:}
        -: 1741:
        -: 1742:// StringType here can be either ::std::string or ::std::wstring.
        -: 1743:template <typename StringType>
    #####: 1744:bool IsSubstringPred(const StringType& needle,
        -: 1745:                     const StringType& haystack) {
    #####: 1746:  return haystack.find(needle) != StringType::npos;
        -: 1747:}
------------------
_ZN7testing12_GLOBAL__N_115IsSubstringPredINSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEEEEbRKT_SA_:
    #####: 1744:bool IsSubstringPred(const StringType& needle,
        -: 1745:                     const StringType& haystack) {
    #####: 1746:  return haystack.find(needle) != StringType::npos;
    %%%%%: 1746-block  0
        -: 1747:}
------------------
_ZN7testing12_GLOBAL__N_115IsSubstringPredINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEbRKT_SA_:
    #####: 1744:bool IsSubstringPred(const StringType& needle,
        -: 1745:                     const StringType& haystack) {
    #####: 1746:  return haystack.find(needle) != StringType::npos;
    %%%%%: 1746-block  0
        -: 1747:}
------------------
        -: 1748:
        -: 1749:// This function implements either IsSubstring() or IsNotSubstring(),
        -: 1750:// depending on the value of the expected_to_be_substring parameter.
        -: 1751:// StringType here can be const char*, const wchar_t*, ::std::string,
        -: 1752:// or ::std::wstring.
        -: 1753:template <typename StringType>
    #####: 1754:AssertionResult IsSubstringImpl(
        -: 1755:    bool expected_to_be_substring,
        -: 1756:    const char* needle_expr, const char* haystack_expr,
        -: 1757:    const StringType& needle, const StringType& haystack) {
    #####: 1758:  if (IsSubstringPred(needle, haystack) == expected_to_be_substring)
    #####: 1759:    return AssertionSuccess();
        -: 1760:
    #####: 1761:  const bool is_wide_string = sizeof(needle[0]) > 1;
    #####: 1762:  const char* const begin_string_quote = is_wide_string ? "L\"" : "\"";
        -: 1763:  return AssertionFailure()
    #####: 1764:      << "Value of: " << needle_expr << "\n"
    #####: 1765:      << "  Actual: " << begin_string_quote << needle << "\"\n"
    #####: 1766:      << "Expected: " << (expected_to_be_substring ? "" : "not ")
    #####: 1767:      << "a substring of " << haystack_expr << "\n"
    #####: 1768:      << "Which is: " << begin_string_quote << haystack << "\"";
        -: 1769:}
------------------
_ZN7testing12_GLOBAL__N_115IsSubstringImplINSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEEEENS_15AssertionResultEbPKcSA_RKT_SD_:
    #####: 1754:AssertionResult IsSubstringImpl(
        -: 1755:    bool expected_to_be_substring,
        -: 1756:    const char* needle_expr, const char* haystack_expr,
        -: 1757:    const StringType& needle, const StringType& haystack) {
    #####: 1758:  if (IsSubstringPred(needle, haystack) == expected_to_be_substring)
    %%%%%: 1758-block  0
    #####: 1759:    return AssertionSuccess();
    %%%%%: 1759-block  0
        -: 1760:
    #####: 1761:  const bool is_wide_string = sizeof(needle[0]) > 1;
    #####: 1762:  const char* const begin_string_quote = is_wide_string ? "L\"" : "\"";
        -: 1763:  return AssertionFailure()
    #####: 1764:      << "Value of: " << needle_expr << "\n"
    %%%%%: 1764-block  0
    %%%%%: 1764-block  1
    %%%%%: 1764-block  2
    %%%%%: 1764-block  3
    $$$$$: 1764-block  4
    $$$$$: 1764-block  5
    #####: 1765:      << "  Actual: " << begin_string_quote << needle << "\"\n"
    %%%%%: 1765-block  0
    %%%%%: 1765-block  1
    %%%%%: 1765-block  2
    %%%%%: 1765-block  3
    #####: 1766:      << "Expected: " << (expected_to_be_substring ? "" : "not ")
    %%%%%: 1766-block  0
    %%%%%: 1766-block  1
    %%%%%: 1766-block  2
    %%%%%: 1766-block  3
    %%%%%: 1766-block  4
    %%%%%: 1766-block  5
    $$$$$: 1766-block  6
    #####: 1767:      << "a substring of " << haystack_expr << "\n"
    %%%%%: 1767-block  0
    %%%%%: 1767-block  1
    %%%%%: 1767-block  2
    #####: 1768:      << "Which is: " << begin_string_quote << haystack << "\"";
    %%%%%: 1768-block  0
    %%%%%: 1768-block  1
    %%%%%: 1768-block  2
    %%%%%: 1768-block  3
    %%%%%: 1768-block  4
        -: 1769:}
------------------
_ZN7testing12_GLOBAL__N_115IsSubstringImplINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEENS_15AssertionResultEbPKcSA_RKT_SD_:
    #####: 1754:AssertionResult IsSubstringImpl(
        -: 1755:    bool expected_to_be_substring,
        -: 1756:    const char* needle_expr, const char* haystack_expr,
        -: 1757:    const StringType& needle, const StringType& haystack) {
    #####: 1758:  if (IsSubstringPred(needle, haystack) == expected_to_be_substring)
    %%%%%: 1758-block  0
    #####: 1759:    return AssertionSuccess();
    %%%%%: 1759-block  0
        -: 1760:
    #####: 1761:  const bool is_wide_string = sizeof(needle[0]) > 1;
    #####: 1762:  const char* const begin_string_quote = is_wide_string ? "L\"" : "\"";
        -: 1763:  return AssertionFailure()
    #####: 1764:      << "Value of: " << needle_expr << "\n"
    %%%%%: 1764-block  0
    %%%%%: 1764-block  1
    %%%%%: 1764-block  2
    %%%%%: 1764-block  3
    $$$$$: 1764-block  4
    $$$$$: 1764-block  5
    #####: 1765:      << "  Actual: " << begin_string_quote << needle << "\"\n"
    %%%%%: 1765-block  0
    %%%%%: 1765-block  1
    %%%%%: 1765-block  2
    %%%%%: 1765-block  3
    #####: 1766:      << "Expected: " << (expected_to_be_substring ? "" : "not ")
    %%%%%: 1766-block  0
    %%%%%: 1766-block  1
    %%%%%: 1766-block  2
    %%%%%: 1766-block  3
    %%%%%: 1766-block  4
    %%%%%: 1766-block  5
    $$$$$: 1766-block  6
    #####: 1767:      << "a substring of " << haystack_expr << "\n"
    %%%%%: 1767-block  0
    %%%%%: 1767-block  1
    %%%%%: 1767-block  2
    #####: 1768:      << "Which is: " << begin_string_quote << haystack << "\"";
    %%%%%: 1768-block  0
    %%%%%: 1768-block  1
    %%%%%: 1768-block  2
    %%%%%: 1768-block  3
    %%%%%: 1768-block  4
        -: 1769:}
------------------
_ZN7testing12_GLOBAL__N_115IsSubstringImplIPKwEENS_15AssertionResultEbPKcS6_RKT_S9_:
    #####: 1754:AssertionResult IsSubstringImpl(
        -: 1755:    bool expected_to_be_substring,
        -: 1756:    const char* needle_expr, const char* haystack_expr,
        -: 1757:    const StringType& needle, const StringType& haystack) {
    #####: 1758:  if (IsSubstringPred(needle, haystack) == expected_to_be_substring)
    %%%%%: 1758-block  0
    #####: 1759:    return AssertionSuccess();
    %%%%%: 1759-block  0
        -: 1760:
    #####: 1761:  const bool is_wide_string = sizeof(needle[0]) > 1;
    #####: 1762:  const char* const begin_string_quote = is_wide_string ? "L\"" : "\"";
        -: 1763:  return AssertionFailure()
    #####: 1764:      << "Value of: " << needle_expr << "\n"
    %%%%%: 1764-block  0
    %%%%%: 1764-block  1
    %%%%%: 1764-block  2
    %%%%%: 1764-block  3
    $$$$$: 1764-block  4
    $$$$$: 1764-block  5
    #####: 1765:      << "  Actual: " << begin_string_quote << needle << "\"\n"
    %%%%%: 1765-block  0
    %%%%%: 1765-block  1
    %%%%%: 1765-block  2
    %%%%%: 1765-block  3
    #####: 1766:      << "Expected: " << (expected_to_be_substring ? "" : "not ")
    %%%%%: 1766-block  0
    %%%%%: 1766-block  1
    %%%%%: 1766-block  2
    %%%%%: 1766-block  3
    %%%%%: 1766-block  4
    %%%%%: 1766-block  5
    $$$$$: 1766-block  6
    #####: 1767:      << "a substring of " << haystack_expr << "\n"
    %%%%%: 1767-block  0
    %%%%%: 1767-block  1
    %%%%%: 1767-block  2
    #####: 1768:      << "Which is: " << begin_string_quote << haystack << "\"";
    %%%%%: 1768-block  0
    %%%%%: 1768-block  1
    %%%%%: 1768-block  2
    %%%%%: 1768-block  3
    %%%%%: 1768-block  4
        -: 1769:}
------------------
_ZN7testing12_GLOBAL__N_115IsSubstringImplIPKcEENS_15AssertionResultEbS3_S3_RKT_S7_:
    #####: 1754:AssertionResult IsSubstringImpl(
        -: 1755:    bool expected_to_be_substring,
        -: 1756:    const char* needle_expr, const char* haystack_expr,
        -: 1757:    const StringType& needle, const StringType& haystack) {
    #####: 1758:  if (IsSubstringPred(needle, haystack) == expected_to_be_substring)
    %%%%%: 1758-block  0
    #####: 1759:    return AssertionSuccess();
    %%%%%: 1759-block  0
        -: 1760:
    #####: 1761:  const bool is_wide_string = sizeof(needle[0]) > 1;
    #####: 1762:  const char* const begin_string_quote = is_wide_string ? "L\"" : "\"";
        -: 1763:  return AssertionFailure()
    #####: 1764:      << "Value of: " << needle_expr << "\n"
    %%%%%: 1764-block  0
    %%%%%: 1764-block  1
    %%%%%: 1764-block  2
    %%%%%: 1764-block  3
    $$$$$: 1764-block  4
    $$$$$: 1764-block  5
    #####: 1765:      << "  Actual: " << begin_string_quote << needle << "\"\n"
    %%%%%: 1765-block  0
    %%%%%: 1765-block  1
    %%%%%: 1765-block  2
    %%%%%: 1765-block  3
    #####: 1766:      << "Expected: " << (expected_to_be_substring ? "" : "not ")
    %%%%%: 1766-block  0
    %%%%%: 1766-block  1
    %%%%%: 1766-block  2
    %%%%%: 1766-block  3
    %%%%%: 1766-block  4
    %%%%%: 1766-block  5
    $$$$$: 1766-block  6
    #####: 1767:      << "a substring of " << haystack_expr << "\n"
    %%%%%: 1767-block  0
    %%%%%: 1767-block  1
    %%%%%: 1767-block  2
    #####: 1768:      << "Which is: " << begin_string_quote << haystack << "\"";
    %%%%%: 1768-block  0
    %%%%%: 1768-block  1
    %%%%%: 1768-block  2
    %%%%%: 1768-block  3
    %%%%%: 1768-block  4
        -: 1769:}
------------------
        -: 1770:
        -: 1771:}  // namespace
        -: 1772:
        -: 1773:// IsSubstring() and IsNotSubstring() check whether needle is a
        -: 1774:// substring of haystack (NULL is considered a substring of itself
        -: 1775:// only), and return an appropriate error message when they fail.
        -: 1776:
    #####: 1777:AssertionResult IsSubstring(
        -: 1778:    const char* needle_expr, const char* haystack_expr,
        -: 1779:    const char* needle, const char* haystack) {
    #####: 1780:  return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);
    %%%%%: 1780-block  0
        -: 1781:}
        -: 1782:
    #####: 1783:AssertionResult IsSubstring(
        -: 1784:    const char* needle_expr, const char* haystack_expr,
        -: 1785:    const wchar_t* needle, const wchar_t* haystack) {
    #####: 1786:  return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);
    %%%%%: 1786-block  0
        -: 1787:}
        -: 1788:
    #####: 1789:AssertionResult IsNotSubstring(
        -: 1790:    const char* needle_expr, const char* haystack_expr,
        -: 1791:    const char* needle, const char* haystack) {
    #####: 1792:  return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);
    %%%%%: 1792-block  0
        -: 1793:}
        -: 1794:
    #####: 1795:AssertionResult IsNotSubstring(
        -: 1796:    const char* needle_expr, const char* haystack_expr,
        -: 1797:    const wchar_t* needle, const wchar_t* haystack) {
    #####: 1798:  return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);
    %%%%%: 1798-block  0
        -: 1799:}
        -: 1800:
    #####: 1801:AssertionResult IsSubstring(
        -: 1802:    const char* needle_expr, const char* haystack_expr,
        -: 1803:    const ::std::string& needle, const ::std::string& haystack) {
    #####: 1804:  return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);
    %%%%%: 1804-block  0
        -: 1805:}
        -: 1806:
    #####: 1807:AssertionResult IsNotSubstring(
        -: 1808:    const char* needle_expr, const char* haystack_expr,
        -: 1809:    const ::std::string& needle, const ::std::string& haystack) {
    #####: 1810:  return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);
    %%%%%: 1810-block  0
        -: 1811:}
        -: 1812:
        -: 1813:#if GTEST_HAS_STD_WSTRING
    #####: 1814:AssertionResult IsSubstring(
        -: 1815:    const char* needle_expr, const char* haystack_expr,
        -: 1816:    const ::std::wstring& needle, const ::std::wstring& haystack) {
    #####: 1817:  return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);
    %%%%%: 1817-block  0
        -: 1818:}
        -: 1819:
    #####: 1820:AssertionResult IsNotSubstring(
        -: 1821:    const char* needle_expr, const char* haystack_expr,
        -: 1822:    const ::std::wstring& needle, const ::std::wstring& haystack) {
    #####: 1823:  return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);
    %%%%%: 1823-block  0
        -: 1824:}
        -: 1825:#endif  // GTEST_HAS_STD_WSTRING
        -: 1826:
        -: 1827:namespace internal {
        -: 1828:
        -: 1829:#if GTEST_OS_WINDOWS
        -: 1830:
        -: 1831:namespace {
        -: 1832:
        -: 1833:// Helper function for IsHRESULT{SuccessFailure} predicates
        -: 1834:AssertionResult HRESULTFailureHelper(const char* expr,
        -: 1835:                                     const char* expected,
        -: 1836:                                     long hr) {  // NOLINT
        -: 1837:# if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_TV_TITLE
        -: 1838:
        -: 1839:  // Windows CE doesn't support FormatMessage.
        -: 1840:  const char error_text[] = "";
        -: 1841:
        -: 1842:# else
        -: 1843:
        -: 1844:  // Looks up the human-readable system message for the HRESULT code
        -: 1845:  // and since we're not passing any params to FormatMessage, we don't
        -: 1846:  // want inserts expanded.
        -: 1847:  const DWORD kFlags = FORMAT_MESSAGE_FROM_SYSTEM |
        -: 1848:                       FORMAT_MESSAGE_IGNORE_INSERTS;
        -: 1849:  const DWORD kBufSize = 4096;
        -: 1850:  // Gets the system's human readable message string for this HRESULT.
        -: 1851:  char error_text[kBufSize] = { '\0' };
        -: 1852:  DWORD message_length = ::FormatMessageA(kFlags,
        -: 1853:                                          0,   // no source, we're asking system
        -: 1854:                                          static_cast<DWORD>(hr),  // the error
        -: 1855:                                          0,   // no line width restrictions
        -: 1856:                                          error_text,  // output buffer
        -: 1857:                                          kBufSize,    // buf size
        -: 1858:                                          nullptr);  // no arguments for inserts
        -: 1859:  // Trims tailing white space (FormatMessage leaves a trailing CR-LF)
        -: 1860:  for (; message_length && IsSpace(error_text[message_length - 1]);
        -: 1861:          --message_length) {
        -: 1862:    error_text[message_length - 1] = '\0';
        -: 1863:  }
        -: 1864:
        -: 1865:# endif  // GTEST_OS_WINDOWS_MOBILE
        -: 1866:
        -: 1867:  const std::string error_hex("0x" + String::FormatHexInt(hr));
        -: 1868:  return ::testing::AssertionFailure()
        -: 1869:      << "Expected: " << expr << " " << expected << ".\n"
        -: 1870:      << "  Actual: " << error_hex << " " << error_text << "\n";
        -: 1871:}
        -: 1872:
        -: 1873:}  // namespace
        -: 1874:
        -: 1875:AssertionResult IsHRESULTSuccess(const char* expr, long hr) {  // NOLINT
        -: 1876:  if (SUCCEEDED(hr)) {
        -: 1877:    return AssertionSuccess();
        -: 1878:  }
        -: 1879:  return HRESULTFailureHelper(expr, "succeeds", hr);
        -: 1880:}
        -: 1881:
        -: 1882:AssertionResult IsHRESULTFailure(const char* expr, long hr) {  // NOLINT
        -: 1883:  if (FAILED(hr)) {
        -: 1884:    return AssertionSuccess();
        -: 1885:  }
        -: 1886:  return HRESULTFailureHelper(expr, "fails", hr);
        -: 1887:}
        -: 1888:
        -: 1889:#endif  // GTEST_OS_WINDOWS
        -: 1890:
        -: 1891:// Utility functions for encoding Unicode text (wide strings) in
        -: 1892:// UTF-8.
        -: 1893:
        -: 1894:// A Unicode code-point can have up to 21 bits, and is encoded in UTF-8
        -: 1895:// like this:
        -: 1896://
        -: 1897:// Code-point length   Encoding
        -: 1898://   0 -  7 bits       0xxxxxxx
        -: 1899://   8 - 11 bits       110xxxxx 10xxxxxx
        -: 1900://  12 - 16 bits       1110xxxx 10xxxxxx 10xxxxxx
        -: 1901://  17 - 21 bits       11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        -: 1902:
        -: 1903:// The maximum code-point a one-byte UTF-8 sequence can represent.
        -: 1904:constexpr uint32_t kMaxCodePoint1 = (static_cast<uint32_t>(1) <<  7) - 1;
        -: 1905:
        -: 1906:// The maximum code-point a two-byte UTF-8 sequence can represent.
        -: 1907:constexpr uint32_t kMaxCodePoint2 = (static_cast<uint32_t>(1) << (5 + 6)) - 1;
        -: 1908:
        -: 1909:// The maximum code-point a three-byte UTF-8 sequence can represent.
        -: 1910:constexpr uint32_t kMaxCodePoint3 = (static_cast<uint32_t>(1) << (4 + 2*6)) - 1;
        -: 1911:
        -: 1912:// The maximum code-point a four-byte UTF-8 sequence can represent.
        -: 1913:constexpr uint32_t kMaxCodePoint4 = (static_cast<uint32_t>(1) << (3 + 3*6)) - 1;
        -: 1914:
        -: 1915:// Chops off the n lowest bits from a bit pattern.  Returns the n
        -: 1916:// lowest bits.  As a side effect, the original bit pattern will be
        -: 1917:// shifted to the right by n bits.
    #####: 1918:inline uint32_t ChopLowBits(uint32_t* bits, int n) {
    #####: 1919:  const uint32_t low_bits = *bits & ((static_cast<uint32_t>(1) << n) - 1);
    #####: 1920:  *bits >>= n;
    #####: 1921:  return low_bits;
    %%%%%: 1921-block  0
        -: 1922:}
        -: 1923:
        -: 1924:// Converts a Unicode code point to a narrow string in UTF-8 encoding.
        -: 1925:// code_point parameter is of type uint32_t because wchar_t may not be
        -: 1926:// wide enough to contain a code point.
        -: 1927:// If the code_point is not a valid Unicode code point
        -: 1928:// (i.e. outside of Unicode range U+0 to U+10FFFF) it will be converted
        -: 1929:// to "(Invalid Unicode 0xXXXXXXXX)".
    #####: 1930:std::string CodePointToUtf8(uint32_t code_point) {
    #####: 1931:  if (code_point > kMaxCodePoint4) {
    %%%%%: 1931-block  0
    #####: 1932:    return "(Invalid Unicode 0x" + String::FormatHexUInt32(code_point) + ")";
    %%%%%: 1932-block  0
    %%%%%: 1932-block  1
    %%%%%: 1932-block  2
    %%%%%: 1932-block  3
    $$$$$: 1932-block  4
    $$$$$: 1932-block  5
    $$$$$: 1932-block  6
    $$$$$: 1932-block  7
        -: 1933:  }
        -: 1934:
        -: 1935:  char str[5];  // Big enough for the largest valid code point.
    #####: 1936:  if (code_point <= kMaxCodePoint1) {
    %%%%%: 1936-block  0
    #####: 1937:    str[1] = '\0';
    #####: 1938:    str[0] = static_cast<char>(code_point);                          // 0xxxxxxx
    %%%%%: 1938-block  0
    #####: 1939:  } else if (code_point <= kMaxCodePoint2) {
    %%%%%: 1939-block  0
    #####: 1940:    str[2] = '\0';
    #####: 1941:    str[1] = static_cast<char>(0x80 | ChopLowBits(&code_point, 6));  // 10xxxxxx
    %%%%%: 1941-block  0
    #####: 1942:    str[0] = static_cast<char>(0xC0 | code_point);                   // 110xxxxx
    #####: 1943:  } else if (code_point <= kMaxCodePoint3) {
    %%%%%: 1943-block  0
    #####: 1944:    str[3] = '\0';
    #####: 1945:    str[2] = static_cast<char>(0x80 | ChopLowBits(&code_point, 6));  // 10xxxxxx
    %%%%%: 1945-block  0
    #####: 1946:    str[1] = static_cast<char>(0x80 | ChopLowBits(&code_point, 6));  // 10xxxxxx
    #####: 1947:    str[0] = static_cast<char>(0xE0 | code_point);                   // 1110xxxx
        -: 1948:  } else {  // code_point <= kMaxCodePoint4
    #####: 1949:    str[4] = '\0';
    #####: 1950:    str[3] = static_cast<char>(0x80 | ChopLowBits(&code_point, 6));  // 10xxxxxx
    %%%%%: 1950-block  0
    #####: 1951:    str[2] = static_cast<char>(0x80 | ChopLowBits(&code_point, 6));  // 10xxxxxx
    #####: 1952:    str[1] = static_cast<char>(0x80 | ChopLowBits(&code_point, 6));  // 10xxxxxx
    #####: 1953:    str[0] = static_cast<char>(0xF0 | code_point);                   // 11110xxx
        -: 1954:  }
    #####: 1955:  return str;
    %%%%%: 1955-block  0
    %%%%%: 1955-block  1
    $$$$$: 1955-block  2
    $$$$$: 1955-block  3
        -: 1956:}
        -: 1957:
        -: 1958:// The following two functions only make sense if the system
        -: 1959:// uses UTF-16 for wide string encoding. All supported systems
        -: 1960:// with 16 bit wchar_t (Windows, Cygwin) do use UTF-16.
        -: 1961:
        -: 1962:// Determines if the arguments constitute UTF-16 surrogate pair
        -: 1963:// and thus should be combined into a single Unicode code point
        -: 1964:// using CreateCodePointFromUtf16SurrogatePair.
    #####: 1965:inline bool IsUtf16SurrogatePair(wchar_t first, wchar_t second) {
        -: 1966:  return sizeof(wchar_t) == 2 &&
    #####: 1967:      (first & 0xFC00) == 0xD800 && (second & 0xFC00) == 0xDC00;
    %%%%%: 1967-block  0
        -: 1968:}
        -: 1969:
        -: 1970:// Creates a Unicode code point from UTF16 surrogate pair.
    #####: 1971:inline uint32_t CreateCodePointFromUtf16SurrogatePair(wchar_t first,
        -: 1972:                                                      wchar_t second) {
    #####: 1973:  const auto first_u = static_cast<uint32_t>(first);
    #####: 1974:  const auto second_u = static_cast<uint32_t>(second);
    #####: 1975:  const uint32_t mask = (1 << 10) - 1;
        -: 1976:  return (sizeof(wchar_t) == 2)
        -: 1977:             ? (((first_u & mask) << 10) | (second_u & mask)) + 0x10000
        -: 1978:             :
        -: 1979:             // This function should not be called when the condition is
        -: 1980:             // false, but we provide a sensible default in case it is.
    #####: 1981:             first_u;
    %%%%%: 1981-block  0
        -: 1982:}
        -: 1983:
        -: 1984:// Converts a wide string to a narrow string in UTF-8 encoding.
        -: 1985:// The wide string is assumed to have the following encoding:
        -: 1986://   UTF-16 if sizeof(wchar_t) == 2 (on Windows, Cygwin)
        -: 1987://   UTF-32 if sizeof(wchar_t) == 4 (on Linux)
        -: 1988:// Parameter str points to a null-terminated wide string.
        -: 1989:// Parameter num_chars may additionally limit the number
        -: 1990:// of wchar_t characters processed. -1 is used when the entire string
        -: 1991:// should be processed.
        -: 1992:// If the string contains code points that are not valid Unicode code points
        -: 1993:// (i.e. outside of Unicode range U+0 to U+10FFFF) they will be output
        -: 1994:// as '(Invalid Unicode 0xXXXXXXXX)'. If the string is in UTF16 encoding
        -: 1995:// and contains invalid UTF-16 surrogate pairs, values in those pairs
        -: 1996:// will be encoded as individual Unicode characters from Basic Normal Plane.
    #####: 1997:std::string WideStringToUtf8(const wchar_t* str, int num_chars) {
    #####: 1998:  if (num_chars == -1)
    %%%%%: 1998-block  0
    #####: 1999:    num_chars = static_cast<int>(wcslen(str));
    %%%%%: 1999-block  0
        -: 2000:
    #####: 2001:  ::std::stringstream stream;
    %%%%%: 2001-block  0
    %%%%%: 2001-block  1
    $$$$$: 2001-block  2
    #####: 2002:  for (int i = 0; i < num_chars; ++i) {
    %%%%%: 2002-block  0
    %%%%%: 2002-block  1
        -: 2003:    uint32_t unicode_code_point;
        -: 2004:
    #####: 2005:    if (str[i] == L'\0') {
    %%%%%: 2005-block  0
    #####: 2006:      break;
    %%%%%: 2006-block  0
    #####: 2007:    } else if (i + 1 < num_chars && IsUtf16SurrogatePair(str[i], str[i + 1])) {
    %%%%%: 2007-block  0
    %%%%%: 2007-block  1
    %%%%%: 2007-block  2
    %%%%%: 2007-block  3
    %%%%%: 2007-block  4
    #####: 2008:      unicode_code_point = CreateCodePointFromUtf16SurrogatePair(str[i],
    #####: 2009:                                                                 str[i + 1]);
    %%%%%: 2009-block  0
    #####: 2010:      i++;
        -: 2011:    } else {
    #####: 2012:      unicode_code_point = static_cast<uint32_t>(str[i]);
    %%%%%: 2012-block  0
        -: 2013:    }
        -: 2014:
    #####: 2015:    stream << CodePointToUtf8(unicode_code_point);
    %%%%%: 2015-block  0
    %%%%%: 2015-block  1
    %%%%%: 2015-block  2
    $$$$$: 2015-block  3
    $$$$$: 2015-block  4
        -: 2016:  }
    #####: 2017:  return StringStreamToString(&stream);
    %%%%%: 2017-block  0
    %%%%%: 2017-block  1
        -: 2018:}
        -: 2019:
        -: 2020:// Converts a wide C string to an std::string using the UTF-8 encoding.
        -: 2021:// NULL will be converted to "(null)".
    #####: 2022:std::string String::ShowWideCString(const wchar_t * wide_c_str) {
    #####: 2023:  if (wide_c_str == nullptr) return "(null)";
    %%%%%: 2023-block  0
    %%%%%: 2023-block  1
    %%%%%: 2023-block  2
    $$$$$: 2023-block  3
        -: 2024:
    #####: 2025:  return internal::WideStringToUtf8(wide_c_str, -1);
    %%%%%: 2025-block  0
        -: 2026:}
        -: 2027:
        -: 2028:// Compares two wide C strings.  Returns true if and only if they have the
        -: 2029:// same content.
        -: 2030://
        -: 2031:// Unlike wcscmp(), this function can handle NULL argument(s).  A NULL
        -: 2032:// C string is considered different to any non-NULL C string,
        -: 2033:// including the empty string.
    #####: 2034:bool String::WideCStringEquals(const wchar_t * lhs, const wchar_t * rhs) {
    #####: 2035:  if (lhs == nullptr) return rhs == nullptr;
    %%%%%: 2035-block  0
    %%%%%: 2035-block  1
        -: 2036:
    #####: 2037:  if (rhs == nullptr) return false;
    %%%%%: 2037-block  0
    %%%%%: 2037-block  1
        -: 2038:
    #####: 2039:  return wcscmp(lhs, rhs) == 0;
    %%%%%: 2039-block  0
        -: 2040:}
        -: 2041:
        -: 2042:// Helper function for *_STREQ on wide strings.
    #####: 2043:AssertionResult CmpHelperSTREQ(const char* lhs_expression,
        -: 2044:                               const char* rhs_expression,
        -: 2045:                               const wchar_t* lhs,
        -: 2046:                               const wchar_t* rhs) {
    #####: 2047:  if (String::WideCStringEquals(lhs, rhs)) {
    %%%%%: 2047-block  0
    #####: 2048:    return AssertionSuccess();
    %%%%%: 2048-block  0
        -: 2049:  }
        -: 2050:
        -: 2051:  return EqFailure(lhs_expression,
        -: 2052:                   rhs_expression,
    #####: 2053:                   PrintToString(lhs),
    %%%%%: 2053-block  0
    $$$$$: 2053-block  1
    $$$$$: 2053-block  2
    #####: 2054:                   PrintToString(rhs),
    %%%%%: 2054-block  0
    $$$$$: 2054-block  1
    #####: 2055:                   false);
    %%%%%: 2055-block  0
        -: 2056:}
        -: 2057:
        -: 2058:// Helper function for *_STRNE on wide strings.
    #####: 2059:AssertionResult CmpHelperSTRNE(const char* s1_expression,
        -: 2060:                               const char* s2_expression,
        -: 2061:                               const wchar_t* s1,
        -: 2062:                               const wchar_t* s2) {
    #####: 2063:  if (!String::WideCStringEquals(s1, s2)) {
    %%%%%: 2063-block  0
    #####: 2064:    return AssertionSuccess();
    %%%%%: 2064-block  0
        -: 2065:  }
        -: 2066:
    #####: 2067:  return AssertionFailure() << "Expected: (" << s1_expression << ") != ("
    %%%%%: 2067-block  0
    %%%%%: 2067-block  1
    %%%%%: 2067-block  2
    $$$$$: 2067-block  3
    #####: 2068:                            << s2_expression << "), actual: "
    %%%%%: 2068-block  0
    %%%%%: 2068-block  1
    #####: 2069:                            << PrintToString(s1)
    %%%%%: 2069-block  0
    %%%%%: 2069-block  1
    $$$$$: 2069-block  2
    $$$$$: 2069-block  3
    #####: 2070:                            << " vs " << PrintToString(s2);
    %%%%%: 2070-block  0
    %%%%%: 2070-block  1
    %%%%%: 2070-block  2
    %%%%%: 2070-block  3
    %%%%%: 2070-block  4
    $$$$$: 2070-block  5
    $$$$$: 2070-block  6
        -: 2071:}
        -: 2072:
        -: 2073:// Compares two C strings, ignoring case.  Returns true if and only if they have
        -: 2074:// the same content.
        -: 2075://
        -: 2076:// Unlike strcasecmp(), this function can handle NULL argument(s).  A
        -: 2077:// NULL C string is considered different to any non-NULL C string,
        -: 2078:// including the empty string.
        4: 2079:bool String::CaseInsensitiveCStringEquals(const char * lhs, const char * rhs) {
       4*: 2080:  if (lhs == nullptr) return rhs == nullptr;
        4: 2080-block  0
    %%%%%: 2080-block  1
       4*: 2081:  if (rhs == nullptr) return false;
        4: 2081-block  0
    %%%%%: 2081-block  1
        4: 2082:  return posix::StrCaseCmp(lhs, rhs) == 0;
        4: 2082-block  0
        -: 2083:}
        -: 2084:
        -: 2085:// Compares two wide C strings, ignoring case.  Returns true if and only if they
        -: 2086:// have the same content.
        -: 2087://
        -: 2088:// Unlike wcscasecmp(), this function can handle NULL argument(s).
        -: 2089:// A NULL C string is considered different to any non-NULL wide C string,
        -: 2090:// including the empty string.
        -: 2091:// NB: The implementations on different platforms slightly differ.
        -: 2092:// On windows, this method uses _wcsicmp which compares according to LC_CTYPE
        -: 2093:// environment variable. On GNU platform this method uses wcscasecmp
        -: 2094:// which compares according to LC_CTYPE category of the current locale.
        -: 2095:// On MacOS X, it uses towlower, which also uses LC_CTYPE category of the
        -: 2096:// current locale.
    #####: 2097:bool String::CaseInsensitiveWideCStringEquals(const wchar_t* lhs,
        -: 2098:                                              const wchar_t* rhs) {
    #####: 2099:  if (lhs == nullptr) return rhs == nullptr;
    %%%%%: 2099-block  0
    %%%%%: 2099-block  1
        -: 2100:
    #####: 2101:  if (rhs == nullptr) return false;
    %%%%%: 2101-block  0
    %%%%%: 2101-block  1
        -: 2102:
        -: 2103:#if GTEST_OS_WINDOWS
        -: 2104:  return _wcsicmp(lhs, rhs) == 0;
        -: 2105:#elif GTEST_OS_LINUX && !GTEST_OS_LINUX_ANDROID
    #####: 2106:  return wcscasecmp(lhs, rhs) == 0;
    %%%%%: 2106-block  0
        -: 2107:#else
        -: 2108:  // Android, Mac OS X and Cygwin don't define wcscasecmp.
        -: 2109:  // Other unknown OSes may not define it either.
        -: 2110:  wint_t left, right;
        -: 2111:  do {
        -: 2112:    left = towlower(static_cast<wint_t>(*lhs++));
        -: 2113:    right = towlower(static_cast<wint_t>(*rhs++));
        -: 2114:  } while (left && left == right);
        -: 2115:  return left == right;
        -: 2116:#endif  // OS selector
        -: 2117:}
        -: 2118:
        -: 2119:// Returns true if and only if str ends with the given suffix, ignoring case.
        -: 2120:// Any string is considered to end with an empty suffix.
    #####: 2121:bool String::EndsWithCaseInsensitive(
        -: 2122:    const std::string& str, const std::string& suffix) {
    #####: 2123:  const size_t str_len = str.length();
    %%%%%: 2123-block  0
    #####: 2124:  const size_t suffix_len = suffix.length();
    #####: 2125:  return (str_len >= suffix_len) &&
    %%%%%: 2125-block  0
    %%%%%: 2125-block  1
    #####: 2126:         CaseInsensitiveCStringEquals(str.c_str() + str_len - suffix_len,
    %%%%%: 2126-block  0
    #####: 2127:                                      suffix.c_str());
    %%%%%: 2127-block  0
        -: 2128:}
        -: 2129:
        -: 2130:// Formats an int value as "%02d".
    #####: 2131:std::string String::FormatIntWidth2(int value) {
    #####: 2132:  return FormatIntWidthN(value, 2);
    %%%%%: 2132-block  0
        -: 2133:}
        -: 2134:
        -: 2135:// Formats an int value to given width with leading zeros.
    #####: 2136:std::string String::FormatIntWidthN(int value, int width) {
    #####: 2137:  std::stringstream ss;
    %%%%%: 2137-block  0
    %%%%%: 2137-block  1
    $$$$$: 2137-block  2
    #####: 2138:  ss << std::setfill('0') << std::setw(width) << value;
    %%%%%: 2138-block  0
    %%%%%: 2138-block  1
    %%%%%: 2138-block  2
    #####: 2139:  return ss.str();
    %%%%%: 2139-block  0
    %%%%%: 2139-block  1
        -: 2140:}
        -: 2141:
        -: 2142:// Formats an int value as "%X".
    #####: 2143:std::string String::FormatHexUInt32(uint32_t value) {
    #####: 2144:  std::stringstream ss;
    %%%%%: 2144-block  0
    %%%%%: 2144-block  1
    $$$$$: 2144-block  2
    #####: 2145:  ss << std::hex << std::uppercase << value;
    %%%%%: 2145-block  0
    %%%%%: 2145-block  1
    %%%%%: 2145-block  2
    #####: 2146:  return ss.str();
    %%%%%: 2146-block  0
    %%%%%: 2146-block  1
        -: 2147:}
        -: 2148:
        -: 2149:// Formats an int value as "%X".
    #####: 2150:std::string String::FormatHexInt(int value) {
    #####: 2151:  return FormatHexUInt32(static_cast<uint32_t>(value));
    %%%%%: 2151-block  0
        -: 2152:}
        -: 2153:
        -: 2154:// Formats a byte as "%02X".
    #####: 2155:std::string String::FormatByte(unsigned char value) {
    #####: 2156:  std::stringstream ss;
    %%%%%: 2156-block  0
    %%%%%: 2156-block  1
    $$$$$: 2156-block  2
    #####: 2157:  ss << std::setfill('0') << std::setw(2) << std::hex << std::uppercase
    %%%%%: 2157-block  0
    %%%%%: 2157-block  1
    %%%%%: 2157-block  2
    %%%%%: 2157-block  3
    #####: 2158:     << static_cast<unsigned int>(value);
    %%%%%: 2158-block  0
    #####: 2159:  return ss.str();
    %%%%%: 2159-block  0
    %%%%%: 2159-block  1
        -: 2160:}
        -: 2161:
        -: 2162:// Converts the buffer in a stringstream to an std::string, converting NUL
        -: 2163:// bytes to "\\0" along the way.
       85: 2164:std::string StringStreamToString(::std::stringstream* ss) {
      170: 2165:  const ::std::string& str = ss->str();
       85: 2165-block  0
       85: 2165-block  1
    $$$$$: 2165-block  2
       85: 2166:  const char* const start = str.c_str();
       85: 2166-block  0
       85: 2167:  const char* const end = start + str.length();
        -: 2168:
       85: 2169:  std::string result;
       85: 2170:  result.reserve(static_cast<size_t>(2 * (end - start)));
     1314: 2171:  for (const char* ch = start; ch != end; ++ch) {
       85: 2171-block  0
     1314: 2171-block  1
     1229: 2171-block  2
     1229: 2172:    if (*ch == '\0') {
     1229: 2172-block  0
    #####: 2173:      result += "\\0";  // Replaces NUL with "\\0";
    %%%%%: 2173-block  0
        -: 2174:    } else {
     1229: 2175:      result += *ch;
     1229: 2175-block  0
        -: 2176:    }
        -: 2177:  }
        -: 2178:
      170: 2179:  return result;
       85: 2179-block  0
       85: 2179-block  1
        -: 2180:}
        -: 2181:
        -: 2182:// Appends the user-supplied message to the Google-Test-generated message.
    #####: 2183:std::string AppendUserMessage(const std::string& gtest_msg,
        -: 2184:                              const Message& user_msg) {
        -: 2185:  // Appends the user message if it's non-empty.
    #####: 2186:  const std::string user_msg_string = user_msg.GetString();
    %%%%%: 2186-block  0
    %%%%%: 2186-block  1
    $$$$$: 2186-block  2
    #####: 2187:  if (user_msg_string.empty()) {
    %%%%%: 2187-block  0
    #####: 2188:    return gtest_msg;
    %%%%%: 2188-block  0
        -: 2189:  }
    #####: 2190:  if (gtest_msg.empty()) {
    %%%%%: 2190-block  0
    #####: 2191:    return user_msg_string;
    %%%%%: 2191-block  0
        -: 2192:  }
    #####: 2193:  return gtest_msg + "\n" + user_msg_string;
    %%%%%: 2193-block  0
    %%%%%: 2193-block  1
    %%%%%: 2193-block  2
    $$$$$: 2193-block  3
    $$$$$: 2193-block  4
        -: 2194:}
        -: 2195:
        -: 2196:}  // namespace internal
        -: 2197:
        -: 2198:// class TestResult
        -: 2199:
        -: 2200:// Creates an empty TestResult.
       44: 2201:TestResult::TestResult()
       44: 2202:    : death_test_count_(0), start_timestamp_(0), elapsed_time_(0) {}
       44: 2202-block  0
        -: 2203:
        -: 2204:// D'tor.
       44: 2205:TestResult::~TestResult() {
       44: 2205-block  0
       44: 2206:}
        -: 2207:
        -: 2208:// Returns the i-th test part result among all the results. i can
        -: 2209:// range from 0 to total_part_count() - 1. If i is not in that range,
        -: 2210:// aborts the program.
    #####: 2211:const TestPartResult& TestResult::GetTestPartResult(int i) const {
    #####: 2212:  if (i < 0 || i >= total_part_count())
    %%%%%: 2212-block  0
    %%%%%: 2212-block  1
    %%%%%: 2212-block  2
    %%%%%: 2212-block  3
    %%%%%: 2212-block  4
    #####: 2213:    internal::posix::Abort();
    %%%%%: 2213-block  0
    #####: 2214:  return test_part_results_.at(static_cast<size_t>(i));
    %%%%%: 2214-block  0
        -: 2215:}
        -: 2216:
        -: 2217:// Returns the i-th test property. i can range from 0 to
        -: 2218:// test_property_count() - 1. If i is not in that range, aborts the
        -: 2219:// program.
    #####: 2220:const TestProperty& TestResult::GetTestProperty(int i) const {
    #####: 2221:  if (i < 0 || i >= test_property_count())
    %%%%%: 2221-block  0
    %%%%%: 2221-block  1
    %%%%%: 2221-block  2
    %%%%%: 2221-block  3
    %%%%%: 2221-block  4
    #####: 2222:    internal::posix::Abort();
    %%%%%: 2222-block  0
    #####: 2223:  return test_properties_.at(static_cast<size_t>(i));
    %%%%%: 2223-block  0
        -: 2224:}
        -: 2225:
        -: 2226:// Clears the test part results.
    #####: 2227:void TestResult::ClearTestPartResults() {
    #####: 2228:  test_part_results_.clear();
    %%%%%: 2228-block  0
    #####: 2229:}
        -: 2230:
        -: 2231:// Adds a test part result to the list.
    #####: 2232:void TestResult::AddTestPartResult(const TestPartResult& test_part_result) {
    #####: 2233:  test_part_results_.push_back(test_part_result);
    %%%%%: 2233-block  0
    #####: 2234:}
        -: 2235:
        -: 2236:// Adds a test property to the list. If a property with the same key as the
        -: 2237:// supplied property is already represented, the value of this test_property
        -: 2238:// replaces the old value for that key.
    #####: 2239:void TestResult::RecordProperty(const std::string& xml_element,
        -: 2240:                                const TestProperty& test_property) {
    #####: 2241:  if (!ValidateTestProperty(xml_element, test_property)) {
    %%%%%: 2241-block  0
    %%%%%: 2241-block  1
    #####: 2242:    return;
    %%%%%: 2242-block  0
    %%%%%: 2242-block  1
        -: 2243:  }
    #####: 2244:  internal::MutexLock lock(&test_properites_mutex_);
    %%%%%: 2244-block  0
    $$$$$: 2244-block  1
        -: 2245:  const std::vector<TestProperty>::iterator property_with_matching_key =
        -: 2246:      std::find_if(test_properties_.begin(), test_properties_.end(),
    #####: 2247:                   internal::TestPropertyKeyIs(test_property.key()));
    %%%%%: 2247-block  0
    %%%%%: 2247-block  1
    %%%%%: 2247-block  2
    %%%%%: 2247-block  3
    $$$$$: 2247-block  4
    $$$$$: 2247-block  5
    $$$$$: 2247-block  6
    $$$$$: 2247-block  7
    $$$$$: 2247-block  8
    $$$$$: 2247-block  9
    #####: 2248:  if (property_with_matching_key == test_properties_.end()) {
    #####: 2249:    test_properties_.push_back(test_property);
    %%%%%: 2249-block  0
    #####: 2250:    return;
    %%%%%: 2250-block  0
        -: 2251:  }
    #####: 2252:  property_with_matching_key->SetValue(test_property.value());
    %%%%%: 2252-block  0
    %%%%%: 2252-block  1
    %%%%%: 2252-block  2
    $$$$$: 2252-block  3
    $$$$$: 2252-block  4
    $$$$$: 2252-block  5
    $$$$$: 2252-block  6
        -: 2253:}
        -: 2254:
        -: 2255:// The list of reserved attributes used in the <testsuites> element of XML
        -: 2256:// output.
        -: 2257:static const char* const kReservedTestSuitesAttributes[] = {
        -: 2258:  "disabled",
        -: 2259:  "errors",
        -: 2260:  "failures",
        -: 2261:  "name",
        -: 2262:  "random_seed",
        -: 2263:  "tests",
        -: 2264:  "time",
        -: 2265:  "timestamp"
        -: 2266:};
        -: 2267:
        -: 2268:// The list of reserved attributes used in the <testsuite> element of XML
        -: 2269:// output.
        -: 2270:static const char* const kReservedTestSuiteAttributes[] = {
        -: 2271:    "disabled", "errors", "failures",  "name",
        -: 2272:    "tests",    "time",   "timestamp", "skipped"};
        -: 2273:
        -: 2274:// The list of reserved attributes used in the <testcase> element of XML output.
        -: 2275:static const char* const kReservedTestCaseAttributes[] = {
        -: 2276:    "classname",   "name", "status", "time",  "type_param",
        -: 2277:    "value_param", "file", "line"};
        -: 2278:
        -: 2279:// Use a slightly different set for allowed output to ensure existing tests can
        -: 2280:// still RecordProperty("result") or "RecordProperty(timestamp")
        -: 2281:static const char* const kReservedOutputTestCaseAttributes[] = {
        -: 2282:    "classname",   "name", "status", "time",   "type_param",
        -: 2283:    "value_param", "file", "line",   "result", "timestamp"};
        -: 2284:
        -: 2285:template <size_t kSize>
    #####: 2286:std::vector<std::string> ArrayAsVector(const char* const (&array)[kSize]) {
    #####: 2287:  return std::vector<std::string>(array, array + kSize);
        -: 2288:}
------------------
_ZN7testing13ArrayAsVectorILm10EEESt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS7_EERAT__KPKc:
    #####: 2286:std::vector<std::string> ArrayAsVector(const char* const (&array)[kSize]) {
    #####: 2287:  return std::vector<std::string>(array, array + kSize);
    %%%%%: 2287-block  0
    %%%%%: 2287-block  1
    %%%%%: 2287-block  2
    $$$$$: 2287-block  3
        -: 2288:}
------------------
_ZN7testing13ArrayAsVectorILm8EEESt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS7_EERAT__KPKc:
    #####: 2286:std::vector<std::string> ArrayAsVector(const char* const (&array)[kSize]) {
    #####: 2287:  return std::vector<std::string>(array, array + kSize);
    %%%%%: 2287-block  0
    %%%%%: 2287-block  1
    %%%%%: 2287-block  2
    $$$$$: 2287-block  3
        -: 2288:}
------------------
        -: 2289:
    #####: 2290:static std::vector<std::string> GetReservedAttributesForElement(
        -: 2291:    const std::string& xml_element) {
    #####: 2292:  if (xml_element == "testsuites") {
    %%%%%: 2292-block  0
    #####: 2293:    return ArrayAsVector(kReservedTestSuitesAttributes);
    %%%%%: 2293-block  0
    #####: 2294:  } else if (xml_element == "testsuite") {
    %%%%%: 2294-block  0
    #####: 2295:    return ArrayAsVector(kReservedTestSuiteAttributes);
    %%%%%: 2295-block  0
    #####: 2296:  } else if (xml_element == "testcase") {
    %%%%%: 2296-block  0
    #####: 2297:    return ArrayAsVector(kReservedTestCaseAttributes);
    %%%%%: 2297-block  0
        -: 2298:  } else {
    #####: 2299:    GTEST_CHECK_(false) << "Unrecognized xml_element provided: " << xml_element;
    %%%%%: 2299-block  0
    %%%%%: 2299-block  1
    %%%%%: 2299-block  2
    %%%%%: 2299-block  3
    %%%%%: 2299-block  4
    $$$$$: 2299-block  5
        -: 2300:  }
        -: 2301:  // This code is unreachable but some compilers may not realizes that.
    #####: 2302:  return std::vector<std::string>();
    %%%%%: 2302-block  0
        -: 2303:}
        -: 2304:
        -: 2305:// TODO(jdesprez): Merge the two getReserved attributes once skip is improved
    #####: 2306:static std::vector<std::string> GetReservedOutputAttributesForElement(
        -: 2307:    const std::string& xml_element) {
    #####: 2308:  if (xml_element == "testsuites") {
    %%%%%: 2308-block  0
    #####: 2309:    return ArrayAsVector(kReservedTestSuitesAttributes);
    %%%%%: 2309-block  0
    #####: 2310:  } else if (xml_element == "testsuite") {
    %%%%%: 2310-block  0
    #####: 2311:    return ArrayAsVector(kReservedTestSuiteAttributes);
    %%%%%: 2311-block  0
    #####: 2312:  } else if (xml_element == "testcase") {
    %%%%%: 2312-block  0
    #####: 2313:    return ArrayAsVector(kReservedOutputTestCaseAttributes);
    %%%%%: 2313-block  0
        -: 2314:  } else {
    #####: 2315:    GTEST_CHECK_(false) << "Unrecognized xml_element provided: " << xml_element;
    %%%%%: 2315-block  0
    %%%%%: 2315-block  1
    %%%%%: 2315-block  2
    %%%%%: 2315-block  3
    %%%%%: 2315-block  4
    $$$$$: 2315-block  5
        -: 2316:  }
        -: 2317:  // This code is unreachable but some compilers may not realizes that.
    #####: 2318:  return std::vector<std::string>();
    %%%%%: 2318-block  0
        -: 2319:}
        -: 2320:
    #####: 2321:static std::string FormatWordList(const std::vector<std::string>& words) {
    #####: 2322:  Message word_list;
    %%%%%: 2322-block  0
    %%%%%: 2322-block  1
    $$$$$: 2322-block  2
    #####: 2323:  for (size_t i = 0; i < words.size(); ++i) {
    %%%%%: 2323-block  0
    %%%%%: 2323-block  1
    %%%%%: 2323-block  2
    #####: 2324:    if (i > 0 && words.size() > 2) {
    %%%%%: 2324-block  0
    %%%%%: 2324-block  1
    %%%%%: 2324-block  2
    %%%%%: 2324-block  3
    %%%%%: 2324-block  4
    #####: 2325:      word_list << ", ";
    %%%%%: 2325-block  0
        -: 2326:    }
    #####: 2327:    if (i == words.size() - 1) {
    %%%%%: 2327-block  0
    #####: 2328:      word_list << "and ";
    %%%%%: 2328-block  0
        -: 2329:    }
    #####: 2330:    word_list << "'" << words[i] << "'";
    %%%%%: 2330-block  0
    %%%%%: 2330-block  1
    %%%%%: 2330-block  2
        -: 2331:  }
    #####: 2332:  return word_list.GetString();
    %%%%%: 2332-block  0
    %%%%%: 2332-block  1
        -: 2333:}
        -: 2334:
    #####: 2335:static bool ValidateTestPropertyName(
        -: 2336:    const std::string& property_name,
        -: 2337:    const std::vector<std::string>& reserved_names) {
    #####: 2338:  if (std::find(reserved_names.begin(), reserved_names.end(), property_name) !=
    %%%%%: 2338-block  0
    #####: 2339:          reserved_names.end()) {
    %%%%%: 2339-block  0
    $$$$$: 2339-block  1
    #####: 2340:    ADD_FAILURE() << "Reserved key used in RecordProperty(): " << property_name
    %%%%%: 2340-block  0
    %%%%%: 2340-block  1
    %%%%%: 2340-block  2
    %%%%%: 2340-block  3
    $$$$$: 2340-block  4
    $$$$$: 2340-block  5
    $$$$$: 2340-block  6
    #####: 2341:                  << " (" << FormatWordList(reserved_names)
    %%%%%: 2341-block  0
    %%%%%: 2341-block  1
    %%%%%: 2341-block  2
    $$$$$: 2341-block  3
    $$$$$: 2341-block  4
    #####: 2342:                  << " are reserved by " << GTEST_NAME_ << ")";
    %%%%%: 2342-block  0
    %%%%%: 2342-block  1
    %%%%%: 2342-block  2
    %%%%%: 2342-block  3
    #####: 2343:    return false;
        -: 2344:  }
    #####: 2345:  return true;
    %%%%%: 2345-block  0
        -: 2346:}
        -: 2347:
        -: 2348:// Adds a failure if the key is a reserved attribute of the element named
        -: 2349:// xml_element.  Returns true if the property is valid.
    #####: 2350:bool TestResult::ValidateTestProperty(const std::string& xml_element,
        -: 2351:                                      const TestProperty& test_property) {
    #####: 2352:  return ValidateTestPropertyName(test_property.key(),
    %%%%%: 2352-block  0
    %%%%%: 2352-block  1
    $$$$$: 2352-block  2
    $$$$$: 2352-block  3
    $$$$$: 2352-block  4
    $$$$$: 2352-block  5
    #####: 2353:                                  GetReservedAttributesForElement(xml_element));
    %%%%%: 2353-block  0
    %%%%%: 2353-block  1
    %%%%%: 2353-block  2
    $$$$$: 2353-block  3
        -: 2354:}
        -: 2355:
        -: 2356:// Clears the object.
       43: 2357:void TestResult::Clear() {
       43: 2358:  test_part_results_.clear();
       43: 2358-block  0
       43: 2359:  test_properties_.clear();
       43: 2360:  death_test_count_ = 0;
       43: 2361:  elapsed_time_ = 0;
       43: 2362:}
        -: 2363:
        -: 2364:// Returns true off the test part was skipped.
    #####: 2365:static bool TestPartSkipped(const TestPartResult& result) {
    #####: 2366:  return result.skipped();
    %%%%%: 2366-block  0
        -: 2367:}
        -: 2368:
        -: 2369:// Returns true if and only if the test was skipped.
      156: 2370:bool TestResult::Skipped() const {
     156*: 2371:  return !Failed() && CountIf(test_part_results_, TestPartSkipped) > 0;
      156: 2371-block  0
      156: 2371-block  1
    %%%%%: 2371-block  2
      156: 2371-block  3
      156: 2371-block  4
        -: 2372:}
        -: 2373:
        -: 2374:// Returns true if and only if the test failed.
      315: 2375:bool TestResult::Failed() const {
     315*: 2376:  for (int i = 0; i < total_part_count(); ++i) {
      315: 2376-block  0
      315: 2376-block  1
    %%%%%: 2376-block  2
    #####: 2377:    if (GetTestPartResult(i).failed())
    %%%%%: 2377-block  0
    #####: 2378:      return true;
    %%%%%: 2378-block  0
        -: 2379:  }
      315: 2380:  return false;
      315: 2380-block  0
        -: 2381:}
        -: 2382:
        -: 2383:// Returns true if and only if the test part fatally failed.
    #####: 2384:static bool TestPartFatallyFailed(const TestPartResult& result) {
    #####: 2385:  return result.fatally_failed();
    %%%%%: 2385-block  0
        -: 2386:}
        -: 2387:
        -: 2388:// Returns true if and only if the test fatally failed.
       63: 2389:bool TestResult::HasFatalFailure() const {
       63: 2390:  return CountIf(test_part_results_, TestPartFatallyFailed) > 0;
       63: 2390-block  0
        -: 2391:}
        -: 2392:
        -: 2393:// Returns true if and only if the test part non-fatally failed.
    #####: 2394:static bool TestPartNonfatallyFailed(const TestPartResult& result) {
    #####: 2395:  return result.nonfatally_failed();
    %%%%%: 2395-block  0
        -: 2396:}
        -: 2397:
        -: 2398:// Returns true if and only if the test has a non-fatal failure.
    #####: 2399:bool TestResult::HasNonfatalFailure() const {
    #####: 2400:  return CountIf(test_part_results_, TestPartNonfatallyFailed) > 0;
    %%%%%: 2400-block  0
        -: 2401:}
        -: 2402:
        -: 2403:// Gets the number of all test parts.  This is the sum of the number
        -: 2404:// of successful test parts and the number of failed test parts.
      315: 2405:int TestResult::total_part_count() const {
      315: 2406:  return static_cast<int>(test_part_results_.size());
      315: 2406-block  0
        -: 2407:}
        -: 2408:
        -: 2409:// Returns the number of the test properties.
    #####: 2410:int TestResult::test_property_count() const {
    #####: 2411:  return static_cast<int>(test_properties_.size());
    %%%%%: 2411-block  0
        -: 2412:}
        -: 2413:
        -: 2414:// class Test
        -: 2415:
        -: 2416:// Creates a Test object.
        -: 2417:
        -: 2418:// The c'tor saves the states of all flags.
       31: 2419:Test::Test()
       31: 2420:    : gtest_flag_saver_(new GTEST_FLAG_SAVER_) {
       31: 2420-block  0
       31: 2420-block  1
    $$$$$: 2420-block  2
       31: 2421:}
        -: 2422:
        -: 2423:// The d'tor restores the states of all flags.  The actual work is
        -: 2424:// done by the d'tor of the gtest_flag_saver_ field, and thus not
        -: 2425:// visible here.
      31*: 2426:Test::~Test() {
      31*: 2427:}
------------------
_ZN7testing4TestD0Ev:
    #####: 2426:Test::~Test() {
    #####: 2427:}
    %%%%%: 2427-block  0
------------------
_ZN7testing4TestD2Ev:
       31: 2426:Test::~Test() {
       31: 2426-block  0
       31: 2427:}
------------------
        -: 2428:
        -: 2429:// Sets up the test fixture.
        -: 2430://
        -: 2431:// A sub-class may override this.
       31: 2432:void Test::SetUp() {
       31: 2433:}
        -: 2434:
        -: 2435:// Tears down the test fixture.
        -: 2436://
        -: 2437:// A sub-class may override this.
       31: 2438:void Test::TearDown() {
       31: 2439:}
        -: 2440:
        -: 2441:// Allows user supplied key value pairs to be recorded for later output.
    #####: 2442:void Test::RecordProperty(const std::string& key, const std::string& value) {
    #####: 2443:  UnitTest::GetInstance()->RecordProperty(key, value);
    %%%%%: 2443-block  0
    #####: 2444:}
        -: 2445:
        -: 2446:// Allows user supplied key value pairs to be recorded for later output.
    #####: 2447:void Test::RecordProperty(const std::string& key, int value) {
    #####: 2448:  Message value_message;
    %%%%%: 2448-block  0
    $$$$$: 2448-block  1
    #####: 2449:  value_message << value;
    %%%%%: 2449-block  0
    #####: 2450:  RecordProperty(key, value_message.GetString().c_str());
    %%%%%: 2450-block  0
    %%%%%: 2450-block  1
    %%%%%: 2450-block  2
    %%%%%: 2450-block  3
    $$$$$: 2450-block  4
    $$$$$: 2450-block  5
    $$$$$: 2450-block  6
    $$$$$: 2450-block  7
    $$$$$: 2450-block  8
    $$$$$: 2450-block  9
    #####: 2451:}
        -: 2452:
        -: 2453:namespace internal {
        -: 2454:
    #####: 2455:void ReportFailureInUnknownLocation(TestPartResult::Type result_type,
        -: 2456:                                    const std::string& message) {
        -: 2457:  // This function is a friend of UnitTest and as such has access to
        -: 2458:  // AddTestPartResult.
    #####: 2459:  UnitTest::GetInstance()->AddTestPartResult(
    %%%%%: 2459-block  0
    %%%%%: 2459-block  1
    %%%%%: 2459-block  2
    $$$$$: 2459-block  3
    $$$$$: 2459-block  4
    $$$$$: 2459-block  5
        -: 2460:      result_type,
        -: 2461:      nullptr,  // No info about the source file where the exception occurred.
        -: 2462:      -1,       // We have no info on which line caused the exception.
        -: 2463:      message,
        -: 2464:      "");  // No stack trace, either.
    #####: 2465:}
        -: 2466:
        -: 2467:}  // namespace internal
        -: 2468:
        -: 2469:// Google Test requires all tests in the same test suite to use the same test
        -: 2470:// fixture class.  This function checks if the current test has the
        -: 2471:// same fixture class as the first test in the current test suite.  If
        -: 2472:// yes, it returns true; otherwise it generates a Google Test failure and
        -: 2473:// returns false.
       31: 2474:bool Test::HasSameFixtureClass() {
       31: 2475:  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
       31: 2475-block  0
       31: 2476:  const TestSuite* const test_suite = impl->current_test_suite();
       31: 2476-block  0
        -: 2477:
        -: 2478:  // Info about the first test in the current test suite.
       31: 2479:  const TestInfo* const first_test_info = test_suite->test_info_list()[0];
       31: 2480:  const internal::TypeId first_fixture_id = first_test_info->fixture_class_id_;
       31: 2481:  const char* const first_test_name = first_test_info->name();
        -: 2482:
        -: 2483:  // Info about the current test.
       31: 2484:  const TestInfo* const this_test_info = impl->current_test_info();
       31: 2485:  const internal::TypeId this_fixture_id = this_test_info->fixture_class_id_;
       31: 2486:  const char* const this_test_name = this_test_info->name();
        -: 2487:
       31: 2488:  if (this_fixture_id != first_fixture_id) {
        -: 2489:    // Is the first test defined using TEST?
    #####: 2490:    const bool first_is_TEST = first_fixture_id == internal::GetTestTypeId();
    %%%%%: 2490-block  0
        -: 2491:    // Is this test defined using TEST?
    #####: 2492:    const bool this_is_TEST = this_fixture_id == internal::GetTestTypeId();
    %%%%%: 2492-block  0
        -: 2493:
    #####: 2494:    if (first_is_TEST || this_is_TEST) {
    %%%%%: 2494-block  0
    %%%%%: 2494-block  1
        -: 2495:      // Both TEST and TEST_F appear in same test suite, which is incorrect.
        -: 2496:      // Tell the user how to fix this.
        -: 2497:
        -: 2498:      // Gets the name of the TEST and the name of the TEST_F.  Note
        -: 2499:      // that first_is_TEST and this_is_TEST cannot both be true, as
        -: 2500:      // the fixture IDs are different for the two tests.
    #####: 2501:      const char* const TEST_name =
    %%%%%: 2501-block  0
    %%%%%: 2501-block  1
    %%%%%: 2501-block  2
        -: 2502:          first_is_TEST ? first_test_name : this_test_name;
    #####: 2503:      const char* const TEST_F_name =
    %%%%%: 2503-block  0
    %%%%%: 2503-block  1
    %%%%%: 2503-block  2
        -: 2504:          first_is_TEST ? this_test_name : first_test_name;
        -: 2505:
    #####: 2506:      ADD_FAILURE()
    %%%%%: 2506-block  0
    %%%%%: 2506-block  1
    %%%%%: 2506-block  2
    $$$$$: 2506-block  3
    $$$$$: 2506-block  4
    $$$$$: 2506-block  5
    $$$$$: 2506-block  6
    #####: 2507:          << "All tests in the same test suite must use the same test fixture\n"
    %%%%%: 2507-block  0
    #####: 2508:          << "class, so mixing TEST_F and TEST in the same test suite is\n"
    %%%%%: 2508-block  0
    #####: 2509:          << "illegal.  In test suite " << this_test_info->test_suite_name()
    %%%%%: 2509-block  0
    %%%%%: 2509-block  1
    $$$$$: 2509-block  2
    #####: 2510:          << ",\n"
    %%%%%: 2510-block  0
    #####: 2511:          << "test " << TEST_F_name << " is defined using TEST_F but\n"
    %%%%%: 2511-block  0
    %%%%%: 2511-block  1
    %%%%%: 2511-block  2
    #####: 2512:          << "test " << TEST_name << " is defined using TEST.  You probably\n"
    %%%%%: 2512-block  0
    %%%%%: 2512-block  1
    %%%%%: 2512-block  2
    #####: 2513:          << "want to change the TEST to TEST_F or move it to another test\n"
    %%%%%: 2513-block  0
    #####: 2514:          << "case.";
    %%%%%: 2514-block  0
    %%%%%: 2514-block  1
        -: 2515:    } else {
        -: 2516:      // Two fixture classes with the same name appear in two different
        -: 2517:      // namespaces, which is not allowed. Tell the user how to fix this.
    #####: 2518:      ADD_FAILURE()
    %%%%%: 2518-block  0
    %%%%%: 2518-block  1
    %%%%%: 2518-block  2
    $$$$$: 2518-block  3
    $$$$$: 2518-block  4
    $$$$$: 2518-block  5
    $$$$$: 2518-block  6
    #####: 2519:          << "All tests in the same test suite must use the same test fixture\n"
    %%%%%: 2519-block  0
    #####: 2520:          << "class.  However, in test suite "
    %%%%%: 2520-block  0
    #####: 2521:          << this_test_info->test_suite_name() << ",\n"
    %%%%%: 2521-block  0
    %%%%%: 2521-block  1
    $$$$$: 2521-block  2
    #####: 2522:          << "you defined test " << first_test_name << " and test "
    %%%%%: 2522-block  0
    %%%%%: 2522-block  1
    %%%%%: 2522-block  2
    #####: 2523:          << this_test_name << "\n"
    %%%%%: 2523-block  0
    %%%%%: 2523-block  1
    #####: 2524:          << "using two different test fixture classes.  This can happen if\n"
    %%%%%: 2524-block  0
    #####: 2525:          << "the two classes are from different namespaces or translation\n"
    %%%%%: 2525-block  0
    #####: 2526:          << "units and have the same name.  You should probably rename one\n"
    %%%%%: 2526-block  0
    #####: 2527:          << "of the classes to put the tests into different test suites.";
    %%%%%: 2527-block  0
    %%%%%: 2527-block  1
        -: 2528:    }
    #####: 2529:    return false;
    %%%%%: 2529-block  0
        -: 2530:  }
        -: 2531:
       31: 2532:  return true;
       31: 2532-block  0
        -: 2533:}
        -: 2534:
        -: 2535:#if GTEST_HAS_SEH
        -: 2536:
        -: 2537:// Adds an "exception thrown" fatal failure to the current test.  This
        -: 2538:// function returns its result via an output parameter pointer because VC++
        -: 2539:// prohibits creation of objects with destructors on stack in functions
        -: 2540:// using __try (see error C2712).
        -: 2541:static std::string* FormatSehExceptionMessage(DWORD exception_code,
        -: 2542:                                              const char* location) {
        -: 2543:  Message message;
        -: 2544:  message << "SEH exception with code 0x" << std::setbase(16) <<
        -: 2545:    exception_code << std::setbase(10) << " thrown in " << location << ".";
        -: 2546:
        -: 2547:  return new std::string(message.GetString());
        -: 2548:}
        -: 2549:
        -: 2550:#endif  // GTEST_HAS_SEH
        -: 2551:
        -: 2552:namespace internal {
        -: 2553:
        -: 2554:#if GTEST_HAS_EXCEPTIONS
        -: 2555:
        -: 2556:// Adds an "exception thrown" fatal failure to the current test.
    #####: 2557:static std::string FormatCxxExceptionMessage(const char* description,
        -: 2558:                                             const char* location) {
    #####: 2559:  Message message;
    %%%%%: 2559-block  0
    %%%%%: 2559-block  1
    $$$$$: 2559-block  2
    #####: 2560:  if (description != nullptr) {
    %%%%%: 2560-block  0
    #####: 2561:    message << "C++ exception with description \"" << description << "\"";
    %%%%%: 2561-block  0
    %%%%%: 2561-block  1
    %%%%%: 2561-block  2
        -: 2562:  } else {
    #####: 2563:    message << "Unknown C++ exception";
    %%%%%: 2563-block  0
        -: 2564:  }
    #####: 2565:  message << " thrown in " << location << ".";
    %%%%%: 2565-block  0
    %%%%%: 2565-block  1
    %%%%%: 2565-block  2
        -: 2566:
    #####: 2567:  return message.GetString();
    %%%%%: 2567-block  0
    %%%%%: 2567-block  1
        -: 2568:}
        -: 2569:
        -: 2570:static std::string PrintTestPartResultToString(
        -: 2571:    const TestPartResult& test_part_result);
        -: 2572:
    #####: 2573:GoogleTestFailureException::GoogleTestFailureException(
    #####: 2574:    const TestPartResult& failure)
    #####: 2575:    : ::std::runtime_error(PrintTestPartResultToString(failure).c_str()) {}
    %%%%%: 2575-block  0
    %%%%%: 2575-block  1
    $$$$$: 2575-block  2
        -: 2576:
        -: 2577:#endif  // GTEST_HAS_EXCEPTIONS
        -: 2578:
        -: 2579:// We put these helper functions in the internal namespace as IBM's xlC
        -: 2580:// compiler rejects the code if they were declared static.
        -: 2581:
        -: 2582:// Runs the given method and handles SEH exceptions it throws, when
        -: 2583:// SEH is supported; returns the 0-value for type Result in case of an
        -: 2584:// SEH exception.  (Microsoft compilers cannot handle SEH and C++
        -: 2585:// exceptions in the same function.  Therefore, we provide a separate
        -: 2586:// wrapper function for handling SEH exceptions.)
        -: 2587:template <class T, typename Result>
      158: 2588:Result HandleSehExceptionsInMethodIfSupported(
        -: 2589:    T* object, Result (T::*method)(), const char* location) {
        -: 2590:#if GTEST_HAS_SEH
        -: 2591:  __try {
        -: 2592:    return (object->*method)();
        -: 2593:  } __except (internal::UnitTestOptions::GTestShouldProcessSEH(  // NOLINT
        -: 2594:      GetExceptionCode())) {
        -: 2595:    // We create the exception message on the heap because VC++ prohibits
        -: 2596:    // creation of objects with destructors on stack in functions using __try
        -: 2597:    // (see error C2712).
        -: 2598:    std::string* exception_message = FormatSehExceptionMessage(
        -: 2599:        GetExceptionCode(), location);
        -: 2600:    internal::ReportFailureInUnknownLocation(TestPartResult::kFatalFailure,
        -: 2601:                                             *exception_message);
        -: 2602:    delete exception_message;
        -: 2603:    return static_cast<Result>(0);
        -: 2604:  }
        -: 2605:#else
        -: 2606:  (void)location;
     158*: 2607:  return (object->*method)();
        -: 2608:#endif  // GTEST_HAS_SEH
        -: 2609:}
------------------
_ZN7testing8internal38HandleSehExceptionsInMethodIfSupportedINS0_12UnitTestImplEbEET0_PT_MS4_FS3_vEPKc:
        1: 2588:Result HandleSehExceptionsInMethodIfSupported(
        -: 2589:    T* object, Result (T::*method)(), const char* location) {
        -: 2590:#if GTEST_HAS_SEH
        -: 2591:  __try {
        -: 2592:    return (object->*method)();
        -: 2593:  } __except (internal::UnitTestOptions::GTestShouldProcessSEH(  // NOLINT
        -: 2594:      GetExceptionCode())) {
        -: 2595:    // We create the exception message on the heap because VC++ prohibits
        -: 2596:    // creation of objects with destructors on stack in functions using __try
        -: 2597:    // (see error C2712).
        -: 2598:    std::string* exception_message = FormatSehExceptionMessage(
        -: 2599:        GetExceptionCode(), location);
        -: 2600:    internal::ReportFailureInUnknownLocation(TestPartResult::kFatalFailure,
        -: 2601:                                             *exception_message);
        -: 2602:    delete exception_message;
        -: 2603:    return static_cast<Result>(0);
        -: 2604:  }
        -: 2605:#else
        -: 2606:  (void)location;
       1*: 2607:  return (object->*method)();
        1: 2607-block  0
    %%%%%: 2607-block  1
        1: 2607-block  2
        1: 2607-block  3
        -: 2608:#endif  // GTEST_HAS_SEH
        -: 2609:}
------------------
_ZN7testing8internal38HandleSehExceptionsInMethodIfSupportedINS_9TestSuiteEvEET0_PT_MS4_FS3_vEPKc:
        2: 2588:Result HandleSehExceptionsInMethodIfSupported(
        -: 2589:    T* object, Result (T::*method)(), const char* location) {
        -: 2590:#if GTEST_HAS_SEH
        -: 2591:  __try {
        -: 2592:    return (object->*method)();
        -: 2593:  } __except (internal::UnitTestOptions::GTestShouldProcessSEH(  // NOLINT
        -: 2594:      GetExceptionCode())) {
        -: 2595:    // We create the exception message on the heap because VC++ prohibits
        -: 2596:    // creation of objects with destructors on stack in functions using __try
        -: 2597:    // (see error C2712).
        -: 2598:    std::string* exception_message = FormatSehExceptionMessage(
        -: 2599:        GetExceptionCode(), location);
        -: 2600:    internal::ReportFailureInUnknownLocation(TestPartResult::kFatalFailure,
        -: 2601:                                             *exception_message);
        -: 2602:    delete exception_message;
        -: 2603:    return static_cast<Result>(0);
        -: 2604:  }
        -: 2605:#else
        -: 2606:  (void)location;
       2*: 2607:  return (object->*method)();
        2: 2607-block  0
    %%%%%: 2607-block  1
        2: 2607-block  2
        2: 2607-block  3
        -: 2608:#endif  // GTEST_HAS_SEH
        -: 2609:}
------------------
_ZN7testing8internal38HandleSehExceptionsInMethodIfSupportedINS0_15TestFactoryBaseEPNS_4TestEEET0_PT_MS6_FS5_vEPKc:
       31: 2588:Result HandleSehExceptionsInMethodIfSupported(
        -: 2589:    T* object, Result (T::*method)(), const char* location) {
        -: 2590:#if GTEST_HAS_SEH
        -: 2591:  __try {
        -: 2592:    return (object->*method)();
        -: 2593:  } __except (internal::UnitTestOptions::GTestShouldProcessSEH(  // NOLINT
        -: 2594:      GetExceptionCode())) {
        -: 2595:    // We create the exception message on the heap because VC++ prohibits
        -: 2596:    // creation of objects with destructors on stack in functions using __try
        -: 2597:    // (see error C2712).
        -: 2598:    std::string* exception_message = FormatSehExceptionMessage(
        -: 2599:        GetExceptionCode(), location);
        -: 2600:    internal::ReportFailureInUnknownLocation(TestPartResult::kFatalFailure,
        -: 2601:                                             *exception_message);
        -: 2602:    delete exception_message;
        -: 2603:    return static_cast<Result>(0);
        -: 2604:  }
        -: 2605:#else
        -: 2606:  (void)location;
      31*: 2607:  return (object->*method)();
       31: 2607-block  0
       31: 2607-block  1
    %%%%%: 2607-block  2
       31: 2607-block  3
        -: 2608:#endif  // GTEST_HAS_SEH
        -: 2609:}
------------------
_ZN7testing8internal38HandleSehExceptionsInMethodIfSupportedINS_4TestEvEET0_PT_MS4_FS3_vEPKc:
      124: 2588:Result HandleSehExceptionsInMethodIfSupported(
        -: 2589:    T* object, Result (T::*method)(), const char* location) {
        -: 2590:#if GTEST_HAS_SEH
        -: 2591:  __try {
        -: 2592:    return (object->*method)();
        -: 2593:  } __except (internal::UnitTestOptions::GTestShouldProcessSEH(  // NOLINT
        -: 2594:      GetExceptionCode())) {
        -: 2595:    // We create the exception message on the heap because VC++ prohibits
        -: 2596:    // creation of objects with destructors on stack in functions using __try
        -: 2597:    // (see error C2712).
        -: 2598:    std::string* exception_message = FormatSehExceptionMessage(
        -: 2599:        GetExceptionCode(), location);
        -: 2600:    internal::ReportFailureInUnknownLocation(TestPartResult::kFatalFailure,
        -: 2601:                                             *exception_message);
        -: 2602:    delete exception_message;
        -: 2603:    return static_cast<Result>(0);
        -: 2604:  }
        -: 2605:#else
        -: 2606:  (void)location;
      124: 2607:  return (object->*method)();
      124: 2607-block  0
       93: 2607-block  1
       31: 2607-block  2
      124: 2607-block  3
        -: 2608:#endif  // GTEST_HAS_SEH
        -: 2609:}
------------------
        -: 2610:
        -: 2611:// Runs the given method and catches and reports C++ and/or SEH-style
        -: 2612:// exceptions, if they are supported; returns the 0-value for type
        -: 2613:// Result in case of an SEH exception.
        -: 2614:template <class T, typename Result>
      158: 2615:Result HandleExceptionsInMethodIfSupported(
        -: 2616:    T* object, Result (T::*method)(), const char* location) {
        -: 2617:  // NOTE: The user code can affect the way in which Google Test handles
        -: 2618:  // exceptions by setting GTEST_FLAG(catch_exceptions), but only before
        -: 2619:  // RUN_ALL_TESTS() starts. It is technically possible to check the flag
        -: 2620:  // after the exception is caught and either report or re-throw the
        -: 2621:  // exception based on the flag's value:
        -: 2622:  //
        -: 2623:  // try {
        -: 2624:  //   // Perform the test method.
        -: 2625:  // } catch (...) {
        -: 2626:  //   if (GTEST_FLAG(catch_exceptions))
        -: 2627:  //     // Report the exception as failure.
        -: 2628:  //   else
        -: 2629:  //     throw;  // Re-throws the original exception.
        -: 2630:  // }
        -: 2631:  //
        -: 2632:  // However, the purpose of this flag is to allow the program to drop into
        -: 2633:  // the debugger when the exception is thrown. On most platforms, once the
        -: 2634:  // control enters the catch block, the exception origin information is
        -: 2635:  // lost and the debugger will stop the program at the point of the
        -: 2636:  // re-throw in this function -- instead of at the point of the original
        -: 2637:  // throw statement in the code under test.  For this reason, we perform
        -: 2638:  // the check early, sacrificing the ability to affect Google Test's
        -: 2639:  // exception handling in the method where the exception is thrown.
      158: 2640:  if (internal::GetUnitTestImpl()->catch_exceptions()) {
        -: 2641:#if GTEST_HAS_EXCEPTIONS
        -: 2642:    try {
      158: 2643:      return HandleSehExceptionsInMethodIfSupported(object, method, location);
    =====: 2644:    } catch (const AssertionException&) {  // NOLINT
        -: 2645:      // This failure was reported already.
    =====: 2646:    } catch (const internal::GoogleTestFailureException&) {  // NOLINT
        -: 2647:      // This exception type can only be thrown by a failed Google
        -: 2648:      // Test assertion with the intention of letting another testing
        -: 2649:      // framework catch it.  Therefore we just re-throw it.
    =====: 2650:      throw;
    =====: 2651:    } catch (const std::exception& e) {  // NOLINT
    =====: 2652:      internal::ReportFailureInUnknownLocation(
        -: 2653:          TestPartResult::kFatalFailure,
    =====: 2654:          FormatCxxExceptionMessage(e.what(), location));
    =====: 2655:    } catch (...) {  // NOLINT
    =====: 2656:      internal::ReportFailureInUnknownLocation(
        -: 2657:          TestPartResult::kFatalFailure,
        -: 2658:          FormatCxxExceptionMessage(nullptr, location));
        -: 2659:    }
    =====: 2660:    return static_cast<Result>(0);
        -: 2661:#else
        -: 2662:    return HandleSehExceptionsInMethodIfSupported(object, method, location);
        -: 2663:#endif  // GTEST_HAS_EXCEPTIONS
        -: 2664:  } else {
    #####: 2665:    return (object->*method)();
        -: 2666:  }
        -: 2667:}
------------------
_ZN7testing8internal35HandleExceptionsInMethodIfSupportedINS0_12UnitTestImplEbEET0_PT_MS4_FS3_vEPKc:
        1: 2615:Result HandleExceptionsInMethodIfSupported(
        -: 2616:    T* object, Result (T::*method)(), const char* location) {
        -: 2617:  // NOTE: The user code can affect the way in which Google Test handles
        -: 2618:  // exceptions by setting GTEST_FLAG(catch_exceptions), but only before
        -: 2619:  // RUN_ALL_TESTS() starts. It is technically possible to check the flag
        -: 2620:  // after the exception is caught and either report or re-throw the
        -: 2621:  // exception based on the flag's value:
        -: 2622:  //
        -: 2623:  // try {
        -: 2624:  //   // Perform the test method.
        -: 2625:  // } catch (...) {
        -: 2626:  //   if (GTEST_FLAG(catch_exceptions))
        -: 2627:  //     // Report the exception as failure.
        -: 2628:  //   else
        -: 2629:  //     throw;  // Re-throws the original exception.
        -: 2630:  // }
        -: 2631:  //
        -: 2632:  // However, the purpose of this flag is to allow the program to drop into
        -: 2633:  // the debugger when the exception is thrown. On most platforms, once the
        -: 2634:  // control enters the catch block, the exception origin information is
        -: 2635:  // lost and the debugger will stop the program at the point of the
        -: 2636:  // re-throw in this function -- instead of at the point of the original
        -: 2637:  // throw statement in the code under test.  For this reason, we perform
        -: 2638:  // the check early, sacrificing the ability to affect Google Test's
        -: 2639:  // exception handling in the method where the exception is thrown.
        1: 2640:  if (internal::GetUnitTestImpl()->catch_exceptions()) {
        1: 2640-block  0
        -: 2641:#if GTEST_HAS_EXCEPTIONS
        -: 2642:    try {
        1: 2643:      return HandleSehExceptionsInMethodIfSupported(object, method, location);
        1: 2643-block  0
        1: 2643-block  1
    =====: 2644:    } catch (const AssertionException&) {  // NOLINT
    $$$$$: 2644-block  0
        -: 2645:      // This failure was reported already.
    =====: 2646:    } catch (const internal::GoogleTestFailureException&) {  // NOLINT
    $$$$$: 2646-block  0
    $$$$$: 2646-block  1
        -: 2647:      // This exception type can only be thrown by a failed Google
        -: 2648:      // Test assertion with the intention of letting another testing
        -: 2649:      // framework catch it.  Therefore we just re-throw it.
    =====: 2650:      throw;
    =====: 2651:    } catch (const std::exception& e) {  // NOLINT
    $$$$$: 2651-block  0
    $$$$$: 2651-block  1
    =====: 2652:      internal::ReportFailureInUnknownLocation(
    $$$$$: 2652-block  0
    $$$$$: 2652-block  1
    $$$$$: 2652-block  2
    $$$$$: 2652-block  3
        -: 2653:          TestPartResult::kFatalFailure,
    =====: 2654:          FormatCxxExceptionMessage(e.what(), location));
    =====: 2655:    } catch (...) {  // NOLINT
    $$$$$: 2655-block  0
    $$$$$: 2655-block  1
    =====: 2656:      internal::ReportFailureInUnknownLocation(
    $$$$$: 2656-block  0
    $$$$$: 2656-block  1
    $$$$$: 2656-block  2
    $$$$$: 2656-block  3
        -: 2657:          TestPartResult::kFatalFailure,
        -: 2658:          FormatCxxExceptionMessage(nullptr, location));
        -: 2659:    }
    =====: 2660:    return static_cast<Result>(0);
    $$$$$: 2660-block  0
        -: 2661:#else
        -: 2662:    return HandleSehExceptionsInMethodIfSupported(object, method, location);
        -: 2663:#endif  // GTEST_HAS_EXCEPTIONS
        -: 2664:  } else {
    #####: 2665:    return (object->*method)();
    %%%%%: 2665-block  0
    %%%%%: 2665-block  1
    %%%%%: 2665-block  2
    %%%%%: 2665-block  3
        -: 2666:  }
        -: 2667:}
------------------
_ZN7testing8internal35HandleExceptionsInMethodIfSupportedINS_9TestSuiteEvEET0_PT_MS4_FS3_vEPKc:
        2: 2615:Result HandleExceptionsInMethodIfSupported(
        -: 2616:    T* object, Result (T::*method)(), const char* location) {
        -: 2617:  // NOTE: The user code can affect the way in which Google Test handles
        -: 2618:  // exceptions by setting GTEST_FLAG(catch_exceptions), but only before
        -: 2619:  // RUN_ALL_TESTS() starts. It is technically possible to check the flag
        -: 2620:  // after the exception is caught and either report or re-throw the
        -: 2621:  // exception based on the flag's value:
        -: 2622:  //
        -: 2623:  // try {
        -: 2624:  //   // Perform the test method.
        -: 2625:  // } catch (...) {
        -: 2626:  //   if (GTEST_FLAG(catch_exceptions))
        -: 2627:  //     // Report the exception as failure.
        -: 2628:  //   else
        -: 2629:  //     throw;  // Re-throws the original exception.
        -: 2630:  // }
        -: 2631:  //
        -: 2632:  // However, the purpose of this flag is to allow the program to drop into
        -: 2633:  // the debugger when the exception is thrown. On most platforms, once the
        -: 2634:  // control enters the catch block, the exception origin information is
        -: 2635:  // lost and the debugger will stop the program at the point of the
        -: 2636:  // re-throw in this function -- instead of at the point of the original
        -: 2637:  // throw statement in the code under test.  For this reason, we perform
        -: 2638:  // the check early, sacrificing the ability to affect Google Test's
        -: 2639:  // exception handling in the method where the exception is thrown.
        2: 2640:  if (internal::GetUnitTestImpl()->catch_exceptions()) {
        2: 2640-block  0
        -: 2641:#if GTEST_HAS_EXCEPTIONS
        -: 2642:    try {
        2: 2643:      return HandleSehExceptionsInMethodIfSupported(object, method, location);
        2: 2643-block  0
        2: 2643-block  1
    =====: 2644:    } catch (const AssertionException&) {  // NOLINT
    $$$$$: 2644-block  0
        -: 2645:      // This failure was reported already.
    =====: 2646:    } catch (const internal::GoogleTestFailureException&) {  // NOLINT
    $$$$$: 2646-block  0
    $$$$$: 2646-block  1
        -: 2647:      // This exception type can only be thrown by a failed Google
        -: 2648:      // Test assertion with the intention of letting another testing
        -: 2649:      // framework catch it.  Therefore we just re-throw it.
    =====: 2650:      throw;
    =====: 2651:    } catch (const std::exception& e) {  // NOLINT
    $$$$$: 2651-block  0
    $$$$$: 2651-block  1
    =====: 2652:      internal::ReportFailureInUnknownLocation(
    $$$$$: 2652-block  0
    $$$$$: 2652-block  1
    $$$$$: 2652-block  2
    $$$$$: 2652-block  3
        -: 2653:          TestPartResult::kFatalFailure,
    =====: 2654:          FormatCxxExceptionMessage(e.what(), location));
    =====: 2655:    } catch (...) {  // NOLINT
    $$$$$: 2655-block  0
    $$$$$: 2655-block  1
    =====: 2656:      internal::ReportFailureInUnknownLocation(
    $$$$$: 2656-block  0
    $$$$$: 2656-block  1
    $$$$$: 2656-block  2
    $$$$$: 2656-block  3
        -: 2657:          TestPartResult::kFatalFailure,
        -: 2658:          FormatCxxExceptionMessage(nullptr, location));
        -: 2659:    }
    =====: 2660:    return static_cast<Result>(0);
    $$$$$: 2660-block  0
        -: 2661:#else
        -: 2662:    return HandleSehExceptionsInMethodIfSupported(object, method, location);
        -: 2663:#endif  // GTEST_HAS_EXCEPTIONS
        -: 2664:  } else {
    #####: 2665:    return (object->*method)();
    %%%%%: 2665-block  0
    %%%%%: 2665-block  1
    %%%%%: 2665-block  2
    %%%%%: 2665-block  3
        -: 2666:  }
        -: 2667:}
------------------
_ZN7testing8internal35HandleExceptionsInMethodIfSupportedINS0_15TestFactoryBaseEPNS_4TestEEET0_PT_MS6_FS5_vEPKc:
       31: 2615:Result HandleExceptionsInMethodIfSupported(
        -: 2616:    T* object, Result (T::*method)(), const char* location) {
        -: 2617:  // NOTE: The user code can affect the way in which Google Test handles
        -: 2618:  // exceptions by setting GTEST_FLAG(catch_exceptions), but only before
        -: 2619:  // RUN_ALL_TESTS() starts. It is technically possible to check the flag
        -: 2620:  // after the exception is caught and either report or re-throw the
        -: 2621:  // exception based on the flag's value:
        -: 2622:  //
        -: 2623:  // try {
        -: 2624:  //   // Perform the test method.
        -: 2625:  // } catch (...) {
        -: 2626:  //   if (GTEST_FLAG(catch_exceptions))
        -: 2627:  //     // Report the exception as failure.
        -: 2628:  //   else
        -: 2629:  //     throw;  // Re-throws the original exception.
        -: 2630:  // }
        -: 2631:  //
        -: 2632:  // However, the purpose of this flag is to allow the program to drop into
        -: 2633:  // the debugger when the exception is thrown. On most platforms, once the
        -: 2634:  // control enters the catch block, the exception origin information is
        -: 2635:  // lost and the debugger will stop the program at the point of the
        -: 2636:  // re-throw in this function -- instead of at the point of the original
        -: 2637:  // throw statement in the code under test.  For this reason, we perform
        -: 2638:  // the check early, sacrificing the ability to affect Google Test's
        -: 2639:  // exception handling in the method where the exception is thrown.
       31: 2640:  if (internal::GetUnitTestImpl()->catch_exceptions()) {
       31: 2640-block  0
        -: 2641:#if GTEST_HAS_EXCEPTIONS
        -: 2642:    try {
       31: 2643:      return HandleSehExceptionsInMethodIfSupported(object, method, location);
       31: 2643-block  0
       31: 2643-block  1
    =====: 2644:    } catch (const AssertionException&) {  // NOLINT
    $$$$$: 2644-block  0
        -: 2645:      // This failure was reported already.
    =====: 2646:    } catch (const internal::GoogleTestFailureException&) {  // NOLINT
    $$$$$: 2646-block  0
    $$$$$: 2646-block  1
        -: 2647:      // This exception type can only be thrown by a failed Google
        -: 2648:      // Test assertion with the intention of letting another testing
        -: 2649:      // framework catch it.  Therefore we just re-throw it.
    =====: 2650:      throw;
    =====: 2651:    } catch (const std::exception& e) {  // NOLINT
    $$$$$: 2651-block  0
    $$$$$: 2651-block  1
    =====: 2652:      internal::ReportFailureInUnknownLocation(
    $$$$$: 2652-block  0
    $$$$$: 2652-block  1
    $$$$$: 2652-block  2
    $$$$$: 2652-block  3
        -: 2653:          TestPartResult::kFatalFailure,
    =====: 2654:          FormatCxxExceptionMessage(e.what(), location));
    =====: 2655:    } catch (...) {  // NOLINT
    $$$$$: 2655-block  0
    $$$$$: 2655-block  1
    =====: 2656:      internal::ReportFailureInUnknownLocation(
    $$$$$: 2656-block  0
    $$$$$: 2656-block  1
    $$$$$: 2656-block  2
    $$$$$: 2656-block  3
        -: 2657:          TestPartResult::kFatalFailure,
        -: 2658:          FormatCxxExceptionMessage(nullptr, location));
        -: 2659:    }
    =====: 2660:    return static_cast<Result>(0);
    $$$$$: 2660-block  0
        -: 2661:#else
        -: 2662:    return HandleSehExceptionsInMethodIfSupported(object, method, location);
        -: 2663:#endif  // GTEST_HAS_EXCEPTIONS
        -: 2664:  } else {
    #####: 2665:    return (object->*method)();
    %%%%%: 2665-block  0
    %%%%%: 2665-block  1
    %%%%%: 2665-block  2
    %%%%%: 2665-block  3
        -: 2666:  }
        -: 2667:}
------------------
_ZN7testing8internal35HandleExceptionsInMethodIfSupportedINS_4TestEvEET0_PT_MS4_FS3_vEPKc:
      124: 2615:Result HandleExceptionsInMethodIfSupported(
        -: 2616:    T* object, Result (T::*method)(), const char* location) {
        -: 2617:  // NOTE: The user code can affect the way in which Google Test handles
        -: 2618:  // exceptions by setting GTEST_FLAG(catch_exceptions), but only before
        -: 2619:  // RUN_ALL_TESTS() starts. It is technically possible to check the flag
        -: 2620:  // after the exception is caught and either report or re-throw the
        -: 2621:  // exception based on the flag's value:
        -: 2622:  //
        -: 2623:  // try {
        -: 2624:  //   // Perform the test method.
        -: 2625:  // } catch (...) {
        -: 2626:  //   if (GTEST_FLAG(catch_exceptions))
        -: 2627:  //     // Report the exception as failure.
        -: 2628:  //   else
        -: 2629:  //     throw;  // Re-throws the original exception.
        -: 2630:  // }
        -: 2631:  //
        -: 2632:  // However, the purpose of this flag is to allow the program to drop into
        -: 2633:  // the debugger when the exception is thrown. On most platforms, once the
        -: 2634:  // control enters the catch block, the exception origin information is
        -: 2635:  // lost and the debugger will stop the program at the point of the
        -: 2636:  // re-throw in this function -- instead of at the point of the original
        -: 2637:  // throw statement in the code under test.  For this reason, we perform
        -: 2638:  // the check early, sacrificing the ability to affect Google Test's
        -: 2639:  // exception handling in the method where the exception is thrown.
      124: 2640:  if (internal::GetUnitTestImpl()->catch_exceptions()) {
      124: 2640-block  0
        -: 2641:#if GTEST_HAS_EXCEPTIONS
        -: 2642:    try {
      124: 2643:      return HandleSehExceptionsInMethodIfSupported(object, method, location);
      124: 2643-block  0
      124: 2643-block  1
    =====: 2644:    } catch (const AssertionException&) {  // NOLINT
    $$$$$: 2644-block  0
        -: 2645:      // This failure was reported already.
    =====: 2646:    } catch (const internal::GoogleTestFailureException&) {  // NOLINT
    $$$$$: 2646-block  0
    $$$$$: 2646-block  1
        -: 2647:      // This exception type can only be thrown by a failed Google
        -: 2648:      // Test assertion with the intention of letting another testing
        -: 2649:      // framework catch it.  Therefore we just re-throw it.
    =====: 2650:      throw;
    =====: 2651:    } catch (const std::exception& e) {  // NOLINT
    $$$$$: 2651-block  0
    $$$$$: 2651-block  1
    =====: 2652:      internal::ReportFailureInUnknownLocation(
    $$$$$: 2652-block  0
    $$$$$: 2652-block  1
    $$$$$: 2652-block  2
    $$$$$: 2652-block  3
        -: 2653:          TestPartResult::kFatalFailure,
    =====: 2654:          FormatCxxExceptionMessage(e.what(), location));
    =====: 2655:    } catch (...) {  // NOLINT
    $$$$$: 2655-block  0
    $$$$$: 2655-block  1
    =====: 2656:      internal::ReportFailureInUnknownLocation(
    $$$$$: 2656-block  0
    $$$$$: 2656-block  1
    $$$$$: 2656-block  2
    $$$$$: 2656-block  3
        -: 2657:          TestPartResult::kFatalFailure,
        -: 2658:          FormatCxxExceptionMessage(nullptr, location));
        -: 2659:    }
    =====: 2660:    return static_cast<Result>(0);
    $$$$$: 2660-block  0
        -: 2661:#else
        -: 2662:    return HandleSehExceptionsInMethodIfSupported(object, method, location);
        -: 2663:#endif  // GTEST_HAS_EXCEPTIONS
        -: 2664:  } else {
    #####: 2665:    return (object->*method)();
    %%%%%: 2665-block  0
    %%%%%: 2665-block  1
    %%%%%: 2665-block  2
    %%%%%: 2665-block  3
        -: 2666:  }
        -: 2667:}
------------------
        -: 2668:
        -: 2669:}  // namespace internal
        -: 2670:
        -: 2671:// Runs the test and updates the test result.
       31: 2672:void Test::Run() {
      31*: 2673:  if (!HasSameFixtureClass()) return;
       31: 2673-block  0
    %%%%%: 2673-block  1
        -: 2674:
       31: 2675:  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
       31: 2675-block  0
       31: 2676:  impl->os_stack_trace_getter()->UponLeavingGTest();
       31: 2677:  internal::HandleExceptionsInMethodIfSupported(this, &Test::SetUp, "SetUp()");
        -: 2678:  // We will run the test only if SetUp() was successful and didn't call
        -: 2679:  // GTEST_SKIP().
      31*: 2680:  if (!HasFatalFailure() && !IsSkipped()) {
       31: 2680-block  0
       31: 2680-block  1
    %%%%%: 2680-block  2
       31: 2680-block  3
       31: 2681:    impl->os_stack_trace_getter()->UponLeavingGTest();
       31: 2681-block  0
       31: 2682:    internal::HandleExceptionsInMethodIfSupported(
        -: 2683:        this, &Test::TestBody, "the test body");
        -: 2684:  }
        -: 2685:
        -: 2686:  // However, we want to clean up as much as possible.  Hence we will
        -: 2687:  // always call TearDown(), even if SetUp() or the test body has
        -: 2688:  // failed.
       31: 2689:  impl->os_stack_trace_getter()->UponLeavingGTest();
       31: 2689-block  0
       31: 2690:  internal::HandleExceptionsInMethodIfSupported(
        -: 2691:      this, &Test::TearDown, "TearDown()");
        -: 2692:}
        -: 2693:
        -: 2694:// Returns true if and only if the current test has a fatal failure.
       63: 2695:bool Test::HasFatalFailure() {
       63: 2696:  return internal::GetUnitTestImpl()->current_test_result()->HasFatalFailure();
       63: 2696-block  0
        -: 2697:}
        -: 2698:
        -: 2699:// Returns true if and only if the current test has a non-fatal failure.
    #####: 2700:bool Test::HasNonfatalFailure() {
        -: 2701:  return internal::GetUnitTestImpl()->current_test_result()->
    #####: 2702:      HasNonfatalFailure();
    %%%%%: 2702-block  0
        -: 2703:}
        -: 2704:
        -: 2705:// Returns true if and only if the current test was skipped.
       63: 2706:bool Test::IsSkipped() {
       63: 2707:  return internal::GetUnitTestImpl()->current_test_result()->Skipped();
       63: 2707-block  0
        -: 2708:}
        -: 2709:
        -: 2710:// class TestInfo
        -: 2711:
        -: 2712:// Constructs a TestInfo object. It assumes ownership of the test factory
        -: 2713:// object.
       41: 2714:TestInfo::TestInfo(const std::string& a_test_suite_name,
        -: 2715:                   const std::string& a_name, const char* a_type_param,
        -: 2716:                   const char* a_value_param,
        -: 2717:                   internal::CodeLocation a_code_location,
        -: 2718:                   internal::TypeId fixture_class_id,
       41: 2719:                   internal::TestFactoryBase* factory)
        -: 2720:    : test_suite_name_(a_test_suite_name),
        -: 2721:      name_(a_name),
    #####: 2722:      type_param_(a_type_param ? new std::string(a_type_param) : nullptr),
    %%%%%: 2722-block  0
    $$$$$: 2722-block  1
    #####: 2723:      value_param_(a_value_param ? new std::string(a_value_param) : nullptr),
    %%%%%: 2723-block  0
    $$$$$: 2723-block  1
        -: 2724:      location_(a_code_location),
        -: 2725:      fixture_class_id_(fixture_class_id),
        -: 2726:      should_run_(false),
        -: 2727:      is_disabled_(false),
        -: 2728:      matches_filter_(false),
        -: 2729:      is_in_another_shard_(false),
        -: 2730:      factory_(factory),
      41*: 2731:      result_() {}
       41: 2731-block  0
       41: 2731-block  1
    %%%%%: 2731-block  2
    %%%%%: 2731-block  3
       41: 2731-block  4
       41: 2731-block  5
    %%%%%: 2731-block  6
       41: 2731-block  7
    %%%%%: 2731-block  8
    %%%%%: 2731-block  9
       41: 2731-block 10
       41: 2731-block 11
    %%%%%: 2731-block 12
       41: 2731-block 13
       41: 2731-block 14
       41: 2731-block 15
    $$$$$: 2731-block 16
    $$$$$: 2731-block 17
    $$$$$: 2731-block 18
    $$$$$: 2731-block 19
    $$$$$: 2731-block 20
    $$$$$: 2731-block 21
    $$$$$: 2731-block 22
    $$$$$: 2731-block 23
    $$$$$: 2731-block 24
    $$$$$: 2731-block 25
    $$$$$: 2731-block 26
        -: 2732:
        -: 2733:// Destructs a TestInfo object.
       41: 2734:TestInfo::~TestInfo() { delete factory_; }
       41: 2734-block  0
       41: 2734-block  1
       41: 2734-block  2
        -: 2735:
        -: 2736:namespace internal {
        -: 2737:
        -: 2738:// Creates a new TestInfo object and registers it with Google Test;
        -: 2739:// returns the created object.
        -: 2740://
        -: 2741:// Arguments:
        -: 2742://
        -: 2743://   test_suite_name:  name of the test suite
        -: 2744://   name:             name of the test
        -: 2745://   type_param:       the name of the test's type parameter, or NULL if
        -: 2746://                     this is not a typed or a type-parameterized test.
        -: 2747://   value_param:      text representation of the test's value parameter,
        -: 2748://                     or NULL if this is not a value-parameterized test.
        -: 2749://   code_location:    code location where the test is defined
        -: 2750://   fixture_class_id: ID of the test fixture class
        -: 2751://   set_up_tc:        pointer to the function that sets up the test suite
        -: 2752://   tear_down_tc:     pointer to the function that tears down the test suite
        -: 2753://   factory:          pointer to the factory that creates a test object.
        -: 2754://                     The newly created TestInfo instance will assume
        -: 2755://                     ownership of the factory object.
       41: 2756:TestInfo* MakeAndRegisterTestInfo(
        -: 2757:    const char* test_suite_name, const char* name, const char* type_param,
        -: 2758:    const char* value_param, CodeLocation code_location,
        -: 2759:    TypeId fixture_class_id, SetUpTestSuiteFunc set_up_tc,
        -: 2760:    TearDownTestSuiteFunc tear_down_tc, TestFactoryBase* factory) {
        -: 2761:  TestInfo* const test_info =
        -: 2762:      new TestInfo(test_suite_name, name, type_param, value_param,
       41: 2763:                   code_location, fixture_class_id, factory);
       41: 2763-block  0
       41: 2763-block  1
       41: 2763-block  2
       41: 2763-block  3
       41: 2763-block  4
       41: 2763-block  5
    $$$$$: 2763-block  6
    $$$$$: 2763-block  7
    $$$$$: 2763-block  8
    $$$$$: 2763-block  9
    $$$$$: 2763-block 10
    $$$$$: 2763-block 11
    $$$$$: 2763-block 12
    $$$$$: 2763-block 13
    $$$$$: 2763-block 14
    $$$$$: 2763-block 15
       41: 2764:  GetUnitTestImpl()->AddTestInfo(set_up_tc, tear_down_tc, test_info);
       41: 2765:  return test_info;
       41: 2765-block  0
        -: 2766:}
        -: 2767:
    #####: 2768:void ReportInvalidTestSuiteType(const char* test_suite_name,
        -: 2769:                                CodeLocation code_location) {
    #####: 2770:  Message errors;
    %%%%%: 2770-block  0
    $$$$$: 2770-block  1
        -: 2771:  errors
    #####: 2772:      << "Attempted redefinition of test suite " << test_suite_name << ".\n"
    %%%%%: 2772-block  0
    %%%%%: 2772-block  1
    %%%%%: 2772-block  2
    #####: 2773:      << "All tests in the same test suite must use the same test fixture\n"
    %%%%%: 2773-block  0
    #####: 2774:      << "class.  However, in test suite " << test_suite_name << ", you tried\n"
    %%%%%: 2774-block  0
    %%%%%: 2774-block  1
    %%%%%: 2774-block  2
    #####: 2775:      << "to define a test using a fixture class different from the one\n"
    %%%%%: 2775-block  0
    #####: 2776:      << "used earlier. This can happen if the two fixture classes are\n"
    %%%%%: 2776-block  0
    #####: 2777:      << "from different namespaces and have the same name. You should\n"
    %%%%%: 2777-block  0
    #####: 2778:      << "probably rename one of the classes to put the tests into different\n"
    %%%%%: 2778-block  0
    #####: 2779:      << "test suites.";
    %%%%%: 2779-block  0
        -: 2780:
    #####: 2781:  GTEST_LOG_(ERROR) << FormatFileLocation(code_location.file.c_str(),
    %%%%%: 2781-block  0
    %%%%%: 2781-block  1
    $$$$$: 2781-block  2
    $$$$$: 2781-block  3
    $$$$$: 2781-block  4
    $$$$$: 2781-block  5
        -: 2782:                                          code_location.line)
    #####: 2783:                    << " " << errors.GetString();
    %%%%%: 2783-block  0
    %%%%%: 2783-block  1
    %%%%%: 2783-block  2
    %%%%%: 2783-block  3
    %%%%%: 2783-block  4
    $$$$$: 2783-block  5
    $$$$$: 2783-block  6
    #####: 2784:}
        -: 2785:}  // namespace internal
        -: 2786:
        -: 2787:namespace {
        -: 2788:
        -: 2789:// A predicate that checks the test name of a TestInfo against a known
        -: 2790:// value.
        -: 2791://
        -: 2792:// This is used for implementation of the TestSuite class only.  We put
        -: 2793:// it in the anonymous namespace to prevent polluting the outer
        -: 2794:// namespace.
        -: 2795://
        -: 2796:// TestNameIs is copyable.
        -: 2797:class TestNameIs {
        -: 2798: public:
        -: 2799:  // Constructor.
        -: 2800:  //
        -: 2801:  // TestNameIs has NO default constructor.
        -: 2802:  explicit TestNameIs(const char* name)
        -: 2803:      : name_(name) {}
        -: 2804:
        -: 2805:  // Returns true if and only if the test name of test_info matches name_.
        -: 2806:  bool operator()(const TestInfo * test_info) const {
        -: 2807:    return test_info && test_info->name() == name_;
        -: 2808:  }
        -: 2809:
        -: 2810: private:
        -: 2811:  std::string name_;
        -: 2812:};
        -: 2813:
        -: 2814:}  // namespace
        -: 2815:
        -: 2816:namespace internal {
        -: 2817:
        -: 2818:// This method expands all parameterized tests registered with macros TEST_P
        -: 2819:// and INSTANTIATE_TEST_SUITE_P into regular tests and registers those.
        -: 2820:// This will be done just once during the program runtime.
        1: 2821:void UnitTestImpl::RegisterParameterizedTests() {
        1: 2822:  if (!parameterized_tests_registered_) {
        1: 2822-block  0
        1: 2823:    parameterized_test_registry_.RegisterTests();
        1: 2823-block  0
        1: 2824:    type_parameterized_test_registry_.CheckForInstantiations();
        1: 2825:    parameterized_tests_registered_ = true;
        -: 2826:  }
        1: 2827:}
        -: 2828:
        -: 2829:}  // namespace internal
        -: 2830:
        -: 2831:// Creates the test object, runs it, records its result, and then
        -: 2832:// deletes it.
       31: 2833:void TestInfo::Run() {
      31*: 2834:  if (!should_run_) return;
       31: 2834-block  0
    %%%%%: 2834-block  1
        -: 2835:
        -: 2836:  // Tells UnitTest where to store test result.
       31: 2837:  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
       31: 2837-block  0
       31: 2838:  impl->set_current_test_info(this);
       31: 2838-block  0
        -: 2839:
       31: 2840:  TestEventListener* repeater = UnitTest::GetInstance()->listeners().repeater();
       31: 2840-block  0
        -: 2841:
        -: 2842:  // Notifies the unit test event listeners that a test is about to start.
       31: 2843:  repeater->OnTestStart(*this);
        -: 2844:
       31: 2845:  result_.set_start_timestamp(internal::GetTimeInMillis());
       31: 2845-block  0
       31: 2845-block  1
       31: 2846:  internal::Timer timer;
        -: 2847:
       31: 2848:  impl->os_stack_trace_getter()->UponLeavingGTest();
       31: 2848-block  0
        -: 2849:
        -: 2850:  // Creates the test object.
       62: 2851:  Test* const test = internal::HandleExceptionsInMethodIfSupported(
       31: 2852:      factory_, &internal::TestFactoryBase::CreateTest,
       31: 2852-block  0
        -: 2853:      "the test fixture's constructor");
        -: 2854:
        -: 2855:  // Runs the test if the constructor didn't generate a fatal failure or invoke
        -: 2856:  // GTEST_SKIP().
        -: 2857:  // Note that the object will not be null
      31*: 2858:  if (!Test::HasFatalFailure() && !Test::IsSkipped()) {
       31: 2858-block  0
       31: 2858-block  1
       31: 2858-block  2
       31: 2858-block  3
       31: 2858-block  4
    %%%%%: 2858-block  5
       31: 2858-block  6
        -: 2859:    // This doesn't throw as all user code that can throw are wrapped into
        -: 2860:    // exception handling code.
       31: 2861:    test->Run();
       31: 2861-block  0
        -: 2862:  }
        -: 2863:
       31: 2864:  if (test != nullptr) {
       31: 2864-block  0
        -: 2865:    // Deletes the test object.
       31: 2866:    impl->os_stack_trace_getter()->UponLeavingGTest();
       31: 2866-block  0
       31: 2866-block  1
       31: 2867:    internal::HandleExceptionsInMethodIfSupported(
       31: 2867-block  0
        -: 2868:        test, &Test::DeleteSelf_, "the test fixture's destructor");
        -: 2869:  }
        -: 2870:
       31: 2871:  result_.set_elapsed_time(timer.Elapsed());
       31: 2871-block  0
       31: 2871-block  1
        -: 2872:
        -: 2873:  // Notifies the unit test event listener that a test has just finished.
       31: 2874:  repeater->OnTestEnd(*this);
        -: 2875:
        -: 2876:  // Tells UnitTest to stop associating assertion results to this
        -: 2877:  // test.
       31: 2878:  impl->set_current_test_info(nullptr);
       31: 2878-block  0
        -: 2879:}
        -: 2880:
        -: 2881:// Skip and records a skipped test result for this object.
    #####: 2882:void TestInfo::Skip() {
    #####: 2883:  if (!should_run_) return;
    %%%%%: 2883-block  0
    %%%%%: 2883-block  1
        -: 2884:
    #####: 2885:  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
    %%%%%: 2885-block  0
    #####: 2886:  impl->set_current_test_info(this);
    %%%%%: 2886-block  0
        -: 2887:
    #####: 2888:  TestEventListener* repeater = UnitTest::GetInstance()->listeners().repeater();
    %%%%%: 2888-block  0
        -: 2889:
        -: 2890:  // Notifies the unit test event listeners that a test is about to start.
    #####: 2891:  repeater->OnTestStart(*this);
        -: 2892:
        -: 2893:  const TestPartResult test_part_result =
    #####: 2894:      TestPartResult(TestPartResult::kSkip, this->file(), this->line(), "");
    %%%%%: 2894-block  0
    $$$$$: 2894-block  1
    #####: 2895:  impl->GetTestPartResultReporterForCurrentThread()->ReportTestPartResult(
    %%%%%: 2895-block  0
    #####: 2896:      test_part_result);
    %%%%%: 2896-block  0
        -: 2897:
        -: 2898:  // Notifies the unit test event listener that a test has just finished.
    #####: 2899:  repeater->OnTestEnd(*this);
    %%%%%: 2899-block  0
    #####: 2900:  impl->set_current_test_info(nullptr);
    %%%%%: 2900-block  0
        -: 2901:}
        -: 2902:
        -: 2903:// class TestSuite
        -: 2904:
        -: 2905:// Gets the number of successful tests in this test suite.
        2: 2906:int TestSuite::successful_test_count() const {
        2: 2907:  return CountIf(test_info_list_, TestPassed);
        2: 2907-block  0
        -: 2908:}
        -: 2909:
        -: 2910:// Gets the number of successful tests in this test suite.
        2: 2911:int TestSuite::skipped_test_count() const {
        2: 2912:  return CountIf(test_info_list_, TestSkipped);
        2: 2912-block  0
        -: 2913:}
        -: 2914:
        -: 2915:// Gets the number of failed tests in this test suite.
        2: 2916:int TestSuite::failed_test_count() const {
        2: 2917:  return CountIf(test_info_list_, TestFailed);
        2: 2917-block  0
        -: 2918:}
        -: 2919:
        -: 2920:// Gets the number of disabled tests that will be reported in the XML report.
        2: 2921:int TestSuite::reportable_disabled_test_count() const {
        2: 2922:  return CountIf(test_info_list_, TestReportableDisabled);
        2: 2922-block  0
        -: 2923:}
        -: 2924:
        -: 2925:// Gets the number of disabled tests in this test suite.
    #####: 2926:int TestSuite::disabled_test_count() const {
    #####: 2927:  return CountIf(test_info_list_, TestDisabled);
    %%%%%: 2927-block  0
        -: 2928:}
        -: 2929:
        -: 2930:// Gets the number of tests to be printed in the XML report.
    #####: 2931:int TestSuite::reportable_test_count() const {
    #####: 2932:  return CountIf(test_info_list_, TestReportable);
    %%%%%: 2932-block  0
        -: 2933:}
        -: 2934:
        -: 2935:// Get the number of tests in this test suite that should run.
        6: 2936:int TestSuite::test_to_run_count() const {
        6: 2937:  return CountIf(test_info_list_, ShouldRunTest);
        6: 2937-block  0
        -: 2938:}
        -: 2939:
        -: 2940:// Gets the number of all tests.
       32: 2941:int TestSuite::total_test_count() const {
       32: 2942:  return static_cast<int>(test_info_list_.size());
       32: 2942-block  0
        -: 2943:}
        -: 2944:
        -: 2945:// Creates a TestSuite with the given name.
        -: 2946://
        -: 2947:// Arguments:
        -: 2948://
        -: 2949://   a_name:       name of the test suite
        -: 2950://   a_type_param: the name of the test suite's type parameter, or NULL if
        -: 2951://                 this is not a typed or a type-parameterized test suite.
        -: 2952://   set_up_tc:    pointer to the function that sets up the test suite
        -: 2953://   tear_down_tc: pointer to the function that tears down the test suite
        2: 2954:TestSuite::TestSuite(const char* a_name, const char* a_type_param,
        -: 2955:                     internal::SetUpTestSuiteFunc set_up_tc,
        2: 2956:                     internal::TearDownTestSuiteFunc tear_down_tc)
        -: 2957:    : name_(a_name),
    #####: 2958:      type_param_(a_type_param ? new std::string(a_type_param) : nullptr),
    %%%%%: 2958-block  0
    $$$$$: 2958-block  1
        -: 2959:      set_up_tc_(set_up_tc),
        -: 2960:      tear_down_tc_(tear_down_tc),
        -: 2961:      should_run_(false),
        -: 2962:      start_timestamp_(0),
       2*: 2963:      elapsed_time_(0) {}
        2: 2963-block  0
        2: 2963-block  1
    %%%%%: 2963-block  2
    %%%%%: 2963-block  3
        2: 2963-block  4
        2: 2963-block  5
    %%%%%: 2963-block  6
        2: 2963-block  7
        2: 2963-block  8
    $$$$$: 2963-block  9
    $$$$$: 2963-block 10
    $$$$$: 2963-block 11
    $$$$$: 2963-block 12
    $$$$$: 2963-block 13
    $$$$$: 2963-block 14
    $$$$$: 2963-block 15
    $$$$$: 2963-block 16
    $$$$$: 2963-block 17
        -: 2964:
        -: 2965:// Destructor of TestSuite.
        4: 2966:TestSuite::~TestSuite() {
        -: 2967:  // Deletes every Test in the collection.
        2: 2968:  ForEach(test_info_list_, internal::Delete<TestInfo>);
        4: 2969:}
------------------
_ZN7testing9TestSuiteD0Ev:
        2: 2966:TestSuite::~TestSuite() {
        -: 2967:  // Deletes every Test in the collection.
        -: 2968:  ForEach(test_info_list_, internal::Delete<TestInfo>);
        2: 2969:}
        2: 2969-block  0
------------------
_ZN7testing9TestSuiteD2Ev:
        2: 2966:TestSuite::~TestSuite() {
        -: 2967:  // Deletes every Test in the collection.
        2: 2968:  ForEach(test_info_list_, internal::Delete<TestInfo>);
        2: 2968-block  0
        2: 2969:}
------------------
        -: 2970:
        -: 2971:// Returns the i-th test among all the tests. i can range from 0 to
        -: 2972:// total_test_count() - 1. If i is not in that range, returns NULL.
    #####: 2973:const TestInfo* TestSuite::GetTestInfo(int i) const {
    #####: 2974:  const int index = GetElementOr(test_indices_, i, -1);
    %%%%%: 2974-block  0
    #####: 2975:  return index < 0 ? nullptr : test_info_list_[static_cast<size_t>(index)];
    %%%%%: 2975-block  0
    %%%%%: 2975-block  1
    %%%%%: 2975-block  2
        -: 2976:}
        -: 2977:
        -: 2978:// Returns the i-th test among all the tests. i can range from 0 to
        -: 2979:// total_test_count() - 1. If i is not in that range, returns NULL.
       31: 2980:TestInfo* TestSuite::GetMutableTestInfo(int i) {
       31: 2981:  const int index = GetElementOr(test_indices_, i, -1);
       31: 2981-block  0
      31*: 2982:  return index < 0 ? nullptr : test_info_list_[static_cast<size_t>(index)];
       31: 2982-block  0
    %%%%%: 2982-block  1
       31: 2982-block  2
        -: 2983:}
        -: 2984:
        -: 2985:// Adds a test to this test suite.  Will delete the test upon
        -: 2986:// destruction of the TestSuite object.
       41: 2987:void TestSuite::AddTestInfo(TestInfo* test_info) {
       41: 2988:  test_info_list_.push_back(test_info);
       41: 2988-block  0
       41: 2989:  test_indices_.push_back(static_cast<int>(test_indices_.size()));
       41: 2990:}
       41: 2990-block  0
        -: 2991:
        -: 2992:// Runs every test in this TestSuite.
        2: 2993:void TestSuite::Run() {
        2: 2994:  if (!should_run_) return;
        2: 2994-block  0
        1: 2994-block  1
        -: 2995:
        1: 2996:  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
        1: 2996-block  0
        1: 2997:  impl->set_current_test_suite(this);
        1: 2997-block  0
        -: 2998:
        1: 2999:  TestEventListener* repeater = UnitTest::GetInstance()->listeners().repeater();
        1: 2999-block  0
        -: 3000:
        -: 3001:  // Call both legacy and the new API
        1: 3002:  repeater->OnTestSuiteStart(*this);
        -: 3003://  Legacy API is deprecated but still available
        -: 3004:#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        1: 3005:  repeater->OnTestCaseStart(*this);
        1: 3005-block  0
        -: 3006:#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        -: 3007:
        1: 3008:  impl->os_stack_trace_getter()->UponLeavingGTest();
        1: 3008-block  0
        1: 3008-block  1
        1: 3009:  internal::HandleExceptionsInMethodIfSupported(
        1: 3009-block  0
        -: 3010:      this, &TestSuite::RunSetUpTestSuite, "SetUpTestSuite()");
        -: 3011:
        1: 3012:  start_timestamp_ = internal::GetTimeInMillis();
        1: 3012-block  0
        1: 3013:  internal::Timer timer;
        1: 3013-block  0
       32: 3014:  for (int i = 0; i < total_test_count(); i++) {
       32: 3014-block  0
       31: 3014-block  1
       31: 3015:    GetMutableTestInfo(i)->Run();
       31: 3015-block  0
       31: 3015-block  1
      31*: 3016:    if (GTEST_FLAG(fail_fast) && GetMutableTestInfo(i)->result()->Failed()) {
       31: 3016-block  0
    %%%%%: 3016-block  1
    %%%%%: 3016-block  2
    %%%%%: 3016-block  3
    %%%%%: 3016-block  4
       31: 3016-block  5
       31: 3016-block  6
    #####: 3017:      for (int j = i + 1; j < total_test_count(); j++) {
    %%%%%: 3017-block  0
    %%%%%: 3017-block  1
    %%%%%: 3017-block  2
    #####: 3018:        GetMutableTestInfo(j)->Skip();
    %%%%%: 3018-block  0
    %%%%%: 3018-block  1
        -: 3019:      }
    #####: 3020:      break;
    %%%%%: 3020-block  0
        -: 3021:    }
        -: 3022:  }
        1: 3023:  elapsed_time_ = timer.Elapsed();
        1: 3023-block  0
        -: 3024:
        1: 3025:  impl->os_stack_trace_getter()->UponLeavingGTest();
        1: 3025-block  0
        1: 3025-block  1
        1: 3026:  internal::HandleExceptionsInMethodIfSupported(
        1: 3026-block  0
        -: 3027:      this, &TestSuite::RunTearDownTestSuite, "TearDownTestSuite()");
        -: 3028:
        -: 3029:  // Call both legacy and the new API
        1: 3030:  repeater->OnTestSuiteEnd(*this);
        1: 3030-block  0
        -: 3031://  Legacy API is deprecated but still available
        -: 3032:#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        1: 3033:  repeater->OnTestCaseEnd(*this);
        1: 3033-block  0
        -: 3034:#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        -: 3035:
        1: 3036:  impl->set_current_test_suite(nullptr);
        1: 3036-block  0
        -: 3037:}
        -: 3038:
        -: 3039:// Skips all tests under this TestSuite.
    #####: 3040:void TestSuite::Skip() {
    #####: 3041:  if (!should_run_) return;
    %%%%%: 3041-block  0
    %%%%%: 3041-block  1
        -: 3042:
    #####: 3043:  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
    %%%%%: 3043-block  0
    #####: 3044:  impl->set_current_test_suite(this);
        -: 3045:
    #####: 3046:  TestEventListener* repeater = UnitTest::GetInstance()->listeners().repeater();
        -: 3047:
        -: 3048:  // Call both legacy and the new API
    #####: 3049:  repeater->OnTestSuiteStart(*this);
        -: 3050://  Legacy API is deprecated but still available
        -: 3051:#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
    #####: 3052:  repeater->OnTestCaseStart(*this);
        -: 3053:#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        -: 3054:
    #####: 3055:  for (int i = 0; i < total_test_count(); i++) {
    %%%%%: 3055-block  0
    #####: 3056:    GetMutableTestInfo(i)->Skip();
    %%%%%: 3056-block  0
        -: 3057:  }
        -: 3058:
        -: 3059:  // Call both legacy and the new API
    #####: 3060:  repeater->OnTestSuiteEnd(*this);
    %%%%%: 3060-block  0
        -: 3061:  // Legacy API is deprecated but still available
        -: 3062:#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
    #####: 3063:  repeater->OnTestCaseEnd(*this);
        -: 3064:#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        -: 3065:
    #####: 3066:  impl->set_current_test_suite(nullptr);
        -: 3067:}
        -: 3068:
        -: 3069:// Clears the results of all tests in this test suite.
        2: 3070:void TestSuite::ClearResult() {
        2: 3071:  ad_hoc_test_result_.Clear();
        2: 3071-block  0
        2: 3072:  ForEach(test_info_list_, TestInfo::ClearTestResult);
        2: 3073:}
        -: 3074:
        -: 3075:// Shuffles the tests in this test suite.
    #####: 3076:void TestSuite::ShuffleTests(internal::Random* random) {
    #####: 3077:  Shuffle(random, &test_indices_);
    %%%%%: 3077-block  0
    #####: 3078:}
        -: 3079:
        -: 3080:// Restores the test order to before the first shuffle.
        2: 3081:void TestSuite::UnshuffleTests() {
       43: 3082:  for (size_t i = 0; i < test_indices_.size(); i++) {
        2: 3082-block  0
       43: 3082-block  1
       41: 3083:    test_indices_[i] = static_cast<int>(i);
       41: 3083-block  0
        -: 3084:  }
        2: 3085:}
        -: 3086:
        -: 3087:// Formats a countable noun.  Depending on its quantity, either the
        -: 3088:// singular form or the plural form is used. e.g.
        -: 3089://
        -: 3090:// FormatCountableNoun(1, "formula", "formuli") returns "1 formula".
        -: 3091:// FormatCountableNoun(5, "book", "books") returns "5 books".
        7: 3092:static std::string FormatCountableNoun(int count,
        -: 3093:                                       const char * singular_form,
        -: 3094:                                       const char * plural_form) {
       14: 3095:  return internal::StreamableToString(count) + " " +
        7: 3095-block  0
        7: 3095-block  1
    $$$$$: 3095-block  2
    $$$$$: 3095-block  3
    $$$$$: 3095-block  4
       21: 3096:      (count == 1 ? singular_form : plural_form);
        7: 3096-block  0
        2: 3096-block  1
        5: 3096-block  2
        7: 3096-block  3
        7: 3096-block  4
        -: 3097:}
        -: 3098:
        -: 3099:// Formats the count of tests.
        3: 3100:static std::string FormatTestCount(int test_count) {
        3: 3101:  return FormatCountableNoun(test_count, "test", "tests");
        3: 3101-block  0
        -: 3102:}
        -: 3103:
        -: 3104:// Formats the count of test suites.
        2: 3105:static std::string FormatTestSuiteCount(int test_suite_count) {
        2: 3106:  return FormatCountableNoun(test_suite_count, "test suite", "test suites");
        2: 3106-block  0
        -: 3107:}
        -: 3108:
        -: 3109:// Converts a TestPartResult::Type enum to human-friendly string
        -: 3110:// representation.  Both kNonFatalFailure and kFatalFailure are translated
        -: 3111:// to "Failure", as the user usually doesn't care about the difference
        -: 3112:// between the two when viewing the test result.
    #####: 3113:static const char * TestPartResultTypeToString(TestPartResult::Type type) {
    #####: 3114:  switch (type) {
    %%%%%: 3114-block  0
    #####: 3115:    case TestPartResult::kSkip:
    #####: 3116:      return "Skipped\n";
    %%%%%: 3116-block  0
    #####: 3117:    case TestPartResult::kSuccess:
    #####: 3118:      return "Success";
    %%%%%: 3118-block  0
        -: 3119:
    #####: 3120:    case TestPartResult::kNonFatalFailure:
        -: 3121:    case TestPartResult::kFatalFailure:
        -: 3122:#ifdef _MSC_VER
        -: 3123:      return "error: ";
        -: 3124:#else
    #####: 3125:      return "Failure\n";
    %%%%%: 3125-block  0
        -: 3126:#endif
    #####: 3127:    default:
    #####: 3128:      return "Unknown result type";
    %%%%%: 3128-block  0
        -: 3129:  }
        -: 3130:}
        -: 3131:
        -: 3132:namespace internal {
        -: 3133:namespace {
        -: 3134:enum class GTestColor { kDefault, kRed, kGreen, kYellow };
        -: 3135:}  // namespace
        -: 3136:
        -: 3137:// Prints a TestPartResult to an std::string.
    #####: 3138:static std::string PrintTestPartResultToString(
        -: 3139:    const TestPartResult& test_part_result) {
    #####: 3140:  return (Message()
    %%%%%: 3140-block  0
    $$$$$: 3140-block  1
    #####: 3141:          << internal::FormatFileLocation(test_part_result.file_name(),
    $$$$$: 3141-block  0
    $$$$$: 3141-block  1
    #####: 3142:                                          test_part_result.line_number())
    %%%%%: 3142-block  0
    #####: 3143:          << " " << TestPartResultTypeToString(test_part_result.type())
    %%%%%: 3143-block  0
    %%%%%: 3143-block  1
    $$$$$: 3143-block  2
    #####: 3144:          << test_part_result.message()).GetString();
    %%%%%: 3144-block  0
    %%%%%: 3144-block  1
    %%%%%: 3144-block  2
    %%%%%: 3144-block  3
    $$$$$: 3144-block  4
        -: 3145:}
        -: 3146:
        -: 3147:// Prints a TestPartResult.
    #####: 3148:static void PrintTestPartResult(const TestPartResult& test_part_result) {
        -: 3149:  const std::string& result =
    #####: 3150:      PrintTestPartResultToString(test_part_result);
    %%%%%: 3150-block  0
    %%%%%: 3150-block  1
    $$$$$: 3150-block  2
    #####: 3151:  printf("%s\n", result.c_str());
    %%%%%: 3151-block  0
    #####: 3152:  fflush(stdout);
    %%%%%: 3152-block  0
        -: 3153:  // If the test program runs in Visual Studio or a debugger, the
        -: 3154:  // following statements add the test part result message to the Output
        -: 3155:  // window such that the user can double-click on it to jump to the
        -: 3156:  // corresponding source code location; otherwise they do nothing.
        -: 3157:#if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE
        -: 3158:  // We don't call OutputDebugString*() on Windows Mobile, as printing
        -: 3159:  // to stdout is done by OutputDebugString() there already - we don't
        -: 3160:  // want the same message printed twice.
        -: 3161:  ::OutputDebugStringA(result.c_str());
        -: 3162:  ::OutputDebugStringA("\n");
        -: 3163:#endif
    #####: 3164:}
        -: 3165:
        -: 3166:// class PrettyUnitTestResultPrinter
        -: 3167:#if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE && \
        -: 3168:    !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT && !GTEST_OS_WINDOWS_MINGW
        -: 3169:
        -: 3170:// Returns the character attribute for the given color.
        -: 3171:static WORD GetColorAttribute(GTestColor color) {
        -: 3172:  switch (color) {
        -: 3173:    case GTestColor::kRed:
        -: 3174:      return FOREGROUND_RED;
        -: 3175:    case GTestColor::kGreen:
        -: 3176:      return FOREGROUND_GREEN;
        -: 3177:    case GTestColor::kYellow:
        -: 3178:      return FOREGROUND_RED | FOREGROUND_GREEN;
        -: 3179:    default:           return 0;
        -: 3180:  }
        -: 3181:}
        -: 3182:
        -: 3183:static int GetBitOffset(WORD color_mask) {
        -: 3184:  if (color_mask == 0) return 0;
        -: 3185:
        -: 3186:  int bitOffset = 0;
        -: 3187:  while ((color_mask & 1) == 0) {
        -: 3188:    color_mask >>= 1;
        -: 3189:    ++bitOffset;
        -: 3190:  }
        -: 3191:  return bitOffset;
        -: 3192:}
        -: 3193:
        -: 3194:static WORD GetNewColor(GTestColor color, WORD old_color_attrs) {
        -: 3195:  // Let's reuse the BG
        -: 3196:  static const WORD background_mask = BACKGROUND_BLUE | BACKGROUND_GREEN |
        -: 3197:                                      BACKGROUND_RED | BACKGROUND_INTENSITY;
        -: 3198:  static const WORD foreground_mask = FOREGROUND_BLUE | FOREGROUND_GREEN |
        -: 3199:                                      FOREGROUND_RED | FOREGROUND_INTENSITY;
        -: 3200:  const WORD existing_bg = old_color_attrs & background_mask;
        -: 3201:
        -: 3202:  WORD new_color =
        -: 3203:      GetColorAttribute(color) | existing_bg | FOREGROUND_INTENSITY;
        -: 3204:  static const int bg_bitOffset = GetBitOffset(background_mask);
        -: 3205:  static const int fg_bitOffset = GetBitOffset(foreground_mask);
        -: 3206:
        -: 3207:  if (((new_color & background_mask) >> bg_bitOffset) ==
        -: 3208:      ((new_color & foreground_mask) >> fg_bitOffset)) {
        -: 3209:    new_color ^= FOREGROUND_INTENSITY;  // invert intensity
        -: 3210:  }
        -: 3211:  return new_color;
        -: 3212:}
        -: 3213:
        -: 3214:#else
        -: 3215:
        -: 3216:// Returns the ANSI color code for the given color. GTestColor::kDefault is
        -: 3217:// an invalid input.
    #####: 3218:static const char* GetAnsiColorCode(GTestColor color) {
    #####: 3219:  switch (color) {
    %%%%%: 3219-block  0
    #####: 3220:    case GTestColor::kRed:
    #####: 3221:      return "1";
    %%%%%: 3221-block  0
    #####: 3222:    case GTestColor::kGreen:
    #####: 3223:      return "2";
    %%%%%: 3223-block  0
    #####: 3224:    case GTestColor::kYellow:
    #####: 3225:      return "3";
    %%%%%: 3225-block  0
    #####: 3226:    default:
    #####: 3227:      return nullptr;
    %%%%%: 3227-block  0
        -: 3228:  }
        -: 3229:}
        -: 3230:
        -: 3231:#endif  // GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE
        -: 3232:
        -: 3233:// Returns true if and only if Google Test should use colors in the output.
        1: 3234:bool ShouldUseColor(bool stdout_is_tty) {
        1: 3235:  const char* const gtest_color = GTEST_FLAG(color).c_str();
        1: 3235-block  0
        -: 3236:
        1: 3237:  if (String::CaseInsensitiveCStringEquals(gtest_color, "auto")) {
        -: 3238:#if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MINGW
        -: 3239:    // On Windows the TERM variable is usually not set, but the
        -: 3240:    // console there does support colors.
        -: 3241:    return stdout_is_tty;
        -: 3242:#else
        -: 3243:    // On non-Windows platforms, we rely on the TERM variable.
    #####: 3244:    const char* const term = posix::GetEnv("TERM");
    %%%%%: 3244-block  0
        -: 3245:    const bool term_supports_color =
    #####: 3246:        String::CStringEquals(term, "xterm") ||
    #####: 3247:        String::CStringEquals(term, "xterm-color") ||
    %%%%%: 3247-block  0
    #####: 3248:        String::CStringEquals(term, "xterm-256color") ||
    %%%%%: 3248-block  0
    #####: 3249:        String::CStringEquals(term, "screen") ||
    %%%%%: 3249-block  0
    #####: 3250:        String::CStringEquals(term, "screen-256color") ||
    %%%%%: 3250-block  0
    #####: 3251:        String::CStringEquals(term, "tmux") ||
    %%%%%: 3251-block  0
    #####: 3252:        String::CStringEquals(term, "tmux-256color") ||
    %%%%%: 3252-block  0
    #####: 3253:        String::CStringEquals(term, "rxvt-unicode") ||
    %%%%%: 3253-block  0
    #####: 3254:        String::CStringEquals(term, "rxvt-unicode-256color") ||
    %%%%%: 3254-block  0
    #####: 3255:        String::CStringEquals(term, "linux") ||
    %%%%%: 3255-block  0
    %%%%%: 3255-block  1
    %%%%%: 3255-block  2
    #####: 3256:        String::CStringEquals(term, "cygwin");
    %%%%%: 3256-block  0
    #####: 3257:    return stdout_is_tty && term_supports_color;
    %%%%%: 3257-block  0
    %%%%%: 3257-block  1
    %%%%%: 3257-block  2
    %%%%%: 3257-block  3
    %%%%%: 3257-block  4
        -: 3258:#endif  // GTEST_OS_WINDOWS
        -: 3259:  }
        -: 3260:
        2: 3261:  return String::CaseInsensitiveCStringEquals(gtest_color, "yes") ||
        1: 3261-block  0
        2: 3262:      String::CaseInsensitiveCStringEquals(gtest_color, "true") ||
        1: 3262-block  0
       3*: 3263:      String::CaseInsensitiveCStringEquals(gtest_color, "t") ||
        1: 3263-block  0
    %%%%%: 3263-block  1
        1: 3263-block  2
        2: 3264:      String::CStringEquals(gtest_color, "1");
        1: 3264-block  0
        1: 3264-block  1
        -: 3265:  // We take "yes", "true", "t", and "1" as meaning "yes".  If the
        -: 3266:  // value is neither one of these nor "auto", we treat it as "no" to
        -: 3267:  // be conservative.
        -: 3268:}
        -: 3269:
        -: 3270:// Helpers for printing colored strings to stdout. Note that on Windows, we
        -: 3271:// cannot simply emit special characters and have the terminal change colors.
        -: 3272:// This routine must actually emit the characters rather than return a string
        -: 3273:// that would be colored when printed, as can be done on Linux.
        -: 3274:
        -: 3275:GTEST_ATTRIBUTE_PRINTF_(2, 3)
       70: 3276:static void ColoredPrintf(GTestColor color, const char *fmt, ...) {
        -: 3277:  va_list args;
       70: 3278:  va_start(args, fmt);
        -: 3279:
        -: 3280:#if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_ZOS || GTEST_OS_IOS || \
        -: 3281:    GTEST_OS_WINDOWS_PHONE || GTEST_OS_WINDOWS_RT || defined(ESP_PLATFORM)
        -: 3282:  const bool use_color = AlwaysFalse();
        -: 3283:#else
        -: 3284:  static const bool in_color_mode =
       70: 3285:      ShouldUseColor(posix::IsATTY(posix::FileNo(stdout)) != 0);
       70: 3285-block  0
        1: 3285-block  1
        1: 3285-block  2
      70*: 3286:  const bool use_color = in_color_mode && (color != GTestColor::kDefault);
       70: 3286-block  0
    %%%%%: 3286-block  1
    %%%%%: 3286-block  2
       70: 3286-block  3
        -: 3287:#endif  // GTEST_OS_WINDOWS_MOBILE || GTEST_OS_ZOS
        -: 3288:
       70: 3289:  if (!use_color) {
       70: 3289-block  0
       70: 3290:    vprintf(fmt, args);
       70: 3290-block  0
       70: 3291:    va_end(args);
       70: 3292:    return;
       70: 3292-block  0
        -: 3293:  }
        -: 3294:
        -: 3295:#if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE && \
        -: 3296:    !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT && !GTEST_OS_WINDOWS_MINGW
        -: 3297:  const HANDLE stdout_handle = GetStdHandle(STD_OUTPUT_HANDLE);
        -: 3298:
        -: 3299:  // Gets the current text color.
        -: 3300:  CONSOLE_SCREEN_BUFFER_INFO buffer_info;
        -: 3301:  GetConsoleScreenBufferInfo(stdout_handle, &buffer_info);
        -: 3302:  const WORD old_color_attrs = buffer_info.wAttributes;
        -: 3303:  const WORD new_color = GetNewColor(color, old_color_attrs);
        -: 3304:
        -: 3305:  // We need to flush the stream buffers into the console before each
        -: 3306:  // SetConsoleTextAttribute call lest it affect the text that is already
        -: 3307:  // printed but has not yet reached the console.
        -: 3308:  fflush(stdout);
        -: 3309:  SetConsoleTextAttribute(stdout_handle, new_color);
        -: 3310:
        -: 3311:  vprintf(fmt, args);
        -: 3312:
        -: 3313:  fflush(stdout);
        -: 3314:  // Restores the text color.
        -: 3315:  SetConsoleTextAttribute(stdout_handle, old_color_attrs);
        -: 3316:#else
    #####: 3317:  printf("\033[0;3%sm", GetAnsiColorCode(color));
    %%%%%: 3317-block  0
    #####: 3318:  vprintf(fmt, args);
    %%%%%: 3318-block  0
    #####: 3319:  printf("\033[m");  // Resets the terminal to default.
    %%%%%: 3319-block  0
        -: 3320:#endif  // GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE
    #####: 3321:  va_end(args);
    %%%%%: 3321-block  0
        -: 3322:}
        -: 3323:
        -: 3324:// Text printed in Google Test's text output and --gtest_list_tests
        -: 3325:// output to label the type parameter and value parameter for a test.
        -: 3326:static const char kTypeParamLabel[] = "TypeParam";
        -: 3327:static const char kValueParamLabel[] = "GetParam()";
        -: 3328:
    #####: 3329:static void PrintFullTestCommentIfPresent(const TestInfo& test_info) {
    #####: 3330:  const char* const type_param = test_info.type_param();
    %%%%%: 3330-block  0
    #####: 3331:  const char* const value_param = test_info.value_param();
        -: 3332:
    #####: 3333:  if (type_param != nullptr || value_param != nullptr) {
    %%%%%: 3333-block  0
    #####: 3334:    printf(", where ");
    %%%%%: 3334-block  0
    #####: 3335:    if (type_param != nullptr) {
    #####: 3336:      printf("%s = %s", kTypeParamLabel, type_param);
    %%%%%: 3336-block  0
    #####: 3337:      if (value_param != nullptr) printf(" and ");
    %%%%%: 3337-block  0
        -: 3338:    }
    #####: 3339:    if (value_param != nullptr) {
    %%%%%: 3339-block  0
    #####: 3340:      printf("%s = %s", kValueParamLabel, value_param);
    %%%%%: 3340-block  0
        -: 3341:    }
        -: 3342:  }
    #####: 3343:}
        -: 3344:
        -: 3345:// This class implements the TestEventListener interface.
        -: 3346://
        -: 3347:// Class PrettyUnitTestResultPrinter is copyable.
        -: 3348:class PrettyUnitTestResultPrinter : public TestEventListener {
        -: 3349: public:
        1: 3350:  PrettyUnitTestResultPrinter() {}
        1: 3350-block  0
       62: 3351:  static void PrintTestName(const char* test_suite, const char* test) {
       62: 3352:    printf("%s.%s", test_suite, test);
       62: 3352-block  0
       62: 3353:  }
        -: 3354:
        -: 3355:  // The following methods override what's in the TestEventListener class.
        1: 3356:  void OnTestProgramStart(const UnitTest& /*unit_test*/) override {}
        -: 3357:  void OnTestIterationStart(const UnitTest& unit_test, int iteration) override;
        -: 3358:  void OnEnvironmentsSetUpStart(const UnitTest& unit_test) override;
        1: 3359:  void OnEnvironmentsSetUpEnd(const UnitTest& /*unit_test*/) override {}
        -: 3360:#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        -: 3361:  void OnTestCaseStart(const TestCase& test_case) override;
        -: 3362:#else
        -: 3363:  void OnTestSuiteStart(const TestSuite& test_suite) override;
        -: 3364:#endif  // OnTestCaseStart
        -: 3365:
        -: 3366:  void OnTestStart(const TestInfo& test_info) override;
        -: 3367:
        -: 3368:  void OnTestPartResult(const TestPartResult& result) override;
        -: 3369:  void OnTestEnd(const TestInfo& test_info) override;
        -: 3370:#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        -: 3371:  void OnTestCaseEnd(const TestCase& test_case) override;
        -: 3372:#else
        -: 3373:  void OnTestSuiteEnd(const TestSuite& test_suite) override;
        -: 3374:#endif  // GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        -: 3375:
        -: 3376:  void OnEnvironmentsTearDownStart(const UnitTest& unit_test) override;
        1: 3377:  void OnEnvironmentsTearDownEnd(const UnitTest& /*unit_test*/) override {}
        -: 3378:  void OnTestIterationEnd(const UnitTest& unit_test, int iteration) override;
        1: 3379:  void OnTestProgramEnd(const UnitTest& /*unit_test*/) override {}
        -: 3380:
        -: 3381: private:
        -: 3382:  static void PrintFailedTests(const UnitTest& unit_test);
        -: 3383:  static void PrintFailedTestSuites(const UnitTest& unit_test);
        -: 3384:  static void PrintSkippedTests(const UnitTest& unit_test);
        -: 3385:};
        -: 3386:
        -: 3387:  // Fired before each iteration of tests starts.
        1: 3388:void PrettyUnitTestResultPrinter::OnTestIterationStart(
        -: 3389:    const UnitTest& unit_test, int iteration) {
        1: 3390:  if (GTEST_FLAG(repeat) != 1)
        1: 3390-block  0
    #####: 3391:    printf("\nRepeating all tests (iteration %d) . . .\n\n", iteration + 1);
    %%%%%: 3391-block  0
        -: 3392:
        1: 3393:  const char* const filter = GTEST_FLAG(filter).c_str();
        1: 3393-block  0
        -: 3394:
        -: 3395:  // Prints the filter if it's not *.  This reminds the user that some
        -: 3396:  // tests may be skipped.
        1: 3397:  if (!String::CStringEquals(filter, kUniversalFilter)) {
        1: 3398:    ColoredPrintf(GTestColor::kYellow, "Note: %s filter = %s\n", GTEST_NAME_,
        1: 3398-block  0
        -: 3399:                  filter);
        -: 3400:  }
        -: 3401:
        1: 3402:  if (internal::ShouldShard(kTestTotalShards, kTestShardIndex, false)) {
        1: 3402-block  0
    #####: 3403:    const int32_t shard_index = Int32FromEnvOrDie(kTestShardIndex, -1);
    %%%%%: 3403-block  0
    #####: 3404:    ColoredPrintf(GTestColor::kYellow, "Note: This is test shard %d of %s.\n",
        -: 3405:                  static_cast<int>(shard_index) + 1,
        -: 3406:                  internal::posix::GetEnv(kTestTotalShards));
        -: 3407:  }
        -: 3408:
        1: 3409:  if (GTEST_FLAG(shuffle)) {
        1: 3409-block  0
    #####: 3410:    ColoredPrintf(GTestColor::kYellow,
    %%%%%: 3410-block  0
        -: 3411:                  "Note: Randomizing tests' orders with a seed of %d .\n",
        -: 3412:                  unit_test.random_seed());
        -: 3413:  }
        -: 3414:
        1: 3415:  ColoredPrintf(GTestColor::kGreen, "[==========] ");
        1: 3415-block  0
        2: 3416:  printf("Running %s from %s.\n",
        1: 3416-block  0
        2: 3417:         FormatTestCount(unit_test.test_to_run_count()).c_str(),
        1: 3417-block  0
        1: 3417-block  1
    $$$$$: 3417-block  2
    $$$$$: 3417-block  3
        2: 3418:         FormatTestSuiteCount(unit_test.test_suite_to_run_count()).c_str());
    $$$$$: 3418-block  0
        1: 3419:  fflush(stdout);
        1: 3420:}
        -: 3421:
        1: 3422:void PrettyUnitTestResultPrinter::OnEnvironmentsSetUpStart(
        -: 3423:    const UnitTest& /*unit_test*/) {
        1: 3424:  ColoredPrintf(GTestColor::kGreen, "[----------] ");
        1: 3424-block  0
        1: 3425:  printf("Global test environment set-up.\n");
        1: 3426:  fflush(stdout);
        1: 3427:}
        -: 3428:
        -: 3429:#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        1: 3430:void PrettyUnitTestResultPrinter::OnTestCaseStart(const TestCase& test_case) {
        -: 3431:  const std::string counts =
        2: 3432:      FormatCountableNoun(test_case.test_to_run_count(), "test", "tests");
        1: 3432-block  0
        1: 3432-block  1
        1: 3432-block  2
    $$$$$: 3432-block  3
        1: 3433:  ColoredPrintf(GTestColor::kGreen, "[----------] ");
        1: 3433-block  0
        1: 3434:  printf("%s from %s", counts.c_str(), test_case.name());
        1: 3434-block  0
        1: 3435:  if (test_case.type_param() == nullptr) {
        1: 3435-block  0
        1: 3436:    printf("\n");
        1: 3436-block  0
        -: 3437:  } else {
    #####: 3438:    printf(", where %s = %s\n", kTypeParamLabel, test_case.type_param());
    %%%%%: 3438-block  0
        -: 3439:  }
        1: 3440:  fflush(stdout);
        1: 3440-block  0
        1: 3441:}
        -: 3442:#else
        -: 3443:void PrettyUnitTestResultPrinter::OnTestSuiteStart(
        -: 3444:    const TestSuite& test_suite) {
        -: 3445:  const std::string counts =
        -: 3446:      FormatCountableNoun(test_suite.test_to_run_count(), "test", "tests");
        -: 3447:  ColoredPrintf(GTestColor::kGreen, "[----------] ");
        -: 3448:  printf("%s from %s", counts.c_str(), test_suite.name());
        -: 3449:  if (test_suite.type_param() == nullptr) {
        -: 3450:    printf("\n");
        -: 3451:  } else {
        -: 3452:    printf(", where %s = %s\n", kTypeParamLabel, test_suite.type_param());
        -: 3453:  }
        -: 3454:  fflush(stdout);
        -: 3455:}
        -: 3456:#endif  // GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        -: 3457:
       31: 3458:void PrettyUnitTestResultPrinter::OnTestStart(const TestInfo& test_info) {
       31: 3459:  ColoredPrintf(GTestColor::kGreen, "[ RUN      ] ");
       31: 3459-block  0
       31: 3460:  PrintTestName(test_info.test_suite_name(), test_info.name());
       31: 3461:  printf("\n");
       31: 3462:  fflush(stdout);
       31: 3463:}
        -: 3464:
        -: 3465:// Called after an assertion failure.
    #####: 3466:void PrettyUnitTestResultPrinter::OnTestPartResult(
        -: 3467:    const TestPartResult& result) {
    #####: 3468:  switch (result.type()) {
    %%%%%: 3468-block  0
        -: 3469:    // If the test part succeeded, we don't need to do anything.
    #####: 3470:    case TestPartResult::kSuccess:
    #####: 3471:      return;
    %%%%%: 3471-block  0
    #####: 3472:    default:
        -: 3473:      // Print failure message from the assertion
        -: 3474:      // (e.g. expected this and got that).
    #####: 3475:      PrintTestPartResult(result);
    %%%%%: 3475-block  0
    #####: 3476:      fflush(stdout);
        -: 3477:  }
        -: 3478:}
        -: 3479:
       31: 3480:void PrettyUnitTestResultPrinter::OnTestEnd(const TestInfo& test_info) {
       31: 3481:  if (test_info.result()->Passed()) {
       31: 3481-block  0
       31: 3482:    ColoredPrintf(GTestColor::kGreen, "[       OK ] ");
       31: 3482-block  0
    #####: 3483:  } else if (test_info.result()->Skipped()) {
    %%%%%: 3483-block  0
    #####: 3484:    ColoredPrintf(GTestColor::kGreen, "[  SKIPPED ] ");
    %%%%%: 3484-block  0
        -: 3485:  } else {
    #####: 3486:    ColoredPrintf(GTestColor::kRed, "[  FAILED  ] ");
    %%%%%: 3486-block  0
        -: 3487:  }
       31: 3488:  PrintTestName(test_info.test_suite_name(), test_info.name());
       31: 3488-block  0
       31: 3489:  if (test_info.result()->Failed())
    #####: 3490:    PrintFullTestCommentIfPresent(test_info);
    %%%%%: 3490-block  0
        -: 3491:
       31: 3492:  if (GTEST_FLAG(print_time)) {
       31: 3492-block  0
       31: 3493:    printf(" (%s ms)\n", internal::StreamableToString(
       31: 3493-block  0
       31: 3493-block  1
    $$$$$: 3493-block  2
    $$$$$: 3493-block  3
       62: 3494:           test_info.result()->elapsed_time()).c_str());
       31: 3494-block  0
        -: 3495:  } else {
    #####: 3496:    printf("\n");
    %%%%%: 3496-block  0
        -: 3497:  }
       31: 3498:  fflush(stdout);
       31: 3498-block  0
       31: 3499:}
        -: 3500:
        -: 3501:#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        1: 3502:void PrettyUnitTestResultPrinter::OnTestCaseEnd(const TestCase& test_case) {
       1*: 3503:  if (!GTEST_FLAG(print_time)) return;
        1: 3503-block  0
    %%%%%: 3503-block  1
        -: 3504:
        -: 3505:  const std::string counts =
        2: 3506:      FormatCountableNoun(test_case.test_to_run_count(), "test", "tests");
        1: 3506-block  0
        1: 3506-block  1
        1: 3506-block  2
    $$$$$: 3506-block  3
        1: 3507:  ColoredPrintf(GTestColor::kGreen, "[----------] ");
        1: 3507-block  0
        1: 3508:  printf("%s from %s (%s ms total)\n\n", counts.c_str(), test_case.name(),
        1: 3508-block  0
        2: 3509:         internal::StreamableToString(test_case.elapsed_time()).c_str());
        1: 3509-block  0
        1: 3509-block  1
    $$$$$: 3509-block  2
    $$$$$: 3509-block  3
    $$$$$: 3509-block  4
        1: 3510:  fflush(stdout);
        -: 3511:}
        -: 3512:#else
        -: 3513:void PrettyUnitTestResultPrinter::OnTestSuiteEnd(const TestSuite& test_suite) {
        -: 3514:  if (!GTEST_FLAG(print_time)) return;
        -: 3515:
        -: 3516:  const std::string counts =
        -: 3517:      FormatCountableNoun(test_suite.test_to_run_count(), "test", "tests");
        -: 3518:  ColoredPrintf(GTestColor::kGreen, "[----------] ");
        -: 3519:  printf("%s from %s (%s ms total)\n\n", counts.c_str(), test_suite.name(),
        -: 3520:         internal::StreamableToString(test_suite.elapsed_time()).c_str());
        -: 3521:  fflush(stdout);
        -: 3522:}
        -: 3523:#endif  // GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        -: 3524:
        1: 3525:void PrettyUnitTestResultPrinter::OnEnvironmentsTearDownStart(
        -: 3526:    const UnitTest& /*unit_test*/) {
        1: 3527:  ColoredPrintf(GTestColor::kGreen, "[----------] ");
        1: 3527-block  0
        1: 3528:  printf("Global test environment tear-down\n");
        1: 3529:  fflush(stdout);
        1: 3530:}
        -: 3531:
        -: 3532:// Internal helper for printing the list of failed tests.
    #####: 3533:void PrettyUnitTestResultPrinter::PrintFailedTests(const UnitTest& unit_test) {
    #####: 3534:  const int failed_test_count = unit_test.failed_test_count();
    %%%%%: 3534-block  0
    #####: 3535:  ColoredPrintf(GTestColor::kRed, "[  FAILED  ] ");
    #####: 3536:  printf("%s, listed below:\n", FormatTestCount(failed_test_count).c_str());
    %%%%%: 3536-block  0
    $$$$$: 3536-block  1
        -: 3537:
    #####: 3538:  for (int i = 0; i < unit_test.total_test_suite_count(); ++i) {
    %%%%%: 3538-block  0
    %%%%%: 3538-block  1
    #####: 3539:    const TestSuite& test_suite = *unit_test.GetTestSuite(i);
    %%%%%: 3539-block  0
    #####: 3540:    if (!test_suite.should_run() || (test_suite.failed_test_count() == 0)) {
    %%%%%: 3540-block  0
    %%%%%: 3540-block  1
    %%%%%: 3540-block  2
    %%%%%: 3540-block  3
    #####: 3541:      continue;
    %%%%%: 3541-block  0
        -: 3542:    }
    #####: 3543:    for (int j = 0; j < test_suite.total_test_count(); ++j) {
    %%%%%: 3543-block  0
    %%%%%: 3543-block  1
    %%%%%: 3543-block  2
    #####: 3544:      const TestInfo& test_info = *test_suite.GetTestInfo(j);
    %%%%%: 3544-block  0
    #####: 3545:      if (!test_info.should_run() || !test_info.result()->Failed()) {
    %%%%%: 3545-block  0
    %%%%%: 3545-block  1
    %%%%%: 3545-block  2
    %%%%%: 3545-block  3
    #####: 3546:        continue;
    %%%%%: 3546-block  0
        -: 3547:      }
    #####: 3548:      ColoredPrintf(GTestColor::kRed, "[  FAILED  ] ");
    %%%%%: 3548-block  0
    #####: 3549:      printf("%s.%s", test_suite.name(), test_info.name());
    #####: 3550:      PrintFullTestCommentIfPresent(test_info);
    #####: 3551:      printf("\n");
        -: 3552:    }
        -: 3553:  }
    #####: 3554:  printf("\n%2d FAILED %s\n", failed_test_count,
    %%%%%: 3554-block  0
    %%%%%: 3554-block  1
    %%%%%: 3554-block  2
    %%%%%: 3554-block  3
        -: 3555:         failed_test_count == 1 ? "TEST" : "TESTS");
    #####: 3556:}
        -: 3557:
        -: 3558:// Internal helper for printing the list of test suite failures not covered by
        -: 3559:// PrintFailedTests.
    #####: 3560:void PrettyUnitTestResultPrinter::PrintFailedTestSuites(
        -: 3561:    const UnitTest& unit_test) {
    #####: 3562:  int suite_failure_count = 0;
    #####: 3563:  for (int i = 0; i < unit_test.total_test_suite_count(); ++i) {
    %%%%%: 3563-block  0
    %%%%%: 3563-block  1
    %%%%%: 3563-block  2
    #####: 3564:    const TestSuite& test_suite = *unit_test.GetTestSuite(i);
    %%%%%: 3564-block  0
    #####: 3565:    if (!test_suite.should_run()) {
    #####: 3566:      continue;
    %%%%%: 3566-block  0
        -: 3567:    }
    #####: 3568:    if (test_suite.ad_hoc_test_result().Failed()) {
    %%%%%: 3568-block  0
    #####: 3569:      ColoredPrintf(GTestColor::kRed, "[  FAILED  ] ");
    %%%%%: 3569-block  0
    #####: 3570:      printf("%s: SetUpTestSuite or TearDownTestSuite\n", test_suite.name());
    #####: 3571:      ++suite_failure_count;
        -: 3572:    }
        -: 3573:  }
    #####: 3574:  if (suite_failure_count > 0) {
    %%%%%: 3574-block  0
    #####: 3575:    printf("\n%2d FAILED TEST %s\n", suite_failure_count,
    %%%%%: 3575-block  0
    %%%%%: 3575-block  1
    %%%%%: 3575-block  2
    %%%%%: 3575-block  3
        -: 3576:           suite_failure_count == 1 ? "SUITE" : "SUITES");
        -: 3577:  }
    #####: 3578:}
        -: 3579:
        -: 3580:// Internal helper for printing the list of skipped tests.
    #####: 3581:void PrettyUnitTestResultPrinter::PrintSkippedTests(const UnitTest& unit_test) {
    #####: 3582:  const int skipped_test_count = unit_test.skipped_test_count();
    %%%%%: 3582-block  0
    #####: 3583:  if (skipped_test_count == 0) {
    #####: 3584:    return;
    %%%%%: 3584-block  0
        -: 3585:  }
        -: 3586:
    #####: 3587:  for (int i = 0; i < unit_test.total_test_suite_count(); ++i) {
    %%%%%: 3587-block  0
    %%%%%: 3587-block  1
    %%%%%: 3587-block  2
    #####: 3588:    const TestSuite& test_suite = *unit_test.GetTestSuite(i);
    %%%%%: 3588-block  0
    #####: 3589:    if (!test_suite.should_run() || (test_suite.skipped_test_count() == 0)) {
    %%%%%: 3589-block  0
    %%%%%: 3589-block  1
    %%%%%: 3589-block  2
    %%%%%: 3589-block  3
    #####: 3590:      continue;
    %%%%%: 3590-block  0
        -: 3591:    }
    #####: 3592:    for (int j = 0; j < test_suite.total_test_count(); ++j) {
    %%%%%: 3592-block  0
    %%%%%: 3592-block  1
    %%%%%: 3592-block  2
    #####: 3593:      const TestInfo& test_info = *test_suite.GetTestInfo(j);
    %%%%%: 3593-block  0
    #####: 3594:      if (!test_info.should_run() || !test_info.result()->Skipped()) {
    %%%%%: 3594-block  0
    %%%%%: 3594-block  1
    %%%%%: 3594-block  2
    %%%%%: 3594-block  3
    #####: 3595:        continue;
    %%%%%: 3595-block  0
        -: 3596:      }
    #####: 3597:      ColoredPrintf(GTestColor::kGreen, "[  SKIPPED ] ");
    %%%%%: 3597-block  0
    #####: 3598:      printf("%s.%s", test_suite.name(), test_info.name());
    #####: 3599:      printf("\n");
        -: 3600:    }
        -: 3601:  }
        -: 3602:}
        -: 3603:
        1: 3604:void PrettyUnitTestResultPrinter::OnTestIterationEnd(const UnitTest& unit_test,
        -: 3605:                                                     int /*iteration*/) {
        1: 3606:  ColoredPrintf(GTestColor::kGreen, "[==========] ");
        1: 3606-block  0
        2: 3607:  printf("%s from %s ran.",
        1: 3607-block  0
        2: 3608:         FormatTestCount(unit_test.test_to_run_count()).c_str(),
        1: 3608-block  0
        1: 3608-block  1
    $$$$$: 3608-block  2
    $$$$$: 3608-block  3
        2: 3609:         FormatTestSuiteCount(unit_test.test_suite_to_run_count()).c_str());
    $$$$$: 3609-block  0
    $$$$$: 3609-block  1
        1: 3610:  if (GTEST_FLAG(print_time)) {
        1: 3611:    printf(" (%s ms total)",
        1: 3611-block  0
        2: 3612:           internal::StreamableToString(unit_test.elapsed_time()).c_str());
        1: 3612-block  0
        1: 3612-block  1
    $$$$$: 3612-block  2
    $$$$$: 3612-block  3
    $$$$$: 3612-block  4
        -: 3613:  }
        1: 3614:  printf("\n");
        1: 3614-block  0
        1: 3615:  ColoredPrintf(GTestColor::kGreen, "[  PASSED  ] ");
        1: 3616:  printf("%s.\n", FormatTestCount(unit_test.successful_test_count()).c_str());
        1: 3616-block  0
    $$$$$: 3616-block  1
    $$$$$: 3616-block  2
        -: 3617:
        1: 3618:  const int skipped_test_count = unit_test.skipped_test_count();
        1: 3619:  if (skipped_test_count > 0) {
    #####: 3620:    ColoredPrintf(GTestColor::kGreen, "[  SKIPPED ] ");
    %%%%%: 3620-block  0
    #####: 3621:    printf("%s, listed below:\n", FormatTestCount(skipped_test_count).c_str());
    %%%%%: 3621-block  0
    $$$$$: 3621-block  1
    #####: 3622:    PrintSkippedTests(unit_test);
        -: 3623:  }
        -: 3624:
        1: 3625:  if (!unit_test.Passed()) {
        1: 3625-block  0
    #####: 3626:    PrintFailedTests(unit_test);
    %%%%%: 3626-block  0
    #####: 3627:    PrintFailedTestSuites(unit_test);
        -: 3628:  }
        -: 3629:
        1: 3630:  int num_disabled = unit_test.reportable_disabled_test_count();
        1: 3630-block  0
       1*: 3631:  if (num_disabled && !GTEST_FLAG(also_run_disabled_tests)) {
    %%%%%: 3631-block  0
    #####: 3632:    if (unit_test.Passed()) {
    %%%%%: 3632-block  0
    #####: 3633:      printf("\n");  // Add a spacer if no FAILURE banner is displayed.
    %%%%%: 3633-block  0
        -: 3634:    }
    #####: 3635:    ColoredPrintf(GTestColor::kYellow, "  YOU HAVE %d DISABLED %s\n\n",
    %%%%%: 3635-block  0
    %%%%%: 3635-block  1
    %%%%%: 3635-block  2
    %%%%%: 3635-block  3
        -: 3636:                  num_disabled, num_disabled == 1 ? "TEST" : "TESTS");
        -: 3637:  }
        -: 3638:  // Ensure that Google Test output is printed before, e.g., heapchecker output.
        1: 3639:  fflush(stdout);
        1: 3639-block  0
        1: 3640:}
        -: 3641:
        -: 3642:// End PrettyUnitTestResultPrinter
        -: 3643:
        -: 3644:// This class implements the TestEventListener interface.
        -: 3645://
        -: 3646:// Class BriefUnitTestResultPrinter is copyable.
        -: 3647:class BriefUnitTestResultPrinter : public TestEventListener {
        -: 3648: public:
    #####: 3649:  BriefUnitTestResultPrinter() {}
    %%%%%: 3649-block  0
    #####: 3650:  static void PrintTestName(const char* test_suite, const char* test) {
    #####: 3651:    printf("%s.%s", test_suite, test);
    %%%%%: 3651-block  0
    #####: 3652:  }
        -: 3653:
        -: 3654:  // The following methods override what's in the TestEventListener class.
    #####: 3655:  void OnTestProgramStart(const UnitTest& /*unit_test*/) override {}
    #####: 3656:  void OnTestIterationStart(const UnitTest& /*unit_test*/,
    #####: 3657:                            int /*iteration*/) override {}
    #####: 3658:  void OnEnvironmentsSetUpStart(const UnitTest& /*unit_test*/) override {}
    #####: 3659:  void OnEnvironmentsSetUpEnd(const UnitTest& /*unit_test*/) override {}
        -: 3660:#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
    #####: 3661:  void OnTestCaseStart(const TestCase& /*test_case*/) override {}
        -: 3662:#else
        -: 3663:  void OnTestSuiteStart(const TestSuite& /*test_suite*/) override {}
        -: 3664:#endif  // OnTestCaseStart
        -: 3665:
    #####: 3666:  void OnTestStart(const TestInfo& /*test_info*/) override {}
        -: 3667:
        -: 3668:  void OnTestPartResult(const TestPartResult& result) override;
        -: 3669:  void OnTestEnd(const TestInfo& test_info) override;
        -: 3670:#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
    #####: 3671:  void OnTestCaseEnd(const TestCase& /*test_case*/) override {}
        -: 3672:#else
        -: 3673:  void OnTestSuiteEnd(const TestSuite& /*test_suite*/) override {}
        -: 3674:#endif  // GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        -: 3675:
    #####: 3676:  void OnEnvironmentsTearDownStart(const UnitTest& /*unit_test*/) override {}
    #####: 3677:  void OnEnvironmentsTearDownEnd(const UnitTest& /*unit_test*/) override {}
        -: 3678:  void OnTestIterationEnd(const UnitTest& unit_test, int iteration) override;
    #####: 3679:  void OnTestProgramEnd(const UnitTest& /*unit_test*/) override {}
        -: 3680:};
        -: 3681:
        -: 3682:// Called after an assertion failure.
    #####: 3683:void BriefUnitTestResultPrinter::OnTestPartResult(
        -: 3684:    const TestPartResult& result) {
    #####: 3685:  switch (result.type()) {
    %%%%%: 3685-block  0
        -: 3686:    // If the test part succeeded, we don't need to do anything.
    #####: 3687:    case TestPartResult::kSuccess:
    #####: 3688:      return;
    %%%%%: 3688-block  0
    #####: 3689:    default:
        -: 3690:      // Print failure message from the assertion
        -: 3691:      // (e.g. expected this and got that).
    #####: 3692:      PrintTestPartResult(result);
    %%%%%: 3692-block  0
    #####: 3693:      fflush(stdout);
        -: 3694:  }
        -: 3695:}
        -: 3696:
    #####: 3697:void BriefUnitTestResultPrinter::OnTestEnd(const TestInfo& test_info) {
    #####: 3698:  if (test_info.result()->Failed()) {
    %%%%%: 3698-block  0
    #####: 3699:    ColoredPrintf(GTestColor::kRed, "[  FAILED  ] ");
    %%%%%: 3699-block  0
    #####: 3700:    PrintTestName(test_info.test_suite_name(), test_info.name());
    #####: 3701:    PrintFullTestCommentIfPresent(test_info);
        -: 3702:
    #####: 3703:    if (GTEST_FLAG(print_time)) {
    #####: 3704:      printf(" (%s ms)\n",
    %%%%%: 3704-block  0
    #####: 3705:             internal::StreamableToString(test_info.result()->elapsed_time())
    %%%%%: 3705-block  0
    %%%%%: 3705-block  1
    $$$$$: 3705-block  2
    $$$$$: 3705-block  3
        -: 3706:                 .c_str());
        -: 3707:    } else {
    #####: 3708:      printf("\n");
    %%%%%: 3708-block  0
        -: 3709:    }
    #####: 3710:    fflush(stdout);
    %%%%%: 3710-block  0
        -: 3711:  }
    #####: 3712:}
    %%%%%: 3712-block  0
        -: 3713:
    #####: 3714:void BriefUnitTestResultPrinter::OnTestIterationEnd(const UnitTest& unit_test,
        -: 3715:                                                    int /*iteration*/) {
    #####: 3716:  ColoredPrintf(GTestColor::kGreen, "[==========] ");
    %%%%%: 3716-block  0
    #####: 3717:  printf("%s from %s ran.",
    %%%%%: 3717-block  0
    #####: 3718:         FormatTestCount(unit_test.test_to_run_count()).c_str(),
    %%%%%: 3718-block  0
    %%%%%: 3718-block  1
    $$$$$: 3718-block  2
    $$$$$: 3718-block  3
    #####: 3719:         FormatTestSuiteCount(unit_test.test_suite_to_run_count()).c_str());
    $$$$$: 3719-block  0
    $$$$$: 3719-block  1
    #####: 3720:  if (GTEST_FLAG(print_time)) {
    #####: 3721:    printf(" (%s ms total)",
    %%%%%: 3721-block  0
    #####: 3722:           internal::StreamableToString(unit_test.elapsed_time()).c_str());
    %%%%%: 3722-block  0
    %%%%%: 3722-block  1
    $$$$$: 3722-block  2
    $$$$$: 3722-block  3
    $$$$$: 3722-block  4
        -: 3723:  }
    #####: 3724:  printf("\n");
    %%%%%: 3724-block  0
    #####: 3725:  ColoredPrintf(GTestColor::kGreen, "[  PASSED  ] ");
    #####: 3726:  printf("%s.\n", FormatTestCount(unit_test.successful_test_count()).c_str());
    %%%%%: 3726-block  0
    $$$$$: 3726-block  1
    $$$$$: 3726-block  2
        -: 3727:
    #####: 3728:  const int skipped_test_count = unit_test.skipped_test_count();
    #####: 3729:  if (skipped_test_count > 0) {
    #####: 3730:    ColoredPrintf(GTestColor::kGreen, "[  SKIPPED ] ");
    %%%%%: 3730-block  0
    #####: 3731:    printf("%s.\n", FormatTestCount(skipped_test_count).c_str());
    %%%%%: 3731-block  0
    $$$$$: 3731-block  1
        -: 3732:  }
        -: 3733:
    #####: 3734:  int num_disabled = unit_test.reportable_disabled_test_count();
    %%%%%: 3734-block  0
    #####: 3735:  if (num_disabled && !GTEST_FLAG(also_run_disabled_tests)) {
    %%%%%: 3735-block  0
    #####: 3736:    if (unit_test.Passed()) {
    %%%%%: 3736-block  0
    #####: 3737:      printf("\n");  // Add a spacer if no FAILURE banner is displayed.
    %%%%%: 3737-block  0
        -: 3738:    }
    #####: 3739:    ColoredPrintf(GTestColor::kYellow, "  YOU HAVE %d DISABLED %s\n\n",
    %%%%%: 3739-block  0
    %%%%%: 3739-block  1
    %%%%%: 3739-block  2
    %%%%%: 3739-block  3
        -: 3740:                  num_disabled, num_disabled == 1 ? "TEST" : "TESTS");
        -: 3741:  }
        -: 3742:  // Ensure that Google Test output is printed before, e.g., heapchecker output.
    #####: 3743:  fflush(stdout);
    %%%%%: 3743-block  0
    #####: 3744:}
        -: 3745:
        -: 3746:// End BriefUnitTestResultPrinter
        -: 3747:
        -: 3748:// class TestEventRepeater
        -: 3749://
        -: 3750:// This class forwards events to other event listeners.
        -: 3751:class TestEventRepeater : public TestEventListener {
        -: 3752: public:
        1: 3753:  TestEventRepeater() : forwarding_enabled_(true) {}
        1: 3753-block  0
        -: 3754:  ~TestEventRepeater() override;
        -: 3755:  void Append(TestEventListener *listener);
        -: 3756:  TestEventListener* Release(TestEventListener* listener);
        -: 3757:
        -: 3758:  // Controls whether events will be forwarded to listeners_. Set to false
        -: 3759:  // in death test child processes.
    #####: 3760:  bool forwarding_enabled() const { return forwarding_enabled_; }
    %%%%%: 3760-block  0
    #####: 3761:  void set_forwarding_enabled(bool enable) { forwarding_enabled_ = enable; }
        -: 3762:
        -: 3763:  void OnTestProgramStart(const UnitTest& unit_test) override;
        -: 3764:  void OnTestIterationStart(const UnitTest& unit_test, int iteration) override;
        -: 3765:  void OnEnvironmentsSetUpStart(const UnitTest& unit_test) override;
        -: 3766:  void OnEnvironmentsSetUpEnd(const UnitTest& unit_test) override;
        -: 3767://  Legacy API is deprecated but still available
        -: 3768:#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        -: 3769:  void OnTestCaseStart(const TestSuite& parameter) override;
        -: 3770:#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        -: 3771:  void OnTestSuiteStart(const TestSuite& parameter) override;
        -: 3772:  void OnTestStart(const TestInfo& test_info) override;
        -: 3773:  void OnTestPartResult(const TestPartResult& result) override;
        -: 3774:  void OnTestEnd(const TestInfo& test_info) override;
        -: 3775://  Legacy API is deprecated but still available
        -: 3776:#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        -: 3777:  void OnTestCaseEnd(const TestCase& parameter) override;
        -: 3778:#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        -: 3779:  void OnTestSuiteEnd(const TestSuite& parameter) override;
        -: 3780:  void OnEnvironmentsTearDownStart(const UnitTest& unit_test) override;
        -: 3781:  void OnEnvironmentsTearDownEnd(const UnitTest& unit_test) override;
        -: 3782:  void OnTestIterationEnd(const UnitTest& unit_test, int iteration) override;
        -: 3783:  void OnTestProgramEnd(const UnitTest& unit_test) override;
        -: 3784:
        -: 3785: private:
        -: 3786:  // Controls whether events will be forwarded to listeners_. Set to false
        -: 3787:  // in death test child processes.
        -: 3788:  bool forwarding_enabled_;
        -: 3789:  // The list of listeners that receive events.
        -: 3790:  std::vector<TestEventListener*> listeners_;
        -: 3791:
        -: 3792:  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestEventRepeater);
        -: 3793:};
        -: 3794:
        2: 3795:TestEventRepeater::~TestEventRepeater() {
        1: 3796:  ForEach(listeners_, Delete<TestEventListener>);
        2: 3797:}
------------------
_ZN7testing8internal17TestEventRepeaterD0Ev:
        1: 3795:TestEventRepeater::~TestEventRepeater() {
        -: 3796:  ForEach(listeners_, Delete<TestEventListener>);
        1: 3797:}
        1: 3797-block  0
------------------
_ZN7testing8internal17TestEventRepeaterD2Ev:
        1: 3795:TestEventRepeater::~TestEventRepeater() {
        1: 3796:  ForEach(listeners_, Delete<TestEventListener>);
        1: 3796-block  0
        1: 3797:}
------------------
        -: 3798:
        1: 3799:void TestEventRepeater::Append(TestEventListener *listener) {
        1: 3800:  listeners_.push_back(listener);
        1: 3800-block  0
        1: 3801:}
        -: 3802:
        1: 3803:TestEventListener* TestEventRepeater::Release(TestEventListener *listener) {
       1*: 3804:  for (size_t i = 0; i < listeners_.size(); ++i) {
        1: 3804-block  0
        1: 3804-block  1
    %%%%%: 3804-block  2
    #####: 3805:    if (listeners_[i] == listener) {
    %%%%%: 3805-block  0
    #####: 3806:      listeners_.erase(listeners_.begin() + static_cast<int>(i));
    %%%%%: 3806-block  0
    $$$$$: 3806-block  1
    $$$$$: 3806-block  2
    #####: 3807:      return listener;
    %%%%%: 3807-block  0
        -: 3808:    }
        -: 3809:  }
        -: 3810:
        1: 3811:  return nullptr;
        1: 3811-block  0
        -: 3812:}
        -: 3813:
        -: 3814:// Since most methods are very similar, use macros to reduce boilerplate.
        -: 3815:// This defines a member that forwards the call to all listeners.
        -: 3816:#define GTEST_REPEATER_METHOD_(Name, Type) \
        -: 3817:void TestEventRepeater::Name(const Type& parameter) { \
        -: 3818:  if (forwarding_enabled_) { \
        -: 3819:    for (size_t i = 0; i < listeners_.size(); i++) { \
        -: 3820:      listeners_[i]->Name(parameter); \
        -: 3821:    } \
        -: 3822:  } \
        -: 3823:}
        -: 3824:// This defines a member that forwards the call to all listeners in reverse
        -: 3825:// order.
        -: 3826:#define GTEST_REVERSE_REPEATER_METHOD_(Name, Type)      \
        -: 3827:  void TestEventRepeater::Name(const Type& parameter) { \
        -: 3828:    if (forwarding_enabled_) {                          \
        -: 3829:      for (size_t i = listeners_.size(); i != 0; i--) { \
        -: 3830:        listeners_[i - 1]->Name(parameter);             \
        -: 3831:      }                                                 \
        -: 3832:    }                                                   \
        -: 3833:  }
        -: 3834:
        2: 3835:GTEST_REPEATER_METHOD_(OnTestProgramStart, UnitTest)
        1: 3835-block  0
        1: 3835-block  1
        2: 3835-block  2
        1: 3835-block  3
        2: 3836:GTEST_REPEATER_METHOD_(OnEnvironmentsSetUpStart, UnitTest)
        1: 3836-block  0
        1: 3836-block  1
        2: 3836-block  2
        1: 3836-block  3
        -: 3837://  Legacy API is deprecated but still available
        -: 3838:#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        2: 3839:GTEST_REPEATER_METHOD_(OnTestCaseStart, TestSuite)
        1: 3839-block  0
        1: 3839-block  1
        2: 3839-block  2
        1: 3839-block  3
        -: 3840:#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        2: 3841:GTEST_REPEATER_METHOD_(OnTestSuiteStart, TestSuite)
        1: 3841-block  0
        1: 3841-block  1
        2: 3841-block  2
        1: 3841-block  3
       62: 3842:GTEST_REPEATER_METHOD_(OnTestStart, TestInfo)
       31: 3842-block  0
       31: 3842-block  1
       62: 3842-block  2
       31: 3842-block  3
    #####: 3843:GTEST_REPEATER_METHOD_(OnTestPartResult, TestPartResult)
    %%%%%: 3843-block  0
    %%%%%: 3843-block  1
    %%%%%: 3843-block  2
    %%%%%: 3843-block  3
        2: 3844:GTEST_REPEATER_METHOD_(OnEnvironmentsTearDownStart, UnitTest)
        1: 3844-block  0
        1: 3844-block  1
        2: 3844-block  2
        1: 3844-block  3
        2: 3845:GTEST_REVERSE_REPEATER_METHOD_(OnEnvironmentsSetUpEnd, UnitTest)
        1: 3845-block  0
        1: 3845-block  1
        2: 3845-block  2
        1: 3845-block  3
        2: 3846:GTEST_REVERSE_REPEATER_METHOD_(OnEnvironmentsTearDownEnd, UnitTest)
        1: 3846-block  0
        1: 3846-block  1
        2: 3846-block  2
        1: 3846-block  3
       62: 3847:GTEST_REVERSE_REPEATER_METHOD_(OnTestEnd, TestInfo)
       31: 3847-block  0
       31: 3847-block  1
       62: 3847-block  2
       31: 3847-block  3
        -: 3848://  Legacy API is deprecated but still available
        -: 3849:#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        2: 3850:GTEST_REVERSE_REPEATER_METHOD_(OnTestCaseEnd, TestSuite)
        1: 3850-block  0
        1: 3850-block  1
        2: 3850-block  2
        1: 3850-block  3
        -: 3851:#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        2: 3852:GTEST_REVERSE_REPEATER_METHOD_(OnTestSuiteEnd, TestSuite)
        1: 3852-block  0
        1: 3852-block  1
        2: 3852-block  2
        1: 3852-block  3
        2: 3853:GTEST_REVERSE_REPEATER_METHOD_(OnTestProgramEnd, UnitTest)
        1: 3853-block  0
        1: 3853-block  1
        2: 3853-block  2
        1: 3853-block  3
        -: 3854:
        -: 3855:#undef GTEST_REPEATER_METHOD_
        -: 3856:#undef GTEST_REVERSE_REPEATER_METHOD_
        -: 3857:
        1: 3858:void TestEventRepeater::OnTestIterationStart(const UnitTest& unit_test,
        -: 3859:                                             int iteration) {
        1: 3860:  if (forwarding_enabled_) {
        1: 3860-block  0
        2: 3861:    for (size_t i = 0; i < listeners_.size(); i++) {
        1: 3861-block  0
        2: 3861-block  1
        1: 3862:      listeners_[i]->OnTestIterationStart(unit_test, iteration);
        1: 3862-block  0
        -: 3863:    }
        -: 3864:  }
        1: 3865:}
        -: 3866:
        1: 3867:void TestEventRepeater::OnTestIterationEnd(const UnitTest& unit_test,
        -: 3868:                                           int iteration) {
        1: 3869:  if (forwarding_enabled_) {
        1: 3869-block  0
        2: 3870:    for (size_t i = listeners_.size(); i > 0; i--) {
        1: 3870-block  0
        2: 3870-block  1
        1: 3871:      listeners_[i - 1]->OnTestIterationEnd(unit_test, iteration);
        1: 3871-block  0
        -: 3872:    }
        -: 3873:  }
        1: 3874:}
        -: 3875:
        -: 3876:// End TestEventRepeater
        -: 3877:
        -: 3878:// This class generates an XML output file.
        -: 3879:class XmlUnitTestResultPrinter : public EmptyTestEventListener {
        -: 3880: public:
        -: 3881:  explicit XmlUnitTestResultPrinter(const char* output_file);
        -: 3882:
        -: 3883:  void OnTestIterationEnd(const UnitTest& unit_test, int iteration) override;
        -: 3884:  void ListTestsMatchingFilter(const std::vector<TestSuite*>& test_suites);
        -: 3885:
        -: 3886:  // Prints an XML summary of all unit tests.
        -: 3887:  static void PrintXmlTestsList(std::ostream* stream,
        -: 3888:                                const std::vector<TestSuite*>& test_suites);
        -: 3889:
        -: 3890: private:
        -: 3891:  // Is c a whitespace character that is normalized to a space character
        -: 3892:  // when it appears in an XML attribute value?
    #####: 3893:  static bool IsNormalizableWhitespace(char c) {
    #####: 3894:    return c == 0x9 || c == 0xA || c == 0xD;
    %%%%%: 3894-block  0
    %%%%%: 3894-block  1
    %%%%%: 3894-block  2
    %%%%%: 3894-block  3
    %%%%%: 3894-block  4
    %%%%%: 3894-block  5
        -: 3895:  }
        -: 3896:
        -: 3897:  // May c appear in a well-formed XML document?
    #####: 3898:  static bool IsValidXmlCharacter(char c) {
    #####: 3899:    return IsNormalizableWhitespace(c) || c >= 0x20;
    %%%%%: 3899-block  0
    %%%%%: 3899-block  1
    %%%%%: 3899-block  2
    %%%%%: 3899-block  3
    %%%%%: 3899-block  4
        -: 3900:  }
        -: 3901:
        -: 3902:  // Returns an XML-escaped copy of the input string str.  If
        -: 3903:  // is_attribute is true, the text is meant to appear as an attribute
        -: 3904:  // value, and normalizable whitespace is preserved by replacing it
        -: 3905:  // with character references.
        -: 3906:  static std::string EscapeXml(const std::string& str, bool is_attribute);
        -: 3907:
        -: 3908:  // Returns the given string with all characters invalid in XML removed.
        -: 3909:  static std::string RemoveInvalidXmlCharacters(const std::string& str);
        -: 3910:
        -: 3911:  // Convenience wrapper around EscapeXml when str is an attribute value.
    #####: 3912:  static std::string EscapeXmlAttribute(const std::string& str) {
    #####: 3913:    return EscapeXml(str, true);
    %%%%%: 3913-block  0
        -: 3914:  }
        -: 3915:
        -: 3916:  // Convenience wrapper around EscapeXml when str is not an attribute value.
        -: 3917:  static std::string EscapeXmlText(const char* str) {
        -: 3918:    return EscapeXml(str, false);
        -: 3919:  }
        -: 3920:
        -: 3921:  // Verifies that the given attribute belongs to the given element and
        -: 3922:  // streams the attribute as XML.
        -: 3923:  static void OutputXmlAttribute(std::ostream* stream,
        -: 3924:                                 const std::string& element_name,
        -: 3925:                                 const std::string& name,
        -: 3926:                                 const std::string& value);
        -: 3927:
        -: 3928:  // Streams an XML CDATA section, escaping invalid CDATA sequences as needed.
        -: 3929:  static void OutputXmlCDataSection(::std::ostream* stream, const char* data);
        -: 3930:
        -: 3931:  // Streams a test suite XML stanza containing the given test result.
        -: 3932:  //
        -: 3933:  // Requires: result.Failed()
        -: 3934:  static void OutputXmlTestSuiteForTestResult(::std::ostream* stream,
        -: 3935:                                              const TestResult& result);
        -: 3936:
        -: 3937:  // Streams an XML representation of a TestResult object.
        -: 3938:  static void OutputXmlTestResult(::std::ostream* stream,
        -: 3939:                                  const TestResult& result);
        -: 3940:
        -: 3941:  // Streams an XML representation of a TestInfo object.
        -: 3942:  static void OutputXmlTestInfo(::std::ostream* stream,
        -: 3943:                                const char* test_suite_name,
        -: 3944:                                const TestInfo& test_info);
        -: 3945:
        -: 3946:  // Prints an XML representation of a TestSuite object
        -: 3947:  static void PrintXmlTestSuite(::std::ostream* stream,
        -: 3948:                                const TestSuite& test_suite);
        -: 3949:
        -: 3950:  // Prints an XML summary of unit_test to output stream out.
        -: 3951:  static void PrintXmlUnitTest(::std::ostream* stream,
        -: 3952:                               const UnitTest& unit_test);
        -: 3953:
        -: 3954:  // Produces a string representing the test properties in a result as space
        -: 3955:  // delimited XML attributes based on the property key="value" pairs.
        -: 3956:  // When the std::string is not empty, it includes a space at the beginning,
        -: 3957:  // to delimit this attribute from prior attributes.
        -: 3958:  static std::string TestPropertiesAsXmlAttributes(const TestResult& result);
        -: 3959:
        -: 3960:  // Streams an XML representation of the test properties of a TestResult
        -: 3961:  // object.
        -: 3962:  static void OutputXmlTestProperties(std::ostream* stream,
        -: 3963:                                      const TestResult& result);
        -: 3964:
        -: 3965:  // The output file.
        -: 3966:  const std::string output_file_;
        -: 3967:
        -: 3968:  GTEST_DISALLOW_COPY_AND_ASSIGN_(XmlUnitTestResultPrinter);
        -: 3969:};
        -: 3970:
        -: 3971:// Creates a new XmlUnitTestResultPrinter.
    #####: 3972:XmlUnitTestResultPrinter::XmlUnitTestResultPrinter(const char* output_file)
    #####: 3973:    : output_file_(output_file) {
    %%%%%: 3973-block  0
    %%%%%: 3973-block  1
    $$$$$: 3973-block  2
    $$$$$: 3973-block  3
    $$$$$: 3973-block  4
    $$$$$: 3973-block  5
    #####: 3974:  if (output_file_.empty()) {
    #####: 3975:    GTEST_LOG_(FATAL) << "XML output file may not be null";
    %%%%%: 3975-block  0
    %%%%%: 3975-block  1
    %%%%%: 3975-block  2
    $$$$$: 3975-block  3
    $$$$$: 3975-block  4
        -: 3976:  }
    #####: 3977:}
    %%%%%: 3977-block  0
        -: 3978:
        -: 3979:// Called after the unit test ends.
    #####: 3980:void XmlUnitTestResultPrinter::OnTestIterationEnd(const UnitTest& unit_test,
        -: 3981:                                                  int /*iteration*/) {
    #####: 3982:  FILE* xmlout = OpenFileForWriting(output_file_);
    %%%%%: 3982-block  0
    #####: 3983:  std::stringstream stream;
    %%%%%: 3983-block  0
    %%%%%: 3983-block  1
    $$$$$: 3983-block  2
    #####: 3984:  PrintXmlUnitTest(&stream, unit_test);
    %%%%%: 3984-block  0
    #####: 3985:  fprintf(xmlout, "%s", StringStreamToString(&stream).c_str());
    %%%%%: 3985-block  0
    %%%%%: 3985-block  1
    %%%%%: 3985-block  2
    $$$$$: 3985-block  3
    $$$$$: 3985-block  4
    #####: 3986:  fclose(xmlout);
    #####: 3987:}
        -: 3988:
    #####: 3989:void XmlUnitTestResultPrinter::ListTestsMatchingFilter(
        -: 3990:    const std::vector<TestSuite*>& test_suites) {
    #####: 3991:  FILE* xmlout = OpenFileForWriting(output_file_);
    %%%%%: 3991-block  0
    #####: 3992:  std::stringstream stream;
    %%%%%: 3992-block  0
    %%%%%: 3992-block  1
    $$$$$: 3992-block  2
    #####: 3993:  PrintXmlTestsList(&stream, test_suites);
    %%%%%: 3993-block  0
    #####: 3994:  fprintf(xmlout, "%s", StringStreamToString(&stream).c_str());
    %%%%%: 3994-block  0
    %%%%%: 3994-block  1
    %%%%%: 3994-block  2
    $$$$$: 3994-block  3
    $$$$$: 3994-block  4
    #####: 3995:  fclose(xmlout);
    #####: 3996:}
        -: 3997:
        -: 3998:// Returns an XML-escaped copy of the input string str.  If is_attribute
        -: 3999:// is true, the text is meant to appear as an attribute value, and
        -: 4000:// normalizable whitespace is preserved by replacing it with character
        -: 4001:// references.
        -: 4002://
        -: 4003:// Invalid XML characters in str, if any, are stripped from the output.
        -: 4004:// It is expected that most, if not all, of the text processed by this
        -: 4005:// module will consist of ordinary English text.
        -: 4006:// If this module is ever modified to produce version 1.1 XML output,
        -: 4007:// most invalid characters can be retained using character references.
    #####: 4008:std::string XmlUnitTestResultPrinter::EscapeXml(
        -: 4009:    const std::string& str, bool is_attribute) {
    #####: 4010:  Message m;
    %%%%%: 4010-block  0
    %%%%%: 4010-block  1
    $$$$$: 4010-block  2
        -: 4011:
    #####: 4012:  for (size_t i = 0; i < str.size(); ++i) {
    %%%%%: 4012-block  0
    %%%%%: 4012-block  1
    %%%%%: 4012-block  2
    #####: 4013:    const char ch = str[i];
    %%%%%: 4013-block  0
    #####: 4014:    switch (ch) {
    #####: 4015:      case '<':
    #####: 4016:        m << "&lt;";
    %%%%%: 4016-block  0
    #####: 4017:        break;
    %%%%%: 4017-block  0
    #####: 4018:      case '>':
    #####: 4019:        m << "&gt;";
    %%%%%: 4019-block  0
    #####: 4020:        break;
    %%%%%: 4020-block  0
    #####: 4021:      case '&':
    #####: 4022:        m << "&amp;";
    %%%%%: 4022-block  0
    #####: 4023:        break;
    %%%%%: 4023-block  0
    #####: 4024:      case '\'':
    #####: 4025:        if (is_attribute)
    %%%%%: 4025-block  0
    #####: 4026:          m << "&apos;";
    %%%%%: 4026-block  0
        -: 4027:        else
    #####: 4028:          m << '\'';
    %%%%%: 4028-block  0
    %%%%%: 4028-block  1
    $$$$$: 4028-block  2
    #####: 4029:        break;
    %%%%%: 4029-block  0
    #####: 4030:      case '"':
    #####: 4031:        if (is_attribute)
    %%%%%: 4031-block  0
    #####: 4032:          m << "&quot;";
    %%%%%: 4032-block  0
        -: 4033:        else
    #####: 4034:          m << '"';
    %%%%%: 4034-block  0
    %%%%%: 4034-block  1
    $$$$$: 4034-block  2
    #####: 4035:        break;
    %%%%%: 4035-block  0
    #####: 4036:      default:
    #####: 4037:        if (IsValidXmlCharacter(ch)) {
    %%%%%: 4037-block  0
    #####: 4038:          if (is_attribute && IsNormalizableWhitespace(ch))
    %%%%%: 4038-block  0
    %%%%%: 4038-block  1
    %%%%%: 4038-block  2
    %%%%%: 4038-block  3
    %%%%%: 4038-block  4
    #####: 4039:            m << "&#x" << String::FormatByte(static_cast<unsigned char>(ch))
    %%%%%: 4039-block  0
    %%%%%: 4039-block  1
    %%%%%: 4039-block  2
    %%%%%: 4039-block  3
    $$$$$: 4039-block  4
    $$$$$: 4039-block  5
    #####: 4040:              << ";";
    %%%%%: 4040-block  0
        -: 4041:          else
    #####: 4042:            m << ch;
    %%%%%: 4042-block  0
        -: 4043:        }
    #####: 4044:        break;
    %%%%%: 4044-block  0
        -: 4045:    }
        -: 4046:  }
        -: 4047:
    #####: 4048:  return m.GetString();
    %%%%%: 4048-block  0
    %%%%%: 4048-block  1
        -: 4049:}
        -: 4050:
        -: 4051:// Returns the given string with all characters invalid in XML removed.
        -: 4052:// Currently invalid characters are dropped from the string. An
        -: 4053:// alternative is to replace them with certain characters such as . or ?.
    #####: 4054:std::string XmlUnitTestResultPrinter::RemoveInvalidXmlCharacters(
        -: 4055:    const std::string& str) {
    #####: 4056:  std::string output;
    %%%%%: 4056-block  0
    #####: 4057:  output.reserve(str.size());
    #####: 4058:  for (std::string::const_iterator it = str.begin(); it != str.end(); ++it)
    %%%%%: 4058-block  0
    %%%%%: 4058-block  1
    %%%%%: 4058-block  2
    #####: 4059:    if (IsValidXmlCharacter(*it))
    %%%%%: 4059-block  0
    #####: 4060:      output.push_back(*it);
    %%%%%: 4060-block  0
        -: 4061:
    #####: 4062:  return output;
    %%%%%: 4062-block  0
    %%%%%: 4062-block  1
        -: 4063:}
        -: 4064:
        -: 4065:// The following routines generate an XML representation of a UnitTest
        -: 4066:// object.
        -: 4067:// GOOGLETEST_CM0009 DO NOT DELETE
        -: 4068://
        -: 4069:// This is how Google Test concepts map to the DTD:
        -: 4070://
        -: 4071:// <testsuites name="AllTests">        <-- corresponds to a UnitTest object
        -: 4072://   <testsuite name="testcase-name">  <-- corresponds to a TestSuite object
        -: 4073://     <testcase name="test-name">     <-- corresponds to a TestInfo object
        -: 4074://       <failure message="...">...</failure>
        -: 4075://       <failure message="...">...</failure>
        -: 4076://       <failure message="...">...</failure>
        -: 4077://                                     <-- individual assertion failures
        -: 4078://     </testcase>
        -: 4079://   </testsuite>
        -: 4080:// </testsuites>
        -: 4081:
        -: 4082:// Formats the given time in milliseconds as seconds.
    #####: 4083:std::string FormatTimeInMillisAsSeconds(TimeInMillis ms) {
    #####: 4084:  ::std::stringstream ss;
    %%%%%: 4084-block  0
    %%%%%: 4084-block  1
    $$$$$: 4084-block  2
    #####: 4085:  ss << (static_cast<double>(ms) * 1e-3);
    %%%%%: 4085-block  0
    #####: 4086:  return ss.str();
    %%%%%: 4086-block  0
    %%%%%: 4086-block  1
        -: 4087:}
        -: 4088:
    #####: 4089:static bool PortableLocaltime(time_t seconds, struct tm* out) {
        -: 4090:#if defined(_MSC_VER)
        -: 4091:  return localtime_s(out, &seconds) == 0;
        -: 4092:#elif defined(__MINGW32__) || defined(__MINGW64__)
        -: 4093:  // MINGW <time.h> provides neither localtime_r nor localtime_s, but uses
        -: 4094:  // Windows' localtime(), which has a thread-local tm buffer.
        -: 4095:  struct tm* tm_ptr = localtime(&seconds);  // NOLINT
        -: 4096:  if (tm_ptr == nullptr) return false;
        -: 4097:  *out = *tm_ptr;
        -: 4098:  return true;
        -: 4099:#else
    #####: 4100:  return localtime_r(&seconds, out) != nullptr;
    %%%%%: 4100-block  0
        -: 4101:#endif
        -: 4102:}
        -: 4103:
        -: 4104:// Converts the given epoch time in milliseconds to a date string in the ISO
        -: 4105:// 8601 format, without the timezone information.
    #####: 4106:std::string FormatEpochTimeInMillisAsIso8601(TimeInMillis ms) {
        -: 4107:  struct tm time_struct;
    #####: 4108:  if (!PortableLocaltime(static_cast<time_t>(ms / 1000), &time_struct))
    %%%%%: 4108-block  0
    #####: 4109:    return "";
    %%%%%: 4109-block  0
    %%%%%: 4109-block  1
    $$$$$: 4109-block  2
    $$$$$: 4109-block  3
        -: 4110:  // YYYY-MM-DDThh:mm:ss.sss
    #####: 4111:  return StreamableToString(time_struct.tm_year + 1900) + "-" +
    %%%%%: 4111-block  0
    %%%%%: 4111-block  1
    %%%%%: 4111-block  2
    $$$$$: 4111-block  3
    $$$$$: 4111-block  4
    $$$$$: 4111-block  5
    $$$$$: 4111-block  6
    $$$$$: 4111-block  7
    $$$$$: 4111-block  8
    $$$$$: 4111-block  9
    #####: 4112:      String::FormatIntWidth2(time_struct.tm_mon + 1) + "-" +
    %%%%%: 4112-block  0
    %%%%%: 4112-block  1
    %%%%%: 4112-block  2
    $$$$$: 4112-block  3
    $$$$$: 4112-block  4
    $$$$$: 4112-block  5
    $$$$$: 4112-block  6
    $$$$$: 4112-block  7
    $$$$$: 4112-block  8
    #####: 4113:      String::FormatIntWidth2(time_struct.tm_mday) + "T" +
    %%%%%: 4113-block  0
    %%%%%: 4113-block  1
    %%%%%: 4113-block  2
    $$$$$: 4113-block  3
    $$$$$: 4113-block  4
    $$$$$: 4113-block  5
    $$$$$: 4113-block  6
    $$$$$: 4113-block  7
    $$$$$: 4113-block  8
    #####: 4114:      String::FormatIntWidth2(time_struct.tm_hour) + ":" +
    %%%%%: 4114-block  0
    %%%%%: 4114-block  1
    %%%%%: 4114-block  2
    $$$$$: 4114-block  3
    $$$$$: 4114-block  4
    $$$$$: 4114-block  5
    $$$$$: 4114-block  6
    $$$$$: 4114-block  7
    $$$$$: 4114-block  8
    #####: 4115:      String::FormatIntWidth2(time_struct.tm_min) + ":" +
    %%%%%: 4115-block  0
    %%%%%: 4115-block  1
    %%%%%: 4115-block  2
    $$$$$: 4115-block  3
    $$$$$: 4115-block  4
    $$$$$: 4115-block  5
    $$$$$: 4115-block  6
    $$$$$: 4115-block  7
    $$$$$: 4115-block  8
    #####: 4116:      String::FormatIntWidth2(time_struct.tm_sec) + "." +
    %%%%%: 4116-block  0
    %%%%%: 4116-block  1
    %%%%%: 4116-block  2
    $$$$$: 4116-block  3
    $$$$$: 4116-block  4
    $$$$$: 4116-block  5
    $$$$$: 4116-block  6
    #####: 4117:      String::FormatIntWidthN(static_cast<int>(ms % 1000), 3);
    %%%%%: 4117-block  0
    %%%%%: 4117-block  1
    $$$$$: 4117-block  2
    $$$$$: 4117-block  3
        -: 4118:}
        -: 4119:
        -: 4120:// Streams an XML CDATA section, escaping invalid CDATA sequences as needed.
    #####: 4121:void XmlUnitTestResultPrinter::OutputXmlCDataSection(::std::ostream* stream,
        -: 4122:                                                     const char* data) {
    #####: 4123:  const char* segment = data;
    #####: 4124:  *stream << "<![CDATA[";
    %%%%%: 4124-block  0
        -: 4125:  for (;;) {
    #####: 4126:    const char* const next_segment = strstr(segment, "]]>");
    #####: 4127:    if (next_segment != nullptr) {
    %%%%%: 4127-block  0
        -: 4128:      stream->write(
    #####: 4129:          segment, static_cast<std::streamsize>(next_segment - segment));
    %%%%%: 4129-block  0
    #####: 4130:      *stream << "]]>]]&gt;<![CDATA[";
    #####: 4131:      segment = next_segment + strlen("]]>");
        -: 4132:    } else {
    #####: 4133:      *stream << segment;
    %%%%%: 4133-block  0
    #####: 4134:      break;
        -: 4135:    }
    #####: 4136:  }
    %%%%%: 4136-block  0
    #####: 4137:  *stream << "]]>";
    %%%%%: 4137-block  0
    #####: 4138:}
        -: 4139:
    #####: 4140:void XmlUnitTestResultPrinter::OutputXmlAttribute(
        -: 4141:    std::ostream* stream,
        -: 4142:    const std::string& element_name,
        -: 4143:    const std::string& name,
        -: 4144:    const std::string& value) {
        -: 4145:  const std::vector<std::string>& allowed_names =
    #####: 4146:      GetReservedOutputAttributesForElement(element_name);
    %%%%%: 4146-block  0
    $$$$$: 4146-block  1
        -: 4147:
    #####: 4148:  GTEST_CHECK_(std::find(allowed_names.begin(), allowed_names.end(), name) !=
    %%%%%: 4148-block  0
    %%%%%: 4148-block  1
    %%%%%: 4148-block  2
    %%%%%: 4148-block  3
    %%%%%: 4148-block  4
    $$$$$: 4148-block  5
    $$$$$: 4148-block  6
    $$$$$: 4148-block  7
        -: 4149:                   allowed_names.end())
        -: 4150:      << "Attribute " << name << " is not allowed for element <" << element_name
    #####: 4151:      << ">.";
    %%%%%: 4151-block  0
    %%%%%: 4151-block  1
    %%%%%: 4151-block  2
    %%%%%: 4151-block  3
    %%%%%: 4151-block  4
        -: 4152:
    #####: 4153:  *stream << " " << name << "=\"" << EscapeXmlAttribute(value) << "\"";
    %%%%%: 4153-block  0
    %%%%%: 4153-block  1
    %%%%%: 4153-block  2
    %%%%%: 4153-block  3
    %%%%%: 4153-block  4
    %%%%%: 4153-block  5
    %%%%%: 4153-block  6
    $$$$$: 4153-block  7
    $$$$$: 4153-block  8
    #####: 4154:}
        -: 4155:
        -: 4156:// Streams a test suite XML stanza containing the given test result.
    #####: 4157:void XmlUnitTestResultPrinter::OutputXmlTestSuiteForTestResult(
        -: 4158:    ::std::ostream* stream, const TestResult& result) {
        -: 4159:  // Output the boilerplate for a minimal test suite with one test.
    #####: 4160:  *stream << "  <testsuite";
    %%%%%: 4160-block  0
    #####: 4161:  OutputXmlAttribute(stream, "testsuite", "name", "NonTestSuiteFailure");
    %%%%%: 4161-block  0
    %%%%%: 4161-block  1
    %%%%%: 4161-block  2
    %%%%%: 4161-block  3
    $$$$$: 4161-block  4
    $$$$$: 4161-block  5
    $$$$$: 4161-block  6
    $$$$$: 4161-block  7
    $$$$$: 4161-block  8
    $$$$$: 4161-block  9
    $$$$$: 4161-block 10
    $$$$$: 4161-block 11
    $$$$$: 4161-block 12
    $$$$$: 4161-block 13
    $$$$$: 4161-block 14
    $$$$$: 4161-block 15
    #####: 4162:  OutputXmlAttribute(stream, "testsuite", "tests", "1");
    %%%%%: 4162-block  0
    %%%%%: 4162-block  1
    %%%%%: 4162-block  2
    %%%%%: 4162-block  3
    $$$$$: 4162-block  4
    $$$$$: 4162-block  5
    $$$$$: 4162-block  6
    $$$$$: 4162-block  7
    $$$$$: 4162-block  8
    $$$$$: 4162-block  9
    $$$$$: 4162-block 10
    $$$$$: 4162-block 11
    $$$$$: 4162-block 12
    $$$$$: 4162-block 13
    $$$$$: 4162-block 14
    $$$$$: 4162-block 15
    #####: 4163:  OutputXmlAttribute(stream, "testsuite", "failures", "1");
    %%%%%: 4163-block  0
    %%%%%: 4163-block  1
    %%%%%: 4163-block  2
    %%%%%: 4163-block  3
    $$$$$: 4163-block  4
    $$$$$: 4163-block  5
    $$$$$: 4163-block  6
    $$$$$: 4163-block  7
    $$$$$: 4163-block  8
    $$$$$: 4163-block  9
    $$$$$: 4163-block 10
    $$$$$: 4163-block 11
    $$$$$: 4163-block 12
    $$$$$: 4163-block 13
    $$$$$: 4163-block 14
    $$$$$: 4163-block 15
    #####: 4164:  OutputXmlAttribute(stream, "testsuite", "disabled", "0");
    %%%%%: 4164-block  0
    %%%%%: 4164-block  1
    %%%%%: 4164-block  2
    %%%%%: 4164-block  3
    $$$$$: 4164-block  4
    $$$$$: 4164-block  5
    $$$$$: 4164-block  6
    $$$$$: 4164-block  7
    $$$$$: 4164-block  8
    $$$$$: 4164-block  9
    $$$$$: 4164-block 10
    $$$$$: 4164-block 11
    $$$$$: 4164-block 12
    $$$$$: 4164-block 13
    $$$$$: 4164-block 14
    $$$$$: 4164-block 15
    #####: 4165:  OutputXmlAttribute(stream, "testsuite", "skipped", "0");
    %%%%%: 4165-block  0
    %%%%%: 4165-block  1
    %%%%%: 4165-block  2
    %%%%%: 4165-block  3
    $$$$$: 4165-block  4
    $$$$$: 4165-block  5
    $$$$$: 4165-block  6
    $$$$$: 4165-block  7
    $$$$$: 4165-block  8
    $$$$$: 4165-block  9
    $$$$$: 4165-block 10
    $$$$$: 4165-block 11
    $$$$$: 4165-block 12
    $$$$$: 4165-block 13
    $$$$$: 4165-block 14
    $$$$$: 4165-block 15
    #####: 4166:  OutputXmlAttribute(stream, "testsuite", "errors", "0");
    %%%%%: 4166-block  0
    %%%%%: 4166-block  1
    %%%%%: 4166-block  2
    %%%%%: 4166-block  3
    $$$$$: 4166-block  4
    $$$$$: 4166-block  5
    $$$$$: 4166-block  6
    $$$$$: 4166-block  7
    $$$$$: 4166-block  8
    $$$$$: 4166-block  9
    $$$$$: 4166-block 10
    $$$$$: 4166-block 11
    $$$$$: 4166-block 12
    $$$$$: 4166-block 13
    $$$$$: 4166-block 14
    $$$$$: 4166-block 15
    #####: 4167:  OutputXmlAttribute(stream, "testsuite", "time",
    %%%%%: 4167-block  0
    %%%%%: 4167-block  1
    %%%%%: 4167-block  2
    $$$$$: 4167-block  3
    $$$$$: 4167-block  4
    $$$$$: 4167-block  5
    $$$$$: 4167-block  6
    $$$$$: 4167-block  7
    $$$$$: 4167-block  8
    $$$$$: 4167-block  9
    $$$$$: 4167-block 10
    #####: 4168:                     FormatTimeInMillisAsSeconds(result.elapsed_time()));
    $$$$$: 4168-block  0
    $$$$$: 4168-block  1
    #####: 4169:  OutputXmlAttribute(
    %%%%%: 4169-block  0
    %%%%%: 4169-block  1
    %%%%%: 4169-block  2
    $$$$$: 4169-block  3
    $$$$$: 4169-block  4
    $$$$$: 4169-block  5
    $$$$$: 4169-block  6
    $$$$$: 4169-block  7
    $$$$$: 4169-block  8
    $$$$$: 4169-block  9
    $$$$$: 4169-block 10
        -: 4170:      stream, "testsuite", "timestamp",
    #####: 4171:      FormatEpochTimeInMillisAsIso8601(result.start_timestamp()));
    $$$$$: 4171-block  0
    $$$$$: 4171-block  1
    #####: 4172:  *stream << ">";
        -: 4173:
        -: 4174:  // Output the boilerplate for a minimal test case with a single test.
    #####: 4175:  *stream << "    <testcase";
    #####: 4176:  OutputXmlAttribute(stream, "testcase", "name", "");
    %%%%%: 4176-block  0
    %%%%%: 4176-block  1
    %%%%%: 4176-block  2
    %%%%%: 4176-block  3
    $$$$$: 4176-block  4
    $$$$$: 4176-block  5
    $$$$$: 4176-block  6
    $$$$$: 4176-block  7
    $$$$$: 4176-block  8
    $$$$$: 4176-block  9
    $$$$$: 4176-block 10
    $$$$$: 4176-block 11
    $$$$$: 4176-block 12
    $$$$$: 4176-block 13
    $$$$$: 4176-block 14
    $$$$$: 4176-block 15
    #####: 4177:  OutputXmlAttribute(stream, "testcase", "status", "run");
    %%%%%: 4177-block  0
    %%%%%: 4177-block  1
    %%%%%: 4177-block  2
    %%%%%: 4177-block  3
    $$$$$: 4177-block  4
    $$$$$: 4177-block  5
    $$$$$: 4177-block  6
    $$$$$: 4177-block  7
    $$$$$: 4177-block  8
    $$$$$: 4177-block  9
    $$$$$: 4177-block 10
    $$$$$: 4177-block 11
    $$$$$: 4177-block 12
    $$$$$: 4177-block 13
    $$$$$: 4177-block 14
    $$$$$: 4177-block 15
    #####: 4178:  OutputXmlAttribute(stream, "testcase", "result", "completed");
    %%%%%: 4178-block  0
    %%%%%: 4178-block  1
    %%%%%: 4178-block  2
    %%%%%: 4178-block  3
    $$$$$: 4178-block  4
    $$$$$: 4178-block  5
    $$$$$: 4178-block  6
    $$$$$: 4178-block  7
    $$$$$: 4178-block  8
    $$$$$: 4178-block  9
    $$$$$: 4178-block 10
    $$$$$: 4178-block 11
    $$$$$: 4178-block 12
    $$$$$: 4178-block 13
    $$$$$: 4178-block 14
    $$$$$: 4178-block 15
    #####: 4179:  OutputXmlAttribute(stream, "testcase", "classname", "");
    %%%%%: 4179-block  0
    %%%%%: 4179-block  1
    %%%%%: 4179-block  2
    %%%%%: 4179-block  3
    $$$$$: 4179-block  4
    $$$$$: 4179-block  5
    $$$$$: 4179-block  6
    $$$$$: 4179-block  7
    $$$$$: 4179-block  8
    $$$$$: 4179-block  9
    $$$$$: 4179-block 10
    $$$$$: 4179-block 11
    $$$$$: 4179-block 12
    $$$$$: 4179-block 13
    $$$$$: 4179-block 14
    $$$$$: 4179-block 15
    #####: 4180:  OutputXmlAttribute(stream, "testcase", "time",
    %%%%%: 4180-block  0
    %%%%%: 4180-block  1
    %%%%%: 4180-block  2
    $$$$$: 4180-block  3
    $$$$$: 4180-block  4
    $$$$$: 4180-block  5
    $$$$$: 4180-block  6
    $$$$$: 4180-block  7
    $$$$$: 4180-block  8
    $$$$$: 4180-block  9
    $$$$$: 4180-block 10
    #####: 4181:                     FormatTimeInMillisAsSeconds(result.elapsed_time()));
    $$$$$: 4181-block  0
    $$$$$: 4181-block  1
    #####: 4182:  OutputXmlAttribute(
    %%%%%: 4182-block  0
    %%%%%: 4182-block  1
    %%%%%: 4182-block  2
    $$$$$: 4182-block  3
    $$$$$: 4182-block  4
    $$$$$: 4182-block  5
    $$$$$: 4182-block  6
    $$$$$: 4182-block  7
    $$$$$: 4182-block  8
    $$$$$: 4182-block  9
    $$$$$: 4182-block 10
        -: 4183:      stream, "testcase", "timestamp",
    #####: 4184:      FormatEpochTimeInMillisAsIso8601(result.start_timestamp()));
    $$$$$: 4184-block  0
        -: 4185:
        -: 4186:  // Output the actual test result.
    #####: 4187:  OutputXmlTestResult(stream, result);
        -: 4188:
        -: 4189:  // Complete the test suite.
    #####: 4190:  *stream << "  </testsuite>\n";
    #####: 4191:}
        -: 4192:
        -: 4193:// Prints an XML representation of a TestInfo object.
    #####: 4194:void XmlUnitTestResultPrinter::OutputXmlTestInfo(::std::ostream* stream,
        -: 4195:                                                 const char* test_suite_name,
        -: 4196:                                                 const TestInfo& test_info) {
    #####: 4197:  const TestResult& result = *test_info.result();
    %%%%%: 4197-block  0
    #####: 4198:  const std::string kTestsuite = "testcase";
    $$$$$: 4198-block  0
    $$$$$: 4198-block  1
        -: 4199:
    #####: 4200:  if (test_info.is_in_another_shard()) {
    #####: 4201:    return;
    %%%%%: 4201-block  0
        -: 4202:  }
        -: 4203:
    #####: 4204:  *stream << "    <testcase";
    %%%%%: 4204-block  0
    #####: 4205:  OutputXmlAttribute(stream, kTestsuite, "name", test_info.name());
    %%%%%: 4205-block  0
    %%%%%: 4205-block  1
    %%%%%: 4205-block  2
    %%%%%: 4205-block  3
    $$$$$: 4205-block  4
    $$$$$: 4205-block  5
    $$$$$: 4205-block  6
    $$$$$: 4205-block  7
    $$$$$: 4205-block  8
    $$$$$: 4205-block  9
    $$$$$: 4205-block 10
    $$$$$: 4205-block 11
        -: 4206:
    #####: 4207:  if (test_info.value_param() != nullptr) {
    #####: 4208:    OutputXmlAttribute(stream, kTestsuite, "value_param",
    %%%%%: 4208-block  0
    %%%%%: 4208-block  1
    %%%%%: 4208-block  2
    %%%%%: 4208-block  3
    $$$$$: 4208-block  4
    $$$$$: 4208-block  5
    $$$$$: 4208-block  6
    $$$$$: 4208-block  7
    $$$$$: 4208-block  8
    $$$$$: 4208-block  9
    $$$$$: 4208-block 10
    $$$$$: 4208-block 11
        -: 4209:                       test_info.value_param());
        -: 4210:  }
    #####: 4211:  if (test_info.type_param() != nullptr) {
    %%%%%: 4211-block  0
    #####: 4212:    OutputXmlAttribute(stream, kTestsuite, "type_param",
    %%%%%: 4212-block  0
    %%%%%: 4212-block  1
    %%%%%: 4212-block  2
    %%%%%: 4212-block  3
    $$$$$: 4212-block  4
    $$$$$: 4212-block  5
    $$$$$: 4212-block  6
    $$$$$: 4212-block  7
    $$$$$: 4212-block  8
    $$$$$: 4212-block  9
    $$$$$: 4212-block 10
    $$$$$: 4212-block 11
        -: 4213:                       test_info.type_param());
        -: 4214:  }
    #####: 4215:  if (GTEST_FLAG(list_tests)) {
    %%%%%: 4215-block  0
    #####: 4216:    OutputXmlAttribute(stream, kTestsuite, "file", test_info.file());
    %%%%%: 4216-block  0
    %%%%%: 4216-block  1
    %%%%%: 4216-block  2
    %%%%%: 4216-block  3
    $$$$$: 4216-block  4
    $$$$$: 4216-block  5
    $$$$$: 4216-block  6
    $$$$$: 4216-block  7
    $$$$$: 4216-block  8
    $$$$$: 4216-block  9
    $$$$$: 4216-block 10
    $$$$$: 4216-block 11
    #####: 4217:    OutputXmlAttribute(stream, kTestsuite, "line",
    %%%%%: 4217-block  0
    %%%%%: 4217-block  1
    %%%%%: 4217-block  2
    $$$$$: 4217-block  3
    $$$$$: 4217-block  4
    $$$$$: 4217-block  5
    $$$$$: 4217-block  6
    #####: 4218:                       StreamableToString(test_info.line()));
    $$$$$: 4218-block  0
    $$$$$: 4218-block  1
    $$$$$: 4218-block  2
    #####: 4219:    *stream << " />\n";
    #####: 4220:    return;
    %%%%%: 4220-block  0
        -: 4221:  }
        -: 4222:
    #####: 4223:  OutputXmlAttribute(stream, kTestsuite, "status",
    %%%%%: 4223-block  0
    %%%%%: 4223-block  1
    %%%%%: 4223-block  2
    %%%%%: 4223-block  3
    %%%%%: 4223-block  4
    %%%%%: 4223-block  5
    %%%%%: 4223-block  6
    $$$$$: 4223-block  7
    $$$$$: 4223-block  8
    $$$$$: 4223-block  9
    $$$$$: 4223-block 10
    $$$$$: 4223-block 11
    $$$$$: 4223-block 12
    $$$$$: 4223-block 13
    $$$$$: 4223-block 14
    #####: 4224:                     test_info.should_run() ? "run" : "notrun");
    #####: 4225:  OutputXmlAttribute(stream, kTestsuite, "result",
    %%%%%: 4225-block  0
    %%%%%: 4225-block  1
    %%%%%: 4225-block  2
    %%%%%: 4225-block  3
    %%%%%: 4225-block  4
    %%%%%: 4225-block  5
    $$$$$: 4225-block  6
    $$$$$: 4225-block  7
    $$$$$: 4225-block  8
    $$$$$: 4225-block  9
    $$$$$: 4225-block 10
    $$$$$: 4225-block 11
    $$$$$: 4225-block 12
    $$$$$: 4225-block 13
    #####: 4226:                     test_info.should_run()
    #####: 4227:                         ? (result.Skipped() ? "skipped" : "completed")
    %%%%%: 4227-block  0
    %%%%%: 4227-block  1
    %%%%%: 4227-block  2
    %%%%%: 4227-block  3
        -: 4228:                         : "suppressed");
    #####: 4229:  OutputXmlAttribute(stream, kTestsuite, "time",
    %%%%%: 4229-block  0
    %%%%%: 4229-block  1
    %%%%%: 4229-block  2
    $$$$$: 4229-block  3
    $$$$$: 4229-block  4
    $$$$$: 4229-block  5
    $$$$$: 4229-block  6
    #####: 4230:                     FormatTimeInMillisAsSeconds(result.elapsed_time()));
    $$$$$: 4230-block  0
    $$$$$: 4230-block  1
    #####: 4231:  OutputXmlAttribute(
    %%%%%: 4231-block  0
    %%%%%: 4231-block  1
    %%%%%: 4231-block  2
    $$$$$: 4231-block  3
    $$$$$: 4231-block  4
    $$$$$: 4231-block  5
    $$$$$: 4231-block  6
        -: 4232:      stream, kTestsuite, "timestamp",
    #####: 4233:      FormatEpochTimeInMillisAsIso8601(result.start_timestamp()));
    $$$$$: 4233-block  0
    $$$$$: 4233-block  1
    #####: 4234:  OutputXmlAttribute(stream, kTestsuite, "classname", test_suite_name);
    %%%%%: 4234-block  0
    %%%%%: 4234-block  1
    %%%%%: 4234-block  2
    $$$$$: 4234-block  3
    $$$$$: 4234-block  4
    $$$$$: 4234-block  5
    $$$$$: 4234-block  6
    $$$$$: 4234-block  7
    $$$$$: 4234-block  8
    $$$$$: 4234-block  9
    $$$$$: 4234-block 10
        -: 4235:
    #####: 4236:  OutputXmlTestResult(stream, result);
        -: 4237:}
        -: 4238:
    #####: 4239:void XmlUnitTestResultPrinter::OutputXmlTestResult(::std::ostream* stream,
        -: 4240:                                                   const TestResult& result) {
    #####: 4241:  int failures = 0;
    #####: 4242:  int skips = 0;
    #####: 4243:  for (int i = 0; i < result.total_part_count(); ++i) {
    %%%%%: 4243-block  0
    %%%%%: 4243-block  1
    %%%%%: 4243-block  2
    #####: 4244:    const TestPartResult& part = result.GetTestPartResult(i);
    %%%%%: 4244-block  0
    #####: 4245:    if (part.failed()) {
    #####: 4246:      if (++failures == 1 && skips == 0) {
    %%%%%: 4246-block  0
    %%%%%: 4246-block  1
    %%%%%: 4246-block  2
    %%%%%: 4246-block  3
    %%%%%: 4246-block  4
    #####: 4247:        *stream << ">\n";
    %%%%%: 4247-block  0
        -: 4248:      }
        -: 4249:      const std::string location =
        -: 4250:          internal::FormatCompilerIndependentFileLocation(part.file_name(),
    #####: 4251:                                                          part.line_number());
    %%%%%: 4251-block  0
    $$$$$: 4251-block  1
    #####: 4252:      const std::string summary = location + "\n" + part.summary();
    %%%%%: 4252-block  0
    %%%%%: 4252-block  1
    $$$$$: 4252-block  2
    $$$$$: 4252-block  3
        -: 4253:      *stream << "      <failure message=\""
    #####: 4254:              << EscapeXmlAttribute(summary)
    %%%%%: 4254-block  0
    $$$$$: 4254-block  1
    $$$$$: 4254-block  2
    #####: 4255:              << "\" type=\"\">";
    %%%%%: 4255-block  0
    %%%%%: 4255-block  1
    %%%%%: 4255-block  2
    #####: 4256:      const std::string detail = location + "\n" + part.message();
    %%%%%: 4256-block  0
    %%%%%: 4256-block  1
    $$$$$: 4256-block  2
    $$$$$: 4256-block  3
    #####: 4257:      OutputXmlCDataSection(stream, RemoveInvalidXmlCharacters(detail).c_str());
    %%%%%: 4257-block  0
    %%%%%: 4257-block  1
    $$$$$: 4257-block  2
    $$$$$: 4257-block  3
    #####: 4258:      *stream << "</failure>\n";
    #####: 4259:    } else if (part.skipped()) {
    %%%%%: 4259-block  0
    #####: 4260:      if (++skips == 1 && failures == 0) {
    %%%%%: 4260-block  0
    %%%%%: 4260-block  1
    %%%%%: 4260-block  2
    %%%%%: 4260-block  3
    %%%%%: 4260-block  4
    #####: 4261:        *stream << ">\n";
    %%%%%: 4261-block  0
        -: 4262:      }
        -: 4263:      const std::string location =
        -: 4264:          internal::FormatCompilerIndependentFileLocation(part.file_name(),
    #####: 4265:                                                          part.line_number());
    %%%%%: 4265-block  0
    $$$$$: 4265-block  1
    #####: 4266:      const std::string summary = location + "\n" + part.summary();
    %%%%%: 4266-block  0
    %%%%%: 4266-block  1
    $$$$$: 4266-block  2
    $$$$$: 4266-block  3
        -: 4267:      *stream << "      <skipped message=\""
    #####: 4268:              << EscapeXmlAttribute(summary.c_str()) << "\">";
    %%%%%: 4268-block  0
    %%%%%: 4268-block  1
    %%%%%: 4268-block  2
    %%%%%: 4268-block  3
    %%%%%: 4268-block  4
    $$$$$: 4268-block  5
    $$$$$: 4268-block  6
    $$$$$: 4268-block  7
    $$$$$: 4268-block  8
    $$$$$: 4268-block  9
    $$$$$: 4268-block 10
    #####: 4269:      const std::string detail = location + "\n" + part.message();
    %%%%%: 4269-block  0
    %%%%%: 4269-block  1
    $$$$$: 4269-block  2
    $$$$$: 4269-block  3
    #####: 4270:      OutputXmlCDataSection(stream, RemoveInvalidXmlCharacters(detail).c_str());
    %%%%%: 4270-block  0
    %%%%%: 4270-block  1
    $$$$$: 4270-block  2
    $$$$$: 4270-block  3
    #####: 4271:      *stream << "</skipped>\n";
        -: 4272:    }
        -: 4273:  }
        -: 4274:
    #####: 4275:  if (failures == 0 && skips == 0 && result.test_property_count() == 0) {
    %%%%%: 4275-block  0
    %%%%%: 4275-block  1
    %%%%%: 4275-block  2
    %%%%%: 4275-block  3
    %%%%%: 4275-block  4
    %%%%%: 4275-block  5
    #####: 4276:    *stream << " />\n";
    %%%%%: 4276-block  0
        -: 4277:  } else {
    #####: 4278:    if (failures == 0 && skips == 0) {
    %%%%%: 4278-block  0
    %%%%%: 4278-block  1
    #####: 4279:      *stream << ">\n";
    %%%%%: 4279-block  0
        -: 4280:    }
    #####: 4281:    OutputXmlTestProperties(stream, result);
    %%%%%: 4281-block  0
    #####: 4282:    *stream << "    </testcase>\n";
        -: 4283:  }
    #####: 4284:}
    %%%%%: 4284-block  0
        -: 4285:
        -: 4286:// Prints an XML representation of a TestSuite object
    #####: 4287:void XmlUnitTestResultPrinter::PrintXmlTestSuite(std::ostream* stream,
        -: 4288:                                                 const TestSuite& test_suite) {
    #####: 4289:  const std::string kTestsuite = "testsuite";
    %%%%%: 4289-block  0
    %%%%%: 4289-block  1
    $$$$$: 4289-block  2
    $$$$$: 4289-block  3
    #####: 4290:  *stream << "  <" << kTestsuite;
    %%%%%: 4290-block  0
    #####: 4291:  OutputXmlAttribute(stream, kTestsuite, "name", test_suite.name());
    %%%%%: 4291-block  0
    %%%%%: 4291-block  1
    %%%%%: 4291-block  2
    %%%%%: 4291-block  3
    $$$$$: 4291-block  4
    $$$$$: 4291-block  5
    $$$$$: 4291-block  6
    $$$$$: 4291-block  7
    $$$$$: 4291-block  8
    $$$$$: 4291-block  9
    $$$$$: 4291-block 10
    $$$$$: 4291-block 11
    #####: 4292:  OutputXmlAttribute(stream, kTestsuite, "tests",
    %%%%%: 4292-block  0
    %%%%%: 4292-block  1
    %%%%%: 4292-block  2
    $$$$$: 4292-block  3
    $$$$$: 4292-block  4
    $$$$$: 4292-block  5
    $$$$$: 4292-block  6
    #####: 4293:                     StreamableToString(test_suite.reportable_test_count()));
    %%%%%: 4293-block  0
    $$$$$: 4293-block  1
    $$$$$: 4293-block  2
    $$$$$: 4293-block  3
    #####: 4294:  if (!GTEST_FLAG(list_tests)) {
    #####: 4295:    OutputXmlAttribute(stream, kTestsuite, "failures",
    %%%%%: 4295-block  0
    %%%%%: 4295-block  1
    %%%%%: 4295-block  2
    $$$$$: 4295-block  3
    $$$$$: 4295-block  4
    $$$$$: 4295-block  5
    $$$$$: 4295-block  6
    #####: 4296:                       StreamableToString(test_suite.failed_test_count()));
    %%%%%: 4296-block  0
    %%%%%: 4296-block  1
    $$$$$: 4296-block  2
    $$$$$: 4296-block  3
    $$$$$: 4296-block  4
    #####: 4297:    OutputXmlAttribute(
    %%%%%: 4297-block  0
    %%%%%: 4297-block  1
    %%%%%: 4297-block  2
    $$$$$: 4297-block  3
    $$$$$: 4297-block  4
    $$$$$: 4297-block  5
    $$$$$: 4297-block  6
        -: 4298:        stream, kTestsuite, "disabled",
    #####: 4299:        StreamableToString(test_suite.reportable_disabled_test_count()));
    %%%%%: 4299-block  0
    $$$$$: 4299-block  1
    $$$$$: 4299-block  2
    $$$$$: 4299-block  3
    #####: 4300:    OutputXmlAttribute(stream, kTestsuite, "skipped",
    %%%%%: 4300-block  0
    %%%%%: 4300-block  1
    %%%%%: 4300-block  2
    $$$$$: 4300-block  3
    $$$$$: 4300-block  4
    $$$$$: 4300-block  5
    $$$$$: 4300-block  6
    #####: 4301:                       StreamableToString(test_suite.skipped_test_count()));
    %%%%%: 4301-block  0
    $$$$$: 4301-block  1
    $$$$$: 4301-block  2
    $$$$$: 4301-block  3
        -: 4302:
    #####: 4303:    OutputXmlAttribute(stream, kTestsuite, "errors", "0");
    %%%%%: 4303-block  0
    %%%%%: 4303-block  1
    %%%%%: 4303-block  2
    $$$$$: 4303-block  3
    $$$$$: 4303-block  4
    $$$$$: 4303-block  5
    $$$$$: 4303-block  6
    $$$$$: 4303-block  7
    $$$$$: 4303-block  8
    $$$$$: 4303-block  9
    $$$$$: 4303-block 10
        -: 4304:
    #####: 4305:    OutputXmlAttribute(stream, kTestsuite, "time",
    %%%%%: 4305-block  0
    %%%%%: 4305-block  1
    %%%%%: 4305-block  2
    $$$$$: 4305-block  3
    $$$$$: 4305-block  4
    $$$$$: 4305-block  5
    $$$$$: 4305-block  6
    #####: 4306:                       FormatTimeInMillisAsSeconds(test_suite.elapsed_time()));
    $$$$$: 4306-block  0
    $$$$$: 4306-block  1
    #####: 4307:    OutputXmlAttribute(
    %%%%%: 4307-block  0
    %%%%%: 4307-block  1
    %%%%%: 4307-block  2
    $$$$$: 4307-block  3
    $$$$$: 4307-block  4
    $$$$$: 4307-block  5
    $$$$$: 4307-block  6
        -: 4308:        stream, kTestsuite, "timestamp",
    #####: 4309:        FormatEpochTimeInMillisAsIso8601(test_suite.start_timestamp()));
    $$$$$: 4309-block  0
    $$$$$: 4309-block  1
    #####: 4310:    *stream << TestPropertiesAsXmlAttributes(test_suite.ad_hoc_test_result());
    %%%%%: 4310-block  0
    %%%%%: 4310-block  1
    $$$$$: 4310-block  2
    $$$$$: 4310-block  3
        -: 4311:  }
    #####: 4312:  *stream << ">\n";
    %%%%%: 4312-block  0
    #####: 4313:  for (int i = 0; i < test_suite.total_test_count(); ++i) {
    %%%%%: 4313-block  0
    %%%%%: 4313-block  1
    %%%%%: 4313-block  2
    #####: 4314:    if (test_suite.GetTestInfo(i)->is_reportable())
    %%%%%: 4314-block  0
    %%%%%: 4314-block  1
    #####: 4315:      OutputXmlTestInfo(stream, test_suite.name(), *test_suite.GetTestInfo(i));
    %%%%%: 4315-block  0
    %%%%%: 4315-block  1
        -: 4316:  }
    #####: 4317:  *stream << "  </" << kTestsuite << ">\n";
    %%%%%: 4317-block  0
    %%%%%: 4317-block  1
    %%%%%: 4317-block  2
    #####: 4318:}
        -: 4319:
        -: 4320:// Prints an XML summary of unit_test to output stream out.
    #####: 4321:void XmlUnitTestResultPrinter::PrintXmlUnitTest(std::ostream* stream,
        -: 4322:                                                const UnitTest& unit_test) {
    #####: 4323:  const std::string kTestsuites = "testsuites";
    %%%%%: 4323-block  0
    %%%%%: 4323-block  1
    $$$$$: 4323-block  2
    $$$$$: 4323-block  3
        -: 4324:
    #####: 4325:  *stream << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
    #####: 4326:  *stream << "<" << kTestsuites;
    %%%%%: 4326-block  0
    %%%%%: 4326-block  1
        -: 4327:
    #####: 4328:  OutputXmlAttribute(stream, kTestsuites, "tests",
    %%%%%: 4328-block  0
    %%%%%: 4328-block  1
    %%%%%: 4328-block  2
    $$$$$: 4328-block  3
    $$$$$: 4328-block  4
    $$$$$: 4328-block  5
    $$$$$: 4328-block  6
    #####: 4329:                     StreamableToString(unit_test.reportable_test_count()));
    %%%%%: 4329-block  0
    %%%%%: 4329-block  1
    $$$$$: 4329-block  2
    $$$$$: 4329-block  3
    $$$$$: 4329-block  4
    #####: 4330:  OutputXmlAttribute(stream, kTestsuites, "failures",
    %%%%%: 4330-block  0
    %%%%%: 4330-block  1
    %%%%%: 4330-block  2
    $$$$$: 4330-block  3
    $$$$$: 4330-block  4
    $$$$$: 4330-block  5
    $$$$$: 4330-block  6
    #####: 4331:                     StreamableToString(unit_test.failed_test_count()));
    %%%%%: 4331-block  0
    $$$$$: 4331-block  1
    $$$$$: 4331-block  2
    $$$$$: 4331-block  3
    #####: 4332:  OutputXmlAttribute(
    %%%%%: 4332-block  0
    %%%%%: 4332-block  1
    %%%%%: 4332-block  2
    $$$$$: 4332-block  3
    $$$$$: 4332-block  4
    $$$$$: 4332-block  5
    $$$$$: 4332-block  6
        -: 4333:      stream, kTestsuites, "disabled",
    #####: 4334:      StreamableToString(unit_test.reportable_disabled_test_count()));
    %%%%%: 4334-block  0
    $$$$$: 4334-block  1
    $$$$$: 4334-block  2
    $$$$$: 4334-block  3
    #####: 4335:  OutputXmlAttribute(stream, kTestsuites, "errors", "0");
    %%%%%: 4335-block  0
    %%%%%: 4335-block  1
    %%%%%: 4335-block  2
    $$$$$: 4335-block  3
    $$$$$: 4335-block  4
    $$$$$: 4335-block  5
    $$$$$: 4335-block  6
    $$$$$: 4335-block  7
    $$$$$: 4335-block  8
    $$$$$: 4335-block  9
    $$$$$: 4335-block 10
    #####: 4336:  OutputXmlAttribute(stream, kTestsuites, "time",
    %%%%%: 4336-block  0
    %%%%%: 4336-block  1
    %%%%%: 4336-block  2
    $$$$$: 4336-block  3
    $$$$$: 4336-block  4
    $$$$$: 4336-block  5
    $$$$$: 4336-block  6
    #####: 4337:                     FormatTimeInMillisAsSeconds(unit_test.elapsed_time()));
    $$$$$: 4337-block  0
    $$$$$: 4337-block  1
    #####: 4338:  OutputXmlAttribute(
    %%%%%: 4338-block  0
    %%%%%: 4338-block  1
    %%%%%: 4338-block  2
    $$$$$: 4338-block  3
    $$$$$: 4338-block  4
    $$$$$: 4338-block  5
    $$$$$: 4338-block  6
        -: 4339:      stream, kTestsuites, "timestamp",
    #####: 4340:      FormatEpochTimeInMillisAsIso8601(unit_test.start_timestamp()));
    $$$$$: 4340-block  0
    $$$$$: 4340-block  1
        -: 4341:
    #####: 4342:  if (GTEST_FLAG(shuffle)) {
    #####: 4343:    OutputXmlAttribute(stream, kTestsuites, "random_seed",
    %%%%%: 4343-block  0
    %%%%%: 4343-block  1
    %%%%%: 4343-block  2
    $$$$$: 4343-block  3
    $$$$$: 4343-block  4
    $$$$$: 4343-block  5
    $$$$$: 4343-block  6
    #####: 4344:                       StreamableToString(unit_test.random_seed()));
    %%%%%: 4344-block  0
    $$$$$: 4344-block  1
    $$$$$: 4344-block  2
    $$$$$: 4344-block  3
        -: 4345:  }
    #####: 4346:  *stream << TestPropertiesAsXmlAttributes(unit_test.ad_hoc_test_result());
    %%%%%: 4346-block  0
    %%%%%: 4346-block  1
    %%%%%: 4346-block  2
    $$$$$: 4346-block  3
    $$$$$: 4346-block  4
        -: 4347:
    #####: 4348:  OutputXmlAttribute(stream, kTestsuites, "name", "AllTests");
    %%%%%: 4348-block  0
    %%%%%: 4348-block  1
    %%%%%: 4348-block  2
    $$$$$: 4348-block  3
    $$$$$: 4348-block  4
    $$$$$: 4348-block  5
    $$$$$: 4348-block  6
    $$$$$: 4348-block  7
    $$$$$: 4348-block  8
    $$$$$: 4348-block  9
    $$$$$: 4348-block 10
    #####: 4349:  *stream << ">\n";
        -: 4350:
    #####: 4351:  for (int i = 0; i < unit_test.total_test_suite_count(); ++i) {
    %%%%%: 4351-block  0
    %%%%%: 4351-block  1
    %%%%%: 4351-block  2
    #####: 4352:    if (unit_test.GetTestSuite(i)->reportable_test_count() > 0)
    %%%%%: 4352-block  0
    %%%%%: 4352-block  1
    %%%%%: 4352-block  2
    #####: 4353:      PrintXmlTestSuite(stream, *unit_test.GetTestSuite(i));
    %%%%%: 4353-block  0
    %%%%%: 4353-block  1
        -: 4354:  }
        -: 4355:
        -: 4356:  // If there was a test failure outside of one of the test suites (like in a
        -: 4357:  // test environment) include that in the output.
    #####: 4358:  if (unit_test.ad_hoc_test_result().Failed()) {
    %%%%%: 4358-block  0
    %%%%%: 4358-block  1
    #####: 4359:    OutputXmlTestSuiteForTestResult(stream, unit_test.ad_hoc_test_result());
    %%%%%: 4359-block  0
        -: 4360:  }
        -: 4361:
    #####: 4362:  *stream << "</" << kTestsuites << ">\n";
    %%%%%: 4362-block  0
    %%%%%: 4362-block  1
    %%%%%: 4362-block  2
    #####: 4363:}
        -: 4364:
    #####: 4365:void XmlUnitTestResultPrinter::PrintXmlTestsList(
        -: 4366:    std::ostream* stream, const std::vector<TestSuite*>& test_suites) {
    #####: 4367:  const std::string kTestsuites = "testsuites";
    %%%%%: 4367-block  0
    %%%%%: 4367-block  1
    $$$$$: 4367-block  2
    $$$$$: 4367-block  3
        -: 4368:
    #####: 4369:  *stream << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
    #####: 4370:  *stream << "<" << kTestsuites;
    %%%%%: 4370-block  0
    %%%%%: 4370-block  1
        -: 4371:
    #####: 4372:  int total_tests = 0;
    #####: 4373:  for (auto test_suite : test_suites) {
    %%%%%: 4373-block  0
    %%%%%: 4373-block  1
    %%%%%: 4373-block  2
    #####: 4374:    total_tests += test_suite->total_test_count();
        -: 4375:  }
    #####: 4376:  OutputXmlAttribute(stream, kTestsuites, "tests",
    %%%%%: 4376-block  0
    %%%%%: 4376-block  1
    %%%%%: 4376-block  2
    $$$$$: 4376-block  3
    $$$$$: 4376-block  4
    $$$$$: 4376-block  5
    $$$$$: 4376-block  6
    #####: 4377:                     StreamableToString(total_tests));
    %%%%%: 4377-block  0
    $$$$$: 4377-block  1
    $$$$$: 4377-block  2
    #####: 4378:  OutputXmlAttribute(stream, kTestsuites, "name", "AllTests");
    %%%%%: 4378-block  0
    %%%%%: 4378-block  1
    %%%%%: 4378-block  2
    $$$$$: 4378-block  3
    $$$$$: 4378-block  4
    $$$$$: 4378-block  5
    $$$$$: 4378-block  6
    $$$$$: 4378-block  7
    $$$$$: 4378-block  8
    $$$$$: 4378-block  9
    $$$$$: 4378-block 10
    #####: 4379:  *stream << ">\n";
        -: 4380:
    #####: 4381:  for (auto test_suite : test_suites) {
    %%%%%: 4381-block  0
    %%%%%: 4381-block  1
    %%%%%: 4381-block  2
    %%%%%: 4381-block  3
    #####: 4382:    PrintXmlTestSuite(stream, *test_suite);
        -: 4383:  }
    #####: 4384:  *stream << "</" << kTestsuites << ">\n";
    %%%%%: 4384-block  0
    %%%%%: 4384-block  1
    %%%%%: 4384-block  2
    #####: 4385:}
        -: 4386:
        -: 4387:// Produces a string representing the test properties in a result as space
        -: 4388:// delimited XML attributes based on the property key="value" pairs.
    #####: 4389:std::string XmlUnitTestResultPrinter::TestPropertiesAsXmlAttributes(
        -: 4390:    const TestResult& result) {
    #####: 4391:  Message attributes;
    %%%%%: 4391-block  0
    %%%%%: 4391-block  1
    $$$$$: 4391-block  2
    #####: 4392:  for (int i = 0; i < result.test_property_count(); ++i) {
    %%%%%: 4392-block  0
    %%%%%: 4392-block  1
    #####: 4393:    const TestProperty& property = result.GetTestProperty(i);
    %%%%%: 4393-block  0
    #####: 4394:    attributes << " " << property.key() << "="
    %%%%%: 4394-block  0
    %%%%%: 4394-block  1
    %%%%%: 4394-block  2
    $$$$$: 4394-block  3
    #####: 4395:        << "\"" << EscapeXmlAttribute(property.value()) << "\"";
    %%%%%: 4395-block  0
    %%%%%: 4395-block  1
    %%%%%: 4395-block  2
    %%%%%: 4395-block  3
    %%%%%: 4395-block  4
    %%%%%: 4395-block  5
    $$$$$: 4395-block  6
    $$$$$: 4395-block  7
    $$$$$: 4395-block  8
    $$$$$: 4395-block  9
    $$$$$: 4395-block 10
    $$$$$: 4395-block 11
        -: 4396:  }
    #####: 4397:  return attributes.GetString();
    %%%%%: 4397-block  0
    %%%%%: 4397-block  1
        -: 4398:}
        -: 4399:
    #####: 4400:void XmlUnitTestResultPrinter::OutputXmlTestProperties(
        -: 4401:    std::ostream* stream, const TestResult& result) {
    #####: 4402:  const std::string kProperties = "properties";
    %%%%%: 4402-block  0
    $$$$$: 4402-block  1
    $$$$$: 4402-block  2
    #####: 4403:  const std::string kProperty = "property";
    $$$$$: 4403-block  0
    $$$$$: 4403-block  1
        -: 4404:
    #####: 4405:  if (result.test_property_count() <= 0) {
    #####: 4406:    return;
    %%%%%: 4406-block  0
        -: 4407:  }
        -: 4408:
    #####: 4409:  *stream << "<" << kProperties << ">\n";
    %%%%%: 4409-block  0
    %%%%%: 4409-block  1
    %%%%%: 4409-block  2
    #####: 4410:  for (int i = 0; i < result.test_property_count(); ++i) {
    %%%%%: 4410-block  0
    %%%%%: 4410-block  1
    %%%%%: 4410-block  2
    #####: 4411:    const TestProperty& property = result.GetTestProperty(i);
    %%%%%: 4411-block  0
    #####: 4412:    *stream << "<" << kProperty;
    %%%%%: 4412-block  0
    %%%%%: 4412-block  1
    #####: 4413:    *stream << " name=\"" << EscapeXmlAttribute(property.key()) << "\"";
    %%%%%: 4413-block  0
    %%%%%: 4413-block  1
    %%%%%: 4413-block  2
    %%%%%: 4413-block  3
    %%%%%: 4413-block  4
    %%%%%: 4413-block  5
    $$$$$: 4413-block  6
    $$$$$: 4413-block  7
    $$$$$: 4413-block  8
    $$$$$: 4413-block  9
    $$$$$: 4413-block 10
    $$$$$: 4413-block 11
    #####: 4414:    *stream << " value=\"" << EscapeXmlAttribute(property.value()) << "\"";
    %%%%%: 4414-block  0
    %%%%%: 4414-block  1
    %%%%%: 4414-block  2
    %%%%%: 4414-block  3
    %%%%%: 4414-block  4
    $$$$$: 4414-block  5
    $$$$$: 4414-block  6
    $$$$$: 4414-block  7
    $$$$$: 4414-block  8
    $$$$$: 4414-block  9
    $$$$$: 4414-block 10
    #####: 4415:    *stream << "/>\n";
        -: 4416:  }
    #####: 4417:  *stream << "</" << kProperties << ">\n";
    %%%%%: 4417-block  0
    %%%%%: 4417-block  1
    %%%%%: 4417-block  2
        -: 4418:}
        -: 4419:
        -: 4420:// End XmlUnitTestResultPrinter
        -: 4421:
        -: 4422:// This class generates an JSON output file.
        -: 4423:class JsonUnitTestResultPrinter : public EmptyTestEventListener {
        -: 4424: public:
        -: 4425:  explicit JsonUnitTestResultPrinter(const char* output_file);
        -: 4426:
        -: 4427:  void OnTestIterationEnd(const UnitTest& unit_test, int iteration) override;
        -: 4428:
        -: 4429:  // Prints an JSON summary of all unit tests.
        -: 4430:  static void PrintJsonTestList(::std::ostream* stream,
        -: 4431:                                const std::vector<TestSuite*>& test_suites);
        -: 4432:
        -: 4433: private:
        -: 4434:  // Returns an JSON-escaped copy of the input string str.
        -: 4435:  static std::string EscapeJson(const std::string& str);
        -: 4436:
        -: 4437:  //// Verifies that the given attribute belongs to the given element and
        -: 4438:  //// streams the attribute as JSON.
        -: 4439:  static void OutputJsonKey(std::ostream* stream,
        -: 4440:                            const std::string& element_name,
        -: 4441:                            const std::string& name,
        -: 4442:                            const std::string& value,
        -: 4443:                            const std::string& indent,
        -: 4444:                            bool comma = true);
        -: 4445:  static void OutputJsonKey(std::ostream* stream,
        -: 4446:                            const std::string& element_name,
        -: 4447:                            const std::string& name,
        -: 4448:                            int value,
        -: 4449:                            const std::string& indent,
        -: 4450:                            bool comma = true);
        -: 4451:
        -: 4452:  // Streams a test suite JSON stanza containing the given test result.
        -: 4453:  //
        -: 4454:  // Requires: result.Failed()
        -: 4455:  static void OutputJsonTestSuiteForTestResult(::std::ostream* stream,
        -: 4456:                                               const TestResult& result);
        -: 4457:
        -: 4458:  // Streams a JSON representation of a TestResult object.
        -: 4459:  static void OutputJsonTestResult(::std::ostream* stream,
        -: 4460:                                   const TestResult& result);
        -: 4461:
        -: 4462:  // Streams a JSON representation of a TestInfo object.
        -: 4463:  static void OutputJsonTestInfo(::std::ostream* stream,
        -: 4464:                                 const char* test_suite_name,
        -: 4465:                                 const TestInfo& test_info);
        -: 4466:
        -: 4467:  // Prints a JSON representation of a TestSuite object
        -: 4468:  static void PrintJsonTestSuite(::std::ostream* stream,
        -: 4469:                                 const TestSuite& test_suite);
        -: 4470:
        -: 4471:  // Prints a JSON summary of unit_test to output stream out.
        -: 4472:  static void PrintJsonUnitTest(::std::ostream* stream,
        -: 4473:                                const UnitTest& unit_test);
        -: 4474:
        -: 4475:  // Produces a string representing the test properties in a result as
        -: 4476:  // a JSON dictionary.
        -: 4477:  static std::string TestPropertiesAsJson(const TestResult& result,
        -: 4478:                                          const std::string& indent);
        -: 4479:
        -: 4480:  // The output file.
        -: 4481:  const std::string output_file_;
        -: 4482:
        -: 4483:  GTEST_DISALLOW_COPY_AND_ASSIGN_(JsonUnitTestResultPrinter);
        -: 4484:};
        -: 4485:
        -: 4486:// Creates a new JsonUnitTestResultPrinter.
    #####: 4487:JsonUnitTestResultPrinter::JsonUnitTestResultPrinter(const char* output_file)
    #####: 4488:    : output_file_(output_file) {
    %%%%%: 4488-block  0
    %%%%%: 4488-block  1
    $$$$$: 4488-block  2
    $$$$$: 4488-block  3
    $$$$$: 4488-block  4
    $$$$$: 4488-block  5
    #####: 4489:  if (output_file_.empty()) {
    #####: 4490:    GTEST_LOG_(FATAL) << "JSON output file may not be null";
    %%%%%: 4490-block  0
    %%%%%: 4490-block  1
    %%%%%: 4490-block  2
    $$$$$: 4490-block  3
    $$$$$: 4490-block  4
        -: 4491:  }
    #####: 4492:}
    %%%%%: 4492-block  0
        -: 4493:
    #####: 4494:void JsonUnitTestResultPrinter::OnTestIterationEnd(const UnitTest& unit_test,
        -: 4495:                                                  int /*iteration*/) {
    #####: 4496:  FILE* jsonout = OpenFileForWriting(output_file_);
    %%%%%: 4496-block  0
    #####: 4497:  std::stringstream stream;
    %%%%%: 4497-block  0
    %%%%%: 4497-block  1
    $$$$$: 4497-block  2
    #####: 4498:  PrintJsonUnitTest(&stream, unit_test);
    %%%%%: 4498-block  0
    #####: 4499:  fprintf(jsonout, "%s", StringStreamToString(&stream).c_str());
    %%%%%: 4499-block  0
    %%%%%: 4499-block  1
    %%%%%: 4499-block  2
    $$$$$: 4499-block  3
    $$$$$: 4499-block  4
    #####: 4500:  fclose(jsonout);
    #####: 4501:}
        -: 4502:
        -: 4503:// Returns an JSON-escaped copy of the input string str.
    #####: 4504:std::string JsonUnitTestResultPrinter::EscapeJson(const std::string& str) {
    #####: 4505:  Message m;
    %%%%%: 4505-block  0
    %%%%%: 4505-block  1
    $$$$$: 4505-block  2
        -: 4506:
    #####: 4507:  for (size_t i = 0; i < str.size(); ++i) {
    %%%%%: 4507-block  0
    %%%%%: 4507-block  1
    %%%%%: 4507-block  2
    #####: 4508:    const char ch = str[i];
    %%%%%: 4508-block  0
    #####: 4509:    switch (ch) {
    #####: 4510:      case '\\':
        -: 4511:      case '"':
        -: 4512:      case '/':
    #####: 4513:        m << '\\' << ch;
    %%%%%: 4513-block  0
    %%%%%: 4513-block  1
    $$$$$: 4513-block  2
    #####: 4514:        break;
    %%%%%: 4514-block  0
    #####: 4515:      case '\b':
    #####: 4516:        m << "\\b";
    %%%%%: 4516-block  0
    #####: 4517:        break;
    %%%%%: 4517-block  0
    #####: 4518:      case '\t':
    #####: 4519:        m << "\\t";
    %%%%%: 4519-block  0
    #####: 4520:        break;
    %%%%%: 4520-block  0
    #####: 4521:      case '\n':
    #####: 4522:        m << "\\n";
    %%%%%: 4522-block  0
    #####: 4523:        break;
    %%%%%: 4523-block  0
    #####: 4524:      case '\f':
    #####: 4525:        m << "\\f";
    %%%%%: 4525-block  0
    #####: 4526:        break;
    %%%%%: 4526-block  0
    #####: 4527:      case '\r':
    #####: 4528:        m << "\\r";
    %%%%%: 4528-block  0
    #####: 4529:        break;
    %%%%%: 4529-block  0
    #####: 4530:      default:
    #####: 4531:        if (ch < ' ') {
    %%%%%: 4531-block  0
    #####: 4532:          m << "\\u00" << String::FormatByte(static_cast<unsigned char>(ch));
    %%%%%: 4532-block  0
    %%%%%: 4532-block  1
    %%%%%: 4532-block  2
    %%%%%: 4532-block  3
    $$$$$: 4532-block  4
    $$$$$: 4532-block  5
        -: 4533:        } else {
    #####: 4534:          m << ch;
    %%%%%: 4534-block  0
        -: 4535:        }
    #####: 4536:        break;
    %%%%%: 4536-block  0
        -: 4537:    }
        -: 4538:  }
        -: 4539:
    #####: 4540:  return m.GetString();
    %%%%%: 4540-block  0
    %%%%%: 4540-block  1
        -: 4541:}
        -: 4542:
        -: 4543:// The following routines generate an JSON representation of a UnitTest
        -: 4544:// object.
        -: 4545:
        -: 4546:// Formats the given time in milliseconds as seconds.
    #####: 4547:static std::string FormatTimeInMillisAsDuration(TimeInMillis ms) {
    #####: 4548:  ::std::stringstream ss;
    %%%%%: 4548-block  0
    %%%%%: 4548-block  1
    $$$$$: 4548-block  2
    #####: 4549:  ss << (static_cast<double>(ms) * 1e-3) << "s";
    %%%%%: 4549-block  0
    %%%%%: 4549-block  1
    #####: 4550:  return ss.str();
    %%%%%: 4550-block  0
    %%%%%: 4550-block  1
        -: 4551:}
        -: 4552:
        -: 4553:// Converts the given epoch time in milliseconds to a date string in the
        -: 4554:// RFC3339 format, without the timezone information.
    #####: 4555:static std::string FormatEpochTimeInMillisAsRFC3339(TimeInMillis ms) {
        -: 4556:  struct tm time_struct;
    #####: 4557:  if (!PortableLocaltime(static_cast<time_t>(ms / 1000), &time_struct))
    %%%%%: 4557-block  0
    #####: 4558:    return "";
    %%%%%: 4558-block  0
    %%%%%: 4558-block  1
    $$$$$: 4558-block  2
    $$$$$: 4558-block  3
        -: 4559:  // YYYY-MM-DDThh:mm:ss
    #####: 4560:  return StreamableToString(time_struct.tm_year + 1900) + "-" +
    %%%%%: 4560-block  0
    %%%%%: 4560-block  1
    %%%%%: 4560-block  2
    $$$$$: 4560-block  3
    $$$$$: 4560-block  4
    $$$$$: 4560-block  5
    $$$$$: 4560-block  6
    $$$$$: 4560-block  7
    $$$$$: 4560-block  8
    $$$$$: 4560-block  9
    #####: 4561:      String::FormatIntWidth2(time_struct.tm_mon + 1) + "-" +
    %%%%%: 4561-block  0
    %%%%%: 4561-block  1
    %%%%%: 4561-block  2
    $$$$$: 4561-block  3
    $$$$$: 4561-block  4
    $$$$$: 4561-block  5
    $$$$$: 4561-block  6
    $$$$$: 4561-block  7
    $$$$$: 4561-block  8
    #####: 4562:      String::FormatIntWidth2(time_struct.tm_mday) + "T" +
    %%%%%: 4562-block  0
    %%%%%: 4562-block  1
    %%%%%: 4562-block  2
    $$$$$: 4562-block  3
    $$$$$: 4562-block  4
    $$$$$: 4562-block  5
    $$$$$: 4562-block  6
    $$$$$: 4562-block  7
    $$$$$: 4562-block  8
    #####: 4563:      String::FormatIntWidth2(time_struct.tm_hour) + ":" +
    %%%%%: 4563-block  0
    %%%%%: 4563-block  1
    %%%%%: 4563-block  2
    $$$$$: 4563-block  3
    $$$$$: 4563-block  4
    $$$$$: 4563-block  5
    $$$$$: 4563-block  6
    $$$$$: 4563-block  7
    $$$$$: 4563-block  8
    #####: 4564:      String::FormatIntWidth2(time_struct.tm_min) + ":" +
    %%%%%: 4564-block  0
    %%%%%: 4564-block  1
    %%%%%: 4564-block  2
    %%%%%: 4564-block  3
    $$$$$: 4564-block  4
    $$$$$: 4564-block  5
    $$$$$: 4564-block  6
    $$$$$: 4564-block  7
    $$$$$: 4564-block  8
    $$$$$: 4564-block  9
    #####: 4565:      String::FormatIntWidth2(time_struct.tm_sec) + "Z";
    %%%%%: 4565-block  0
    %%%%%: 4565-block  1
    $$$$$: 4565-block  2
    $$$$$: 4565-block  3
        -: 4566:}
        -: 4567:
    #####: 4568:static inline std::string Indent(size_t width) {
    #####: 4569:  return std::string(width, ' ');
    %%%%%: 4569-block  0
    %%%%%: 4569-block  1
    %%%%%: 4569-block  2
    $$$$$: 4569-block  3
        -: 4570:}
        -: 4571:
    #####: 4572:void JsonUnitTestResultPrinter::OutputJsonKey(
        -: 4573:    std::ostream* stream,
        -: 4574:    const std::string& element_name,
        -: 4575:    const std::string& name,
        -: 4576:    const std::string& value,
        -: 4577:    const std::string& indent,
        -: 4578:    bool comma) {
        -: 4579:  const std::vector<std::string>& allowed_names =
    #####: 4580:      GetReservedOutputAttributesForElement(element_name);
    %%%%%: 4580-block  0
    %%%%%: 4580-block  1
    $$$$$: 4580-block  2
        -: 4581:
    #####: 4582:  GTEST_CHECK_(std::find(allowed_names.begin(), allowed_names.end(), name) !=
    %%%%%: 4582-block  0
    %%%%%: 4582-block  1
    %%%%%: 4582-block  2
    %%%%%: 4582-block  3
    %%%%%: 4582-block  4
    $$$$$: 4582-block  5
    $$$$$: 4582-block  6
    $$$$$: 4582-block  7
        -: 4583:                   allowed_names.end())
        -: 4584:      << "Key \"" << name << "\" is not allowed for value \"" << element_name
    #####: 4585:      << "\".";
    %%%%%: 4585-block  0
    %%%%%: 4585-block  1
    %%%%%: 4585-block  2
    %%%%%: 4585-block  3
    %%%%%: 4585-block  4
        -: 4586:
    #####: 4587:  *stream << indent << "\"" << name << "\": \"" << EscapeJson(value) << "\"";
    %%%%%: 4587-block  0
    %%%%%: 4587-block  1
    %%%%%: 4587-block  2
    %%%%%: 4587-block  3
    %%%%%: 4587-block  4
    %%%%%: 4587-block  5
    %%%%%: 4587-block  6
    %%%%%: 4587-block  7
    $$$$$: 4587-block  8
    $$$$$: 4587-block  9
    #####: 4588:  if (comma)
    #####: 4589:    *stream << ",\n";
    %%%%%: 4589-block  0
    #####: 4590:}
        -: 4591:
    #####: 4592:void JsonUnitTestResultPrinter::OutputJsonKey(
        -: 4593:    std::ostream* stream,
        -: 4594:    const std::string& element_name,
        -: 4595:    const std::string& name,
        -: 4596:    int value,
        -: 4597:    const std::string& indent,
        -: 4598:    bool comma) {
        -: 4599:  const std::vector<std::string>& allowed_names =
    #####: 4600:      GetReservedOutputAttributesForElement(element_name);
    %%%%%: 4600-block  0
    %%%%%: 4600-block  1
    $$$$$: 4600-block  2
        -: 4601:
    #####: 4602:  GTEST_CHECK_(std::find(allowed_names.begin(), allowed_names.end(), name) !=
    %%%%%: 4602-block  0
    %%%%%: 4602-block  1
    %%%%%: 4602-block  2
    %%%%%: 4602-block  3
    %%%%%: 4602-block  4
    $$$$$: 4602-block  5
    $$$$$: 4602-block  6
    $$$$$: 4602-block  7
        -: 4603:                   allowed_names.end())
        -: 4604:      << "Key \"" << name << "\" is not allowed for value \"" << element_name
    #####: 4605:      << "\".";
    %%%%%: 4605-block  0
    %%%%%: 4605-block  1
    %%%%%: 4605-block  2
    %%%%%: 4605-block  3
    %%%%%: 4605-block  4
        -: 4606:
    #####: 4607:  *stream << indent << "\"" << name << "\": " << StreamableToString(value);
    %%%%%: 4607-block  0
    %%%%%: 4607-block  1
    %%%%%: 4607-block  2
    %%%%%: 4607-block  3
    %%%%%: 4607-block  4
    %%%%%: 4607-block  5
    %%%%%: 4607-block  6
    $$$$$: 4607-block  7
    $$$$$: 4607-block  8
    #####: 4608:  if (comma)
    #####: 4609:    *stream << ",\n";
    %%%%%: 4609-block  0
    #####: 4610:}
        -: 4611:
        -: 4612:// Streams a test suite JSON stanza containing the given test result.
    #####: 4613:void JsonUnitTestResultPrinter::OutputJsonTestSuiteForTestResult(
        -: 4614:    ::std::ostream* stream, const TestResult& result) {
        -: 4615:  // Output the boilerplate for a new test suite.
    #####: 4616:  *stream << Indent(4) << "{\n";
    %%%%%: 4616-block  0
    %%%%%: 4616-block  1
    %%%%%: 4616-block  2
    $$$$$: 4616-block  3
    $$$$$: 4616-block  4
    #####: 4617:  OutputJsonKey(stream, "testsuite", "name", "NonTestSuiteFailure", Indent(6));
    %%%%%: 4617-block  0
    %%%%%: 4617-block  1
    %%%%%: 4617-block  2
    %%%%%: 4617-block  3
    $$$$$: 4617-block  4
    $$$$$: 4617-block  5
    $$$$$: 4617-block  6
    $$$$$: 4617-block  7
    $$$$$: 4617-block  8
    $$$$$: 4617-block  9
    $$$$$: 4617-block 10
    $$$$$: 4617-block 11
    $$$$$: 4617-block 12
    $$$$$: 4617-block 13
    $$$$$: 4617-block 14
    $$$$$: 4617-block 15
    $$$$$: 4617-block 16
    $$$$$: 4617-block 17
    #####: 4618:  OutputJsonKey(stream, "testsuite", "tests", 1, Indent(6));
    %%%%%: 4618-block  0
    %%%%%: 4618-block  1
    %%%%%: 4618-block  2
    $$$$$: 4618-block  3
    $$$$$: 4618-block  4
    $$$$$: 4618-block  5
    $$$$$: 4618-block  6
    $$$$$: 4618-block  7
    $$$$$: 4618-block  8
    $$$$$: 4618-block  9
    $$$$$: 4618-block 10
    $$$$$: 4618-block 11
    $$$$$: 4618-block 12
    #####: 4619:  if (!GTEST_FLAG(list_tests)) {
    #####: 4620:    OutputJsonKey(stream, "testsuite", "failures", 1, Indent(6));
    %%%%%: 4620-block  0
    %%%%%: 4620-block  1
    %%%%%: 4620-block  2
    %%%%%: 4620-block  3
    $$$$$: 4620-block  4
    $$$$$: 4620-block  5
    $$$$$: 4620-block  6
    $$$$$: 4620-block  7
    $$$$$: 4620-block  8
    $$$$$: 4620-block  9
    $$$$$: 4620-block 10
    $$$$$: 4620-block 11
    $$$$$: 4620-block 12
    $$$$$: 4620-block 13
    #####: 4621:    OutputJsonKey(stream, "testsuite", "disabled", 0, Indent(6));
    %%%%%: 4621-block  0
    %%%%%: 4621-block  1
    %%%%%: 4621-block  2
    $$$$$: 4621-block  3
    $$$$$: 4621-block  4
    $$$$$: 4621-block  5
    $$$$$: 4621-block  6
    $$$$$: 4621-block  7
    $$$$$: 4621-block  8
    $$$$$: 4621-block  9
    $$$$$: 4621-block 10
    $$$$$: 4621-block 11
    $$$$$: 4621-block 12
    #####: 4622:    OutputJsonKey(stream, "testsuite", "skipped", 0, Indent(6));
    %%%%%: 4622-block  0
    %%%%%: 4622-block  1
    %%%%%: 4622-block  2
    $$$$$: 4622-block  3
    $$$$$: 4622-block  4
    $$$$$: 4622-block  5
    $$$$$: 4622-block  6
    $$$$$: 4622-block  7
    $$$$$: 4622-block  8
    $$$$$: 4622-block  9
    $$$$$: 4622-block 10
    $$$$$: 4622-block 11
    $$$$$: 4622-block 12
    #####: 4623:    OutputJsonKey(stream, "testsuite", "errors", 0, Indent(6));
    %%%%%: 4623-block  0
    %%%%%: 4623-block  1
    %%%%%: 4623-block  2
    $$$$$: 4623-block  3
    $$$$$: 4623-block  4
    $$$$$: 4623-block  5
    $$$$$: 4623-block  6
    $$$$$: 4623-block  7
    $$$$$: 4623-block  8
    $$$$$: 4623-block  9
    $$$$$: 4623-block 10
    $$$$$: 4623-block 11
    $$$$$: 4623-block 12
    #####: 4624:    OutputJsonKey(stream, "testsuite", "time",
    %%%%%: 4624-block  0
    %%%%%: 4624-block  1
    %%%%%: 4624-block  2
    %%%%%: 4624-block  3
    $$$$$: 4624-block  4
    $$$$$: 4624-block  5
    $$$$$: 4624-block  6
    $$$$$: 4624-block  7
    $$$$$: 4624-block  8
    $$$$$: 4624-block  9
    $$$$$: 4624-block 10
    $$$$$: 4624-block 11
    #####: 4625:                  FormatTimeInMillisAsDuration(result.elapsed_time()),
    $$$$$: 4625-block  0
    $$$$$: 4625-block  1
    #####: 4626:                  Indent(6));
    $$$$$: 4626-block  0
    $$$$$: 4626-block  1
    #####: 4627:    OutputJsonKey(stream, "testsuite", "timestamp",
    %%%%%: 4627-block  0
    %%%%%: 4627-block  1
    %%%%%: 4627-block  2
    %%%%%: 4627-block  3
    $$$$$: 4627-block  4
    $$$$$: 4627-block  5
    $$$$$: 4627-block  6
    $$$$$: 4627-block  7
    $$$$$: 4627-block  8
    $$$$$: 4627-block  9
    $$$$$: 4627-block 10
    $$$$$: 4627-block 11
    #####: 4628:                  FormatEpochTimeInMillisAsRFC3339(result.start_timestamp()),
    $$$$$: 4628-block  0
    $$$$$: 4628-block  1
    #####: 4629:                  Indent(6));
    $$$$$: 4629-block  0
    $$$$$: 4629-block  1
        -: 4630:  }
    #####: 4631:  *stream << Indent(6) << "\"testsuite\": [\n";
    %%%%%: 4631-block  0
    %%%%%: 4631-block  1
    %%%%%: 4631-block  2
    $$$$$: 4631-block  3
    $$$$$: 4631-block  4
        -: 4632:
        -: 4633:  // Output the boilerplate for a new test case.
    #####: 4634:  *stream << Indent(8) << "{\n";
    %%%%%: 4634-block  0
    %%%%%: 4634-block  1
    $$$$$: 4634-block  2
    $$$$$: 4634-block  3
    #####: 4635:  OutputJsonKey(stream, "testcase", "name", "", Indent(10));
    %%%%%: 4635-block  0
    %%%%%: 4635-block  1
    %%%%%: 4635-block  2
    %%%%%: 4635-block  3
    $$$$$: 4635-block  4
    $$$$$: 4635-block  5
    $$$$$: 4635-block  6
    $$$$$: 4635-block  7
    $$$$$: 4635-block  8
    $$$$$: 4635-block  9
    $$$$$: 4635-block 10
    $$$$$: 4635-block 11
    $$$$$: 4635-block 12
    $$$$$: 4635-block 13
    $$$$$: 4635-block 14
    $$$$$: 4635-block 15
    $$$$$: 4635-block 16
    $$$$$: 4635-block 17
    #####: 4636:  OutputJsonKey(stream, "testcase", "status", "RUN", Indent(10));
    %%%%%: 4636-block  0
    %%%%%: 4636-block  1
    %%%%%: 4636-block  2
    %%%%%: 4636-block  3
    $$$$$: 4636-block  4
    $$$$$: 4636-block  5
    $$$$$: 4636-block  6
    $$$$$: 4636-block  7
    $$$$$: 4636-block  8
    $$$$$: 4636-block  9
    $$$$$: 4636-block 10
    $$$$$: 4636-block 11
    $$$$$: 4636-block 12
    $$$$$: 4636-block 13
    $$$$$: 4636-block 14
    $$$$$: 4636-block 15
    $$$$$: 4636-block 16
    $$$$$: 4636-block 17
    #####: 4637:  OutputJsonKey(stream, "testcase", "result", "COMPLETED", Indent(10));
    %%%%%: 4637-block  0
    %%%%%: 4637-block  1
    %%%%%: 4637-block  2
    %%%%%: 4637-block  3
    $$$$$: 4637-block  4
    $$$$$: 4637-block  5
    $$$$$: 4637-block  6
    $$$$$: 4637-block  7
    $$$$$: 4637-block  8
    $$$$$: 4637-block  9
    $$$$$: 4637-block 10
    $$$$$: 4637-block 11
    $$$$$: 4637-block 12
    $$$$$: 4637-block 13
    $$$$$: 4637-block 14
    $$$$$: 4637-block 15
    $$$$$: 4637-block 16
    $$$$$: 4637-block 17
    #####: 4638:  OutputJsonKey(stream, "testcase", "timestamp",
    %%%%%: 4638-block  0
    %%%%%: 4638-block  1
    %%%%%: 4638-block  2
    %%%%%: 4638-block  3
    $$$$$: 4638-block  4
    $$$$$: 4638-block  5
    $$$$$: 4638-block  6
    $$$$$: 4638-block  7
    $$$$$: 4638-block  8
    $$$$$: 4638-block  9
    $$$$$: 4638-block 10
    $$$$$: 4638-block 11
    #####: 4639:                FormatEpochTimeInMillisAsRFC3339(result.start_timestamp()),
    $$$$$: 4639-block  0
    $$$$$: 4639-block  1
    #####: 4640:                Indent(10));
    $$$$$: 4640-block  0
    $$$$$: 4640-block  1
    #####: 4641:  OutputJsonKey(stream, "testcase", "time",
    %%%%%: 4641-block  0
    %%%%%: 4641-block  1
    %%%%%: 4641-block  2
    %%%%%: 4641-block  3
    $$$$$: 4641-block  4
    $$$$$: 4641-block  5
    $$$$$: 4641-block  6
    $$$$$: 4641-block  7
    $$$$$: 4641-block  8
    $$$$$: 4641-block  9
    $$$$$: 4641-block 10
    $$$$$: 4641-block 11
    #####: 4642:                FormatTimeInMillisAsDuration(result.elapsed_time()),
    $$$$$: 4642-block  0
    $$$$$: 4642-block  1
    #####: 4643:                Indent(10));
    $$$$$: 4643-block  0
    $$$$$: 4643-block  1
    #####: 4644:  OutputJsonKey(stream, "testcase", "classname", "", Indent(10), false);
    %%%%%: 4644-block  0
    %%%%%: 4644-block  1
    %%%%%: 4644-block  2
    %%%%%: 4644-block  3
    $$$$$: 4644-block  4
    $$$$$: 4644-block  5
    $$$$$: 4644-block  6
    $$$$$: 4644-block  7
    $$$$$: 4644-block  8
    $$$$$: 4644-block  9
    $$$$$: 4644-block 10
    $$$$$: 4644-block 11
    $$$$$: 4644-block 12
    $$$$$: 4644-block 13
    $$$$$: 4644-block 14
    $$$$$: 4644-block 15
    $$$$$: 4644-block 16
    $$$$$: 4644-block 17
    #####: 4645:  *stream << TestPropertiesAsJson(result, Indent(10));
    %%%%%: 4645-block  0
    %%%%%: 4645-block  1
    $$$$$: 4645-block  2
    $$$$$: 4645-block  3
    $$$$$: 4645-block  4
    $$$$$: 4645-block  5
        -: 4646:
        -: 4647:  // Output the actual test result.
    #####: 4648:  OutputJsonTestResult(stream, result);
        -: 4649:
        -: 4650:  // Finish the test suite.
    #####: 4651:  *stream << "\n" << Indent(6) << "]\n" << Indent(4) << "}";
    %%%%%: 4651-block  0
    %%%%%: 4651-block  1
    %%%%%: 4651-block  2
    %%%%%: 4651-block  3
    %%%%%: 4651-block  4
    $$$$$: 4651-block  5
    $$$$$: 4651-block  6
    $$$$$: 4651-block  7
    #####: 4652:}
        -: 4653:
        -: 4654:// Prints a JSON representation of a TestInfo object.
    #####: 4655:void JsonUnitTestResultPrinter::OutputJsonTestInfo(::std::ostream* stream,
        -: 4656:                                                   const char* test_suite_name,
        -: 4657:                                                   const TestInfo& test_info) {
    #####: 4658:  const TestResult& result = *test_info.result();
    %%%%%: 4658-block  0
    #####: 4659:  const std::string kTestsuite = "testcase";
    $$$$$: 4659-block  0
    $$$$$: 4659-block  1
    #####: 4660:  const std::string kIndent = Indent(10);
    $$$$$: 4660-block  0
        -: 4661:
    #####: 4662:  *stream << Indent(8) << "{\n";
    %%%%%: 4662-block  0
    %%%%%: 4662-block  1
    %%%%%: 4662-block  2
    %%%%%: 4662-block  3
    $$$$$: 4662-block  4
    $$$$$: 4662-block  5
    #####: 4663:  OutputJsonKey(stream, kTestsuite, "name", test_info.name(), kIndent);
    %%%%%: 4663-block  0
    %%%%%: 4663-block  1
    %%%%%: 4663-block  2
    $$$$$: 4663-block  3
    $$$$$: 4663-block  4
    $$$$$: 4663-block  5
    $$$$$: 4663-block  6
    $$$$$: 4663-block  7
    $$$$$: 4663-block  8
    $$$$$: 4663-block  9
    $$$$$: 4663-block 10
        -: 4664:
    #####: 4665:  if (test_info.value_param() != nullptr) {
    #####: 4666:    OutputJsonKey(stream, kTestsuite, "value_param", test_info.value_param(),
    %%%%%: 4666-block  0
    %%%%%: 4666-block  1
    %%%%%: 4666-block  2
    %%%%%: 4666-block  3
    $$$$$: 4666-block  4
    $$$$$: 4666-block  5
    $$$$$: 4666-block  6
    $$$$$: 4666-block  7
    $$$$$: 4666-block  8
    $$$$$: 4666-block  9
    $$$$$: 4666-block 10
    $$$$$: 4666-block 11
        -: 4667:                  kIndent);
        -: 4668:  }
    #####: 4669:  if (test_info.type_param() != nullptr) {
    %%%%%: 4669-block  0
    #####: 4670:    OutputJsonKey(stream, kTestsuite, "type_param", test_info.type_param(),
    %%%%%: 4670-block  0
    %%%%%: 4670-block  1
    %%%%%: 4670-block  2
    %%%%%: 4670-block  3
    $$$$$: 4670-block  4
    $$$$$: 4670-block  5
    $$$$$: 4670-block  6
    $$$$$: 4670-block  7
    $$$$$: 4670-block  8
    $$$$$: 4670-block  9
    $$$$$: 4670-block 10
    $$$$$: 4670-block 11
        -: 4671:                  kIndent);
        -: 4672:  }
    #####: 4673:  if (GTEST_FLAG(list_tests)) {
    %%%%%: 4673-block  0
    #####: 4674:    OutputJsonKey(stream, kTestsuite, "file", test_info.file(), kIndent);
    %%%%%: 4674-block  0
    %%%%%: 4674-block  1
    %%%%%: 4674-block  2
    %%%%%: 4674-block  3
    $$$$$: 4674-block  4
    $$$$$: 4674-block  5
    $$$$$: 4674-block  6
    $$$$$: 4674-block  7
    $$$$$: 4674-block  8
    $$$$$: 4674-block  9
    $$$$$: 4674-block 10
    $$$$$: 4674-block 11
    #####: 4675:    OutputJsonKey(stream, kTestsuite, "line", test_info.line(), kIndent, false);
    %%%%%: 4675-block  0
    %%%%%: 4675-block  1
    $$$$$: 4675-block  2
    $$$$$: 4675-block  3
    $$$$$: 4675-block  4
    $$$$$: 4675-block  5
    #####: 4676:    *stream << "\n" << Indent(8) << "}";
    %%%%%: 4676-block  0
    %%%%%: 4676-block  1
    %%%%%: 4676-block  2
    %%%%%: 4676-block  3
    $$$$$: 4676-block  4
    $$$$$: 4676-block  5
    #####: 4677:    return;
        -: 4678:  }
        -: 4679:
    #####: 4680:  OutputJsonKey(stream, kTestsuite, "status",
    %%%%%: 4680-block  0
    %%%%%: 4680-block  1
    %%%%%: 4680-block  2
    %%%%%: 4680-block  3
    %%%%%: 4680-block  4
    %%%%%: 4680-block  5
    %%%%%: 4680-block  6
    $$$$$: 4680-block  7
    $$$$$: 4680-block  8
    $$$$$: 4680-block  9
    $$$$$: 4680-block 10
    $$$$$: 4680-block 11
    $$$$$: 4680-block 12
    $$$$$: 4680-block 13
    $$$$$: 4680-block 14
    #####: 4681:                test_info.should_run() ? "RUN" : "NOTRUN", kIndent);
    #####: 4682:  OutputJsonKey(stream, kTestsuite, "result",
    %%%%%: 4682-block  0
    %%%%%: 4682-block  1
    %%%%%: 4682-block  2
    %%%%%: 4682-block  3
    %%%%%: 4682-block  4
    %%%%%: 4682-block  5
    $$$$$: 4682-block  6
    $$$$$: 4682-block  7
    $$$$$: 4682-block  8
    $$$$$: 4682-block  9
    $$$$$: 4682-block 10
    $$$$$: 4682-block 11
    $$$$$: 4682-block 12
    $$$$$: 4682-block 13
    #####: 4683:                test_info.should_run()
    #####: 4684:                    ? (result.Skipped() ? "SKIPPED" : "COMPLETED")
    %%%%%: 4684-block  0
    %%%%%: 4684-block  1
    %%%%%: 4684-block  2
    %%%%%: 4684-block  3
        -: 4685:                    : "SUPPRESSED",
        -: 4686:                kIndent);
    #####: 4687:  OutputJsonKey(stream, kTestsuite, "timestamp",
    %%%%%: 4687-block  0
    %%%%%: 4687-block  1
    %%%%%: 4687-block  2
    $$$$$: 4687-block  3
    $$$$$: 4687-block  4
    $$$$$: 4687-block  5
    $$$$$: 4687-block  6
    #####: 4688:                FormatEpochTimeInMillisAsRFC3339(result.start_timestamp()),
    $$$$$: 4688-block  0
    $$$$$: 4688-block  1
        -: 4689:                kIndent);
    #####: 4690:  OutputJsonKey(stream, kTestsuite, "time",
    %%%%%: 4690-block  0
    %%%%%: 4690-block  1
    %%%%%: 4690-block  2
    $$$$$: 4690-block  3
    $$$$$: 4690-block  4
    $$$$$: 4690-block  5
    $$$$$: 4690-block  6
    #####: 4691:                FormatTimeInMillisAsDuration(result.elapsed_time()), kIndent);
    $$$$$: 4691-block  0
    $$$$$: 4691-block  1
    #####: 4692:  OutputJsonKey(stream, kTestsuite, "classname", test_suite_name, kIndent,
    %%%%%: 4692-block  0
    %%%%%: 4692-block  1
    %%%%%: 4692-block  2
    $$$$$: 4692-block  3
    $$$$$: 4692-block  4
    $$$$$: 4692-block  5
    $$$$$: 4692-block  6
    $$$$$: 4692-block  7
    $$$$$: 4692-block  8
    $$$$$: 4692-block  9
    $$$$$: 4692-block 10
        -: 4693:                false);
    #####: 4694:  *stream << TestPropertiesAsJson(result, kIndent);
    %%%%%: 4694-block  0
    %%%%%: 4694-block  1
    $$$$$: 4694-block  2
    $$$$$: 4694-block  3
        -: 4695:
    #####: 4696:  OutputJsonTestResult(stream, result);
        -: 4697:}
        -: 4698:
    #####: 4699:void JsonUnitTestResultPrinter::OutputJsonTestResult(::std::ostream* stream,
        -: 4700:                                                     const TestResult& result) {
    #####: 4701:  const std::string kIndent = Indent(10);
    %%%%%: 4701-block  0
    $$$$$: 4701-block  1
        -: 4702:
    #####: 4703:  int failures = 0;
    #####: 4704:  for (int i = 0; i < result.total_part_count(); ++i) {
    %%%%%: 4704-block  0
    %%%%%: 4704-block  1
    %%%%%: 4704-block  2
    #####: 4705:    const TestPartResult& part = result.GetTestPartResult(i);
    %%%%%: 4705-block  0
    #####: 4706:    if (part.failed()) {
    %%%%%: 4706-block  0
    #####: 4707:      *stream << ",\n";
    %%%%%: 4707-block  0
    #####: 4708:      if (++failures == 1) {
    %%%%%: 4708-block  0
    #####: 4709:        *stream << kIndent << "\"" << "failures" << "\": [\n";
    %%%%%: 4709-block  0
    %%%%%: 4709-block  1
    %%%%%: 4709-block  2
    %%%%%: 4709-block  3
        -: 4710:      }
        -: 4711:      const std::string location =
        -: 4712:          internal::FormatCompilerIndependentFileLocation(part.file_name(),
    #####: 4713:                                                          part.line_number());
    %%%%%: 4713-block  0
    $$$$$: 4713-block  1
    #####: 4714:      const std::string message = EscapeJson(location + "\n" + part.message());
    %%%%%: 4714-block  0
    %%%%%: 4714-block  1
    %%%%%: 4714-block  2
    %%%%%: 4714-block  3
    $$$$$: 4714-block  4
    $$$$$: 4714-block  5
    $$$$$: 4714-block  6
        -: 4715:      *stream << kIndent << "  {\n"
        -: 4716:              << kIndent << "    \"failure\": \"" << message << "\",\n"
        -: 4717:              << kIndent << "    \"type\": \"\"\n"
    #####: 4718:              << kIndent << "  }";
    %%%%%: 4718-block  0
    %%%%%: 4718-block  1
    %%%%%: 4718-block  2
    %%%%%: 4718-block  3
    %%%%%: 4718-block  4
    %%%%%: 4718-block  5
    %%%%%: 4718-block  6
    %%%%%: 4718-block  7
    %%%%%: 4718-block  8
        -: 4719:    }
        -: 4720:  }
        -: 4721:
    #####: 4722:  if (failures > 0)
    %%%%%: 4722-block  0
    #####: 4723:    *stream << "\n" << kIndent << "]";
    %%%%%: 4723-block  0
    %%%%%: 4723-block  1
    %%%%%: 4723-block  2
    #####: 4724:  *stream << "\n" << Indent(8) << "}";
    %%%%%: 4724-block  0
    %%%%%: 4724-block  1
    %%%%%: 4724-block  2
    %%%%%: 4724-block  3
    %%%%%: 4724-block  4
    $$$$$: 4724-block  5
    $$$$$: 4724-block  6
    #####: 4725:}
        -: 4726:
        -: 4727:// Prints an JSON representation of a TestSuite object
    #####: 4728:void JsonUnitTestResultPrinter::PrintJsonTestSuite(
        -: 4729:    std::ostream* stream, const TestSuite& test_suite) {
    #####: 4730:  const std::string kTestsuite = "testsuite";
    %%%%%: 4730-block  0
    $$$$$: 4730-block  1
    $$$$$: 4730-block  2
    #####: 4731:  const std::string kIndent = Indent(6);
    $$$$$: 4731-block  0
        -: 4732:
    #####: 4733:  *stream << Indent(4) << "{\n";
    %%%%%: 4733-block  0
    %%%%%: 4733-block  1
    %%%%%: 4733-block  2
    %%%%%: 4733-block  3
    $$$$$: 4733-block  4
    $$$$$: 4733-block  5
    #####: 4734:  OutputJsonKey(stream, kTestsuite, "name", test_suite.name(), kIndent);
    %%%%%: 4734-block  0
    %%%%%: 4734-block  1
    %%%%%: 4734-block  2
    $$$$$: 4734-block  3
    $$$$$: 4734-block  4
    $$$$$: 4734-block  5
    $$$$$: 4734-block  6
    $$$$$: 4734-block  7
    $$$$$: 4734-block  8
    $$$$$: 4734-block  9
    $$$$$: 4734-block 10
    #####: 4735:  OutputJsonKey(stream, kTestsuite, "tests", test_suite.reportable_test_count(),
    %%%%%: 4735-block  0
    %%%%%: 4735-block  1
    %%%%%: 4735-block  2
    $$$$$: 4735-block  3
    $$$$$: 4735-block  4
    $$$$$: 4735-block  5
    $$$$$: 4735-block  6
        -: 4736:                kIndent);
    #####: 4737:  if (!GTEST_FLAG(list_tests)) {
    #####: 4738:    OutputJsonKey(stream, kTestsuite, "failures",
    %%%%%: 4738-block  0
    %%%%%: 4738-block  1
    %%%%%: 4738-block  2
    %%%%%: 4738-block  3
    $$$$$: 4738-block  4
    $$$$$: 4738-block  5
    $$$$$: 4738-block  6
    $$$$$: 4738-block  7
        -: 4739:                  test_suite.failed_test_count(), kIndent);
    #####: 4740:    OutputJsonKey(stream, kTestsuite, "disabled",
    %%%%%: 4740-block  0
    %%%%%: 4740-block  1
    %%%%%: 4740-block  2
    $$$$$: 4740-block  3
    $$$$$: 4740-block  4
    $$$$$: 4740-block  5
    $$$$$: 4740-block  6
        -: 4741:                  test_suite.reportable_disabled_test_count(), kIndent);
    #####: 4742:    OutputJsonKey(stream, kTestsuite, "errors", 0, kIndent);
    %%%%%: 4742-block  0
    %%%%%: 4742-block  1
    $$$$$: 4742-block  2
    $$$$$: 4742-block  3
    $$$$$: 4742-block  4
    $$$$$: 4742-block  5
    #####: 4743:    OutputJsonKey(
    %%%%%: 4743-block  0
    %%%%%: 4743-block  1
    %%%%%: 4743-block  2
    $$$$$: 4743-block  3
    $$$$$: 4743-block  4
    $$$$$: 4743-block  5
    $$$$$: 4743-block  6
        -: 4744:        stream, kTestsuite, "timestamp",
    #####: 4745:        FormatEpochTimeInMillisAsRFC3339(test_suite.start_timestamp()),
    $$$$$: 4745-block  0
    $$$$$: 4745-block  1
        -: 4746:        kIndent);
    #####: 4747:    OutputJsonKey(stream, kTestsuite, "time",
    %%%%%: 4747-block  0
    %%%%%: 4747-block  1
    %%%%%: 4747-block  2
    $$$$$: 4747-block  3
    $$$$$: 4747-block  4
    $$$$$: 4747-block  5
    $$$$$: 4747-block  6
    #####: 4748:                  FormatTimeInMillisAsDuration(test_suite.elapsed_time()),
    $$$$$: 4748-block  0
    $$$$$: 4748-block  1
        -: 4749:                  kIndent, false);
    #####: 4750:    *stream << TestPropertiesAsJson(test_suite.ad_hoc_test_result(), kIndent)
    %%%%%: 4750-block  0
    $$$$$: 4750-block  1
    $$$$$: 4750-block  2
    #####: 4751:            << ",\n";
    %%%%%: 4751-block  0
    %%%%%: 4751-block  1
        -: 4752:  }
        -: 4753:
    #####: 4754:  *stream << kIndent << "\"" << kTestsuite << "\": [\n";
    %%%%%: 4754-block  0
    %%%%%: 4754-block  1
    %%%%%: 4754-block  2
    %%%%%: 4754-block  3
        -: 4755:
    #####: 4756:  bool comma = false;
    #####: 4757:  for (int i = 0; i < test_suite.total_test_count(); ++i) {
    %%%%%: 4757-block  0
    %%%%%: 4757-block  1
    %%%%%: 4757-block  2
    #####: 4758:    if (test_suite.GetTestInfo(i)->is_reportable()) {
    %%%%%: 4758-block  0
    %%%%%: 4758-block  1
    #####: 4759:      if (comma) {
    %%%%%: 4759-block  0
    #####: 4760:        *stream << ",\n";
    %%%%%: 4760-block  0
        -: 4761:      } else {
    #####: 4762:        comma = true;
    %%%%%: 4762-block  0
        -: 4763:      }
    #####: 4764:      OutputJsonTestInfo(stream, test_suite.name(), *test_suite.GetTestInfo(i));
    %%%%%: 4764-block  0
    %%%%%: 4764-block  1
        -: 4765:    }
        -: 4766:  }
    #####: 4767:  *stream << "\n" << kIndent << "]\n" << Indent(4) << "}";
    %%%%%: 4767-block  0
    %%%%%: 4767-block  1
    %%%%%: 4767-block  2
    %%%%%: 4767-block  3
    %%%%%: 4767-block  4
    %%%%%: 4767-block  5
    %%%%%: 4767-block  6
    $$$$$: 4767-block  7
    $$$$$: 4767-block  8
    #####: 4768:}
        -: 4769:
        -: 4770:// Prints a JSON summary of unit_test to output stream out.
    #####: 4771:void JsonUnitTestResultPrinter::PrintJsonUnitTest(std::ostream* stream,
        -: 4772:                                                  const UnitTest& unit_test) {
    #####: 4773:  const std::string kTestsuites = "testsuites";
    %%%%%: 4773-block  0
    $$$$$: 4773-block  1
    $$$$$: 4773-block  2
    #####: 4774:  const std::string kIndent = Indent(2);
    %%%%%: 4774-block  0
    $$$$$: 4774-block  1
    #####: 4775:  *stream << "{\n";
    %%%%%: 4775-block  0
        -: 4776:
    #####: 4777:  OutputJsonKey(stream, kTestsuites, "tests", unit_test.reportable_test_count(),
    %%%%%: 4777-block  0
    %%%%%: 4777-block  1
    %%%%%: 4777-block  2
    %%%%%: 4777-block  3
    $$$$$: 4777-block  4
    $$$$$: 4777-block  5
    $$$$$: 4777-block  6
    $$$$$: 4777-block  7
        -: 4778:                kIndent);
    #####: 4779:  OutputJsonKey(stream, kTestsuites, "failures", unit_test.failed_test_count(),
    %%%%%: 4779-block  0
    %%%%%: 4779-block  1
    %%%%%: 4779-block  2
    $$$$$: 4779-block  3
    $$$$$: 4779-block  4
    $$$$$: 4779-block  5
    $$$$$: 4779-block  6
        -: 4780:                kIndent);
    #####: 4781:  OutputJsonKey(stream, kTestsuites, "disabled",
    %%%%%: 4781-block  0
    %%%%%: 4781-block  1
    %%%%%: 4781-block  2
    $$$$$: 4781-block  3
    $$$$$: 4781-block  4
    $$$$$: 4781-block  5
    $$$$$: 4781-block  6
        -: 4782:                unit_test.reportable_disabled_test_count(), kIndent);
    #####: 4783:  OutputJsonKey(stream, kTestsuites, "errors", 0, kIndent);
    %%%%%: 4783-block  0
    %%%%%: 4783-block  1
    $$$$$: 4783-block  2
    $$$$$: 4783-block  3
    $$$$$: 4783-block  4
    $$$$$: 4783-block  5
    #####: 4784:  if (GTEST_FLAG(shuffle)) {
    #####: 4785:    OutputJsonKey(stream, kTestsuites, "random_seed", unit_test.random_seed(),
    %%%%%: 4785-block  0
    %%%%%: 4785-block  1
    %%%%%: 4785-block  2
    $$$$$: 4785-block  3
    $$$$$: 4785-block  4
    $$$$$: 4785-block  5
    $$$$$: 4785-block  6
        -: 4786:                  kIndent);
        -: 4787:  }
    #####: 4788:  OutputJsonKey(stream, kTestsuites, "timestamp",
    %%%%%: 4788-block  0
    %%%%%: 4788-block  1
    %%%%%: 4788-block  2
    $$$$$: 4788-block  3
    $$$$$: 4788-block  4
    $$$$$: 4788-block  5
    $$$$$: 4788-block  6
    #####: 4789:                FormatEpochTimeInMillisAsRFC3339(unit_test.start_timestamp()),
    %%%%%: 4789-block  0
    $$$$$: 4789-block  1
    $$$$$: 4789-block  2
        -: 4790:                kIndent);
    #####: 4791:  OutputJsonKey(stream, kTestsuites, "time",
    %%%%%: 4791-block  0
    %%%%%: 4791-block  1
    %%%%%: 4791-block  2
    $$$$$: 4791-block  3
    $$$$$: 4791-block  4
    $$$$$: 4791-block  5
    $$$$$: 4791-block  6
    #####: 4792:                FormatTimeInMillisAsDuration(unit_test.elapsed_time()), kIndent,
    $$$$$: 4792-block  0
    $$$$$: 4792-block  1
        -: 4793:                false);
        -: 4794:
    #####: 4795:  *stream << TestPropertiesAsJson(unit_test.ad_hoc_test_result(), kIndent)
    %%%%%: 4795-block  0
    $$$$$: 4795-block  1
    $$$$$: 4795-block  2
    #####: 4796:          << ",\n";
    %%%%%: 4796-block  0
    %%%%%: 4796-block  1
        -: 4797:
    #####: 4798:  OutputJsonKey(stream, kTestsuites, "name", "AllTests", kIndent);
    %%%%%: 4798-block  0
    %%%%%: 4798-block  1
    %%%%%: 4798-block  2
    $$$$$: 4798-block  3
    $$$$$: 4798-block  4
    $$$$$: 4798-block  5
    $$$$$: 4798-block  6
    $$$$$: 4798-block  7
    $$$$$: 4798-block  8
    $$$$$: 4798-block  9
    $$$$$: 4798-block 10
    #####: 4799:  *stream << kIndent << "\"" << kTestsuites << "\": [\n";
    %%%%%: 4799-block  0
    %%%%%: 4799-block  1
    %%%%%: 4799-block  2
        -: 4800:
    #####: 4801:  bool comma = false;
    #####: 4802:  for (int i = 0; i < unit_test.total_test_suite_count(); ++i) {
    %%%%%: 4802-block  0
    %%%%%: 4802-block  1
    %%%%%: 4802-block  2
    #####: 4803:    if (unit_test.GetTestSuite(i)->reportable_test_count() > 0) {
    %%%%%: 4803-block  0
    %%%%%: 4803-block  1
    %%%%%: 4803-block  2
    #####: 4804:      if (comma) {
    %%%%%: 4804-block  0
    #####: 4805:        *stream << ",\n";
    %%%%%: 4805-block  0
        -: 4806:      } else {
    #####: 4807:        comma = true;
    %%%%%: 4807-block  0
        -: 4808:      }
    #####: 4809:      PrintJsonTestSuite(stream, *unit_test.GetTestSuite(i));
    %%%%%: 4809-block  0
    %%%%%: 4809-block  1
        -: 4810:    }
        -: 4811:  }
        -: 4812:
        -: 4813:  // If there was a test failure outside of one of the test suites (like in a
        -: 4814:  // test environment) include that in the output.
    #####: 4815:  if (unit_test.ad_hoc_test_result().Failed()) {
    %%%%%: 4815-block  0
    %%%%%: 4815-block  1
    #####: 4816:    OutputJsonTestSuiteForTestResult(stream, unit_test.ad_hoc_test_result());
    %%%%%: 4816-block  0
        -: 4817:  }
        -: 4818:
    #####: 4819:  *stream << "\n" << kIndent << "]\n" << "}\n";
    %%%%%: 4819-block  0
    %%%%%: 4819-block  1
    %%%%%: 4819-block  2
    %%%%%: 4819-block  3
    #####: 4820:}
        -: 4821:
    #####: 4822:void JsonUnitTestResultPrinter::PrintJsonTestList(
        -: 4823:    std::ostream* stream, const std::vector<TestSuite*>& test_suites) {
    #####: 4824:  const std::string kTestsuites = "testsuites";
    %%%%%: 4824-block  0
    $$$$$: 4824-block  1
    $$$$$: 4824-block  2
    #####: 4825:  const std::string kIndent = Indent(2);
    %%%%%: 4825-block  0
    $$$$$: 4825-block  1
    #####: 4826:  *stream << "{\n";
    %%%%%: 4826-block  0
    #####: 4827:  int total_tests = 0;
    #####: 4828:  for (auto test_suite : test_suites) {
    %%%%%: 4828-block  0
    %%%%%: 4828-block  1
    %%%%%: 4828-block  2
    #####: 4829:    total_tests += test_suite->total_test_count();
        -: 4830:  }
    #####: 4831:  OutputJsonKey(stream, kTestsuites, "tests", total_tests, kIndent);
    %%%%%: 4831-block  0
    %%%%%: 4831-block  1
    %%%%%: 4831-block  2
    $$$$$: 4831-block  3
    $$$$$: 4831-block  4
    $$$$$: 4831-block  5
    $$$$$: 4831-block  6
        -: 4832:
    #####: 4833:  OutputJsonKey(stream, kTestsuites, "name", "AllTests", kIndent);
    %%%%%: 4833-block  0
    %%%%%: 4833-block  1
    %%%%%: 4833-block  2
    $$$$$: 4833-block  3
    $$$$$: 4833-block  4
    $$$$$: 4833-block  5
    $$$$$: 4833-block  6
    $$$$$: 4833-block  7
    $$$$$: 4833-block  8
    $$$$$: 4833-block  9
    $$$$$: 4833-block 10
    #####: 4834:  *stream << kIndent << "\"" << kTestsuites << "\": [\n";
    %%%%%: 4834-block  0
    %%%%%: 4834-block  1
    %%%%%: 4834-block  2
        -: 4835:
    #####: 4836:  for (size_t i = 0; i < test_suites.size(); ++i) {
    %%%%%: 4836-block  0
    %%%%%: 4836-block  1
    %%%%%: 4836-block  2
    #####: 4837:    if (i != 0) {
    %%%%%: 4837-block  0
    #####: 4838:      *stream << ",\n";
    %%%%%: 4838-block  0
        -: 4839:    }
    #####: 4840:    PrintJsonTestSuite(stream, *test_suites[i]);
    %%%%%: 4840-block  0
        -: 4841:  }
        -: 4842:
        -: 4843:  *stream << "\n"
        -: 4844:          << kIndent << "]\n"
    #####: 4845:          << "}\n";
    %%%%%: 4845-block  0
    %%%%%: 4845-block  1
    %%%%%: 4845-block  2
    %%%%%: 4845-block  3
    #####: 4846:}
        -: 4847:// Produces a string representing the test properties in a result as
        -: 4848:// a JSON dictionary.
    #####: 4849:std::string JsonUnitTestResultPrinter::TestPropertiesAsJson(
        -: 4850:    const TestResult& result, const std::string& indent) {
    #####: 4851:  Message attributes;
    %%%%%: 4851-block  0
    %%%%%: 4851-block  1
    $$$$$: 4851-block  2
    #####: 4852:  for (int i = 0; i < result.test_property_count(); ++i) {
    %%%%%: 4852-block  0
    %%%%%: 4852-block  1
    #####: 4853:    const TestProperty& property = result.GetTestProperty(i);
    %%%%%: 4853-block  0
    #####: 4854:    attributes << ",\n" << indent << "\"" << property.key() << "\": "
    %%%%%: 4854-block  0
    %%%%%: 4854-block  1
    %%%%%: 4854-block  2
    %%%%%: 4854-block  3
    %%%%%: 4854-block  4
    $$$$$: 4854-block  5
    #####: 4855:               << "\"" << EscapeJson(property.value()) << "\"";
    %%%%%: 4855-block  0
    %%%%%: 4855-block  1
    %%%%%: 4855-block  2
    %%%%%: 4855-block  3
    %%%%%: 4855-block  4
    %%%%%: 4855-block  5
    $$$$$: 4855-block  6
    $$$$$: 4855-block  7
    $$$$$: 4855-block  8
    $$$$$: 4855-block  9
    $$$$$: 4855-block 10
    $$$$$: 4855-block 11
        -: 4856:  }
    #####: 4857:  return attributes.GetString();
    %%%%%: 4857-block  0
    %%%%%: 4857-block  1
        -: 4858:}
        -: 4859:
        -: 4860:// End JsonUnitTestResultPrinter
        -: 4861:
        -: 4862:#if GTEST_CAN_STREAM_RESULTS_
        -: 4863:
        -: 4864:// Checks if str contains '=', '&', '%' or '\n' characters. If yes,
        -: 4865:// replaces them by "%xx" where xx is their hexadecimal value. For
        -: 4866:// example, replaces "=" with "%3D".  This algorithm is O(strlen(str))
        -: 4867:// in both time and space -- important as the input str may contain an
        -: 4868:// arbitrarily long test failure message and stack trace.
    #####: 4869:std::string StreamingListener::UrlEncode(const char* str) {
    #####: 4870:  std::string result;
    %%%%%: 4870-block  0
    #####: 4871:  result.reserve(strlen(str) + 1);
    #####: 4872:  for (char ch = *str; ch != '\0'; ch = *++str) {
    %%%%%: 4872-block  0
    %%%%%: 4872-block  1
    %%%%%: 4872-block  2
    #####: 4873:    switch (ch) {
    %%%%%: 4873-block  0
    #####: 4874:      case '%':
        -: 4875:      case '=':
        -: 4876:      case '&':
        -: 4877:      case '\n':
    #####: 4878:        result.append("%" + String::FormatByte(static_cast<unsigned char>(ch)));
    %%%%%: 4878-block  0
    %%%%%: 4878-block  1
    %%%%%: 4878-block  2
    %%%%%: 4878-block  3
    $$$$$: 4878-block  4
    $$$$$: 4878-block  5
    $$$$$: 4878-block  6
    $$$$$: 4878-block  7
    #####: 4879:        break;
    #####: 4880:      default:
    #####: 4881:        result.push_back(ch);
    %%%%%: 4881-block  0
    #####: 4882:        break;
    %%%%%: 4882-block  0
        -: 4883:    }
        -: 4884:  }
    #####: 4885:  return result;
    %%%%%: 4885-block  0
    %%%%%: 4885-block  1
        -: 4886:}
        -: 4887:
    #####: 4888:void StreamingListener::SocketWriter::MakeConnection() {
    #####: 4889:  GTEST_CHECK_(sockfd_ == -1)
    %%%%%: 4889-block  0
    %%%%%: 4889-block  1
    %%%%%: 4889-block  2
    %%%%%: 4889-block  3
    $$$$$: 4889-block  4
    $$$$$: 4889-block  5
    #####: 4890:      << "MakeConnection() can't be called when there is already a connection.";
    %%%%%: 4890-block  0
        -: 4891:
        -: 4892:  addrinfo hints;
    #####: 4893:  memset(&hints, 0, sizeof(hints));
    #####: 4894:  hints.ai_family = AF_UNSPEC;    // To allow both IPv4 and IPv6 addresses.
    #####: 4895:  hints.ai_socktype = SOCK_STREAM;
    #####: 4896:  addrinfo* servinfo = nullptr;
        -: 4897:
        -: 4898:  // Use the getaddrinfo() to get a linked list of IP addresses for
        -: 4899:  // the given host name.
    #####: 4900:  const int error_num = getaddrinfo(
    %%%%%: 4900-block  0
        -: 4901:      host_name_.c_str(), port_num_.c_str(), &hints, &servinfo);
    #####: 4902:  if (error_num != 0) {
    %%%%%: 4902-block  0
    #####: 4903:    GTEST_LOG_(WARNING) << "stream_result_to: getaddrinfo() failed: "
    %%%%%: 4903-block  0
    %%%%%: 4903-block  1
    %%%%%: 4903-block  2
    $$$$$: 4903-block  3
    $$$$$: 4903-block  4
    #####: 4904:                        << gai_strerror(error_num);
    %%%%%: 4904-block  0
        -: 4905:  }
        -: 4906:
        -: 4907:  // Loop through all the results and connect to the first we can.
    #####: 4908:  for (addrinfo* cur_addr = servinfo; sockfd_ == -1 && cur_addr != nullptr;
    %%%%%: 4908-block  0
    %%%%%: 4908-block  1
    %%%%%: 4908-block  2
    #####: 4909:       cur_addr = cur_addr->ai_next) {
    %%%%%: 4909-block  0
    #####: 4910:    sockfd_ = socket(
    %%%%%: 4910-block  0
        -: 4911:        cur_addr->ai_family, cur_addr->ai_socktype, cur_addr->ai_protocol);
    #####: 4912:    if (sockfd_ != -1) {
        -: 4913:      // Connect the client socket to the server socket.
    #####: 4914:      if (connect(sockfd_, cur_addr->ai_addr, cur_addr->ai_addrlen) == -1) {
    %%%%%: 4914-block  0
    %%%%%: 4914-block  1
    #####: 4915:        close(sockfd_);
    %%%%%: 4915-block  0
    #####: 4916:        sockfd_ = -1;
    %%%%%: 4916-block  0
        -: 4917:      }
        -: 4918:    }
        -: 4919:  }
        -: 4920:
    #####: 4921:  freeaddrinfo(servinfo);  // all done with this structure
    %%%%%: 4921-block  0
        -: 4922:
    #####: 4923:  if (sockfd_ == -1) {
    #####: 4924:    GTEST_LOG_(WARNING) << "stream_result_to: failed to connect to "
    %%%%%: 4924-block  0
    %%%%%: 4924-block  1
    %%%%%: 4924-block  2
    $$$$$: 4924-block  3
    $$$$$: 4924-block  4
    #####: 4925:                        << host_name_ << ":" << port_num_;
    %%%%%: 4925-block  0
    %%%%%: 4925-block  1
    %%%%%: 4925-block  2
        -: 4926:  }
    #####: 4927:}
    %%%%%: 4927-block  0
        -: 4928:
        -: 4929:// End of class Streaming Listener
        -: 4930:#endif  // GTEST_CAN_STREAM_RESULTS__
        -: 4931:
        -: 4932:// class OsStackTraceGetter
        -: 4933:
        -: 4934:const char* const OsStackTraceGetterInterface::kElidedFramesMarker =
        -: 4935:    "... " GTEST_NAME_ " internal frames ...";
        -: 4936:
    #####: 4937:std::string OsStackTraceGetter::CurrentStackTrace(int max_depth, int skip_count)
        -: 4938:    GTEST_LOCK_EXCLUDED_(mutex_) {
        -: 4939:#if GTEST_HAS_ABSL
        -: 4940:  std::string result;
        -: 4941:
        -: 4942:  if (max_depth <= 0) {
        -: 4943:    return result;
        -: 4944:  }
        -: 4945:
        -: 4946:  max_depth = std::min(max_depth, kMaxStackTraceDepth);
        -: 4947:
        -: 4948:  std::vector<void*> raw_stack(max_depth);
        -: 4949:  // Skips the frames requested by the caller, plus this function.
        -: 4950:  const int raw_stack_size =
        -: 4951:      absl::GetStackTrace(&raw_stack[0], max_depth, skip_count + 1);
        -: 4952:
        -: 4953:  void* caller_frame = nullptr;
        -: 4954:  {
        -: 4955:    MutexLock lock(&mutex_);
        -: 4956:    caller_frame = caller_frame_;
        -: 4957:  }
        -: 4958:
        -: 4959:  for (int i = 0; i < raw_stack_size; ++i) {
        -: 4960:    if (raw_stack[i] == caller_frame &&
        -: 4961:        !GTEST_FLAG(show_internal_stack_frames)) {
        -: 4962:      // Add a marker to the trace and stop adding frames.
        -: 4963:      absl::StrAppend(&result, kElidedFramesMarker, "\n");
        -: 4964:      break;
        -: 4965:    }
        -: 4966:
        -: 4967:    char tmp[1024];
        -: 4968:    const char* symbol = "(unknown)";
        -: 4969:    if (absl::Symbolize(raw_stack[i], tmp, sizeof(tmp))) {
        -: 4970:      symbol = tmp;
        -: 4971:    }
        -: 4972:
        -: 4973:    char line[1024];
        -: 4974:    snprintf(line, sizeof(line), "  %p: %s\n", raw_stack[i], symbol);
        -: 4975:    result += line;
        -: 4976:  }
        -: 4977:
        -: 4978:  return result;
        -: 4979:
        -: 4980:#else  // !GTEST_HAS_ABSL
        -: 4981:  static_cast<void>(max_depth);
        -: 4982:  static_cast<void>(skip_count);
    #####: 4983:  return "";
    %%%%%: 4983-block  0
    %%%%%: 4983-block  1
    %%%%%: 4983-block  2
    $$$$$: 4983-block  3
        -: 4984:#endif  // GTEST_HAS_ABSL
        -: 4985:}
        -: 4986:
      157: 4987:void OsStackTraceGetter::UponLeavingGTest() GTEST_LOCK_EXCLUDED_(mutex_) {
        -: 4988:#if GTEST_HAS_ABSL
        -: 4989:  void* caller_frame = nullptr;
        -: 4990:  if (absl::GetStackTrace(&caller_frame, 1, 3) <= 0) {
        -: 4991:    caller_frame = nullptr;
        -: 4992:  }
        -: 4993:
        -: 4994:  MutexLock lock(&mutex_);
        -: 4995:  caller_frame_ = caller_frame;
        -: 4996:#endif  // GTEST_HAS_ABSL
      157: 4997:}
        -: 4998:
        -: 4999:// A helper class that creates the premature-exit file in its
        -: 5000:// constructor and deletes the file in its destructor.
        -: 5001:class ScopedPrematureExitFile {
        -: 5002: public:
        1: 5003:  explicit ScopedPrematureExitFile(const char* premature_exit_filepath)
        1: 5004:      : premature_exit_filepath_(premature_exit_filepath ?
       1*: 5005:                                 premature_exit_filepath : "") {
        1: 5005-block  0
    %%%%%: 5005-block  1
        1: 5005-block  2
        1: 5005-block  3
        1: 5005-block  4
    $$$$$: 5005-block  5
    $$$$$: 5005-block  6
    $$$$$: 5005-block  7
        -: 5006:    // If a path to the premature-exit file is specified...
        1: 5007:    if (!premature_exit_filepath_.empty()) {
        -: 5008:      // create the file with a single "0" character in it.  I/O
        -: 5009:      // errors are ignored as there's nothing better we can do and we
        -: 5010:      // don't want to fail the test because of this.
    #####: 5011:      FILE* pfile = posix::FOpen(premature_exit_filepath, "w");
    %%%%%: 5011-block  0
    #####: 5012:      fwrite("0", 1, 1, pfile);
    %%%%%: 5012-block  0
    #####: 5013:      fclose(pfile);
    %%%%%: 5013-block  0
        -: 5014:    }
        1: 5015:  }
        1: 5015-block  0
        -: 5016:
        1: 5017:  ~ScopedPrematureExitFile() {
        1: 5017-block  0
        -: 5018:#if !defined GTEST_OS_ESP8266
        1: 5019:    if (!premature_exit_filepath_.empty()) {
        1: 5019-block  0
    #####: 5020:      int retval = remove(premature_exit_filepath_.c_str());
    %%%%%: 5020-block  0
    #####: 5021:      if (retval) {
    #####: 5022:        GTEST_LOG_(ERROR) << "Failed to remove premature exit filepath \""
    %%%%%: 5022-block  0
    #####: 5023:                          << premature_exit_filepath_ << "\" with error "
    #####: 5024:                          << retval;
        -: 5025:      }
        -: 5026:    }
        -: 5027:#endif
        1: 5028:  }
        -: 5029:
        -: 5030: private:
        -: 5031:  const std::string premature_exit_filepath_;
        -: 5032:
        -: 5033:  GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedPrematureExitFile);
        -: 5034:};
        -: 5035:
        -: 5036:}  // namespace internal
        -: 5037:
        -: 5038:// class TestEventListeners
        -: 5039:
        1: 5040:TestEventListeners::TestEventListeners()
        1: 5041:    : repeater_(new internal::TestEventRepeater()),
        1: 5041-block  0
        -: 5042:      default_result_printer_(nullptr),
        1: 5043:      default_xml_generator_(nullptr) {}
        -: 5044:
        1: 5045:TestEventListeners::~TestEventListeners() { delete repeater_; }
        1: 5045-block  0
        1: 5045-block  1
        -: 5046:
        -: 5047:// Returns the standard listener responsible for the default console
        -: 5048:// output.  Can be removed from the listeners list to shut down default
        -: 5049:// console output.  Note that removing this object from the listener list
        -: 5050:// with Release transfers its ownership to the user.
        1: 5051:void TestEventListeners::Append(TestEventListener* listener) {
        1: 5052:  repeater_->Append(listener);
        1: 5052-block  0
        1: 5053:}
        -: 5054:
        -: 5055:// Removes the given event listener from the list and returns it.  It then
        -: 5056:// becomes the caller's responsibility to delete the listener. Returns
        -: 5057:// NULL if the listener is not found in the list.
        1: 5058:TestEventListener* TestEventListeners::Release(TestEventListener* listener) {
        1: 5059:  if (listener == default_result_printer_)
        1: 5059-block  0
        1: 5060:    default_result_printer_ = nullptr;
        1: 5060-block  0
    #####: 5061:  else if (listener == default_xml_generator_)
    %%%%%: 5061-block  0
    #####: 5062:    default_xml_generator_ = nullptr;
    %%%%%: 5062-block  0
        1: 5063:  return repeater_->Release(listener);
        1: 5063-block  0
        -: 5064:}
        -: 5065:
        -: 5066:// Returns repeater that broadcasts the TestEventListener events to all
        -: 5067:// subscribers.
       33: 5068:TestEventListener* TestEventListeners::repeater() { return repeater_; }
       33: 5068-block  0
        -: 5069:
        -: 5070:// Sets the default_result_printer attribute to the provided listener.
        -: 5071:// The listener is also added to the listener list and previous
        -: 5072:// default_result_printer is removed from it and deleted. The listener can
        -: 5073:// also be NULL in which case it will not be added to the list. Does
        -: 5074:// nothing if the previous and the current listener objects are the same.
        1: 5075:void TestEventListeners::SetDefaultResultPrinter(TestEventListener* listener) {
        1: 5076:  if (default_result_printer_ != listener) {
        1: 5076-block  0
        -: 5077:    // It is an error to pass this method a listener that is already in the
        -: 5078:    // list.
       1*: 5079:    delete Release(default_result_printer_);
        1: 5079-block  0
    %%%%%: 5079-block  1
        1: 5080:    default_result_printer_ = listener;
        1: 5081:    if (listener != nullptr) Append(listener);
        1: 5081-block  0
        1: 5081-block  1
        -: 5082:  }
        1: 5083:}
        -: 5084:
        -: 5085:// Sets the default_xml_generator attribute to the provided listener.  The
        -: 5086:// listener is also added to the listener list and previous
        -: 5087:// default_xml_generator is removed from it and deleted. The listener can
        -: 5088:// also be NULL in which case it will not be added to the list. Does
        -: 5089:// nothing if the previous and the current listener objects are the same.
    #####: 5090:void TestEventListeners::SetDefaultXmlGenerator(TestEventListener* listener) {
    #####: 5091:  if (default_xml_generator_ != listener) {
    %%%%%: 5091-block  0
        -: 5092:    // It is an error to pass this method a listener that is already in the
        -: 5093:    // list.
    #####: 5094:    delete Release(default_xml_generator_);
    %%%%%: 5094-block  0
    %%%%%: 5094-block  1
    #####: 5095:    default_xml_generator_ = listener;
    #####: 5096:    if (listener != nullptr) Append(listener);
    %%%%%: 5096-block  0
    %%%%%: 5096-block  1
        -: 5097:  }
    #####: 5098:}
        -: 5099:
        -: 5100:// Controls whether events will be forwarded by the repeater to the
        -: 5101:// listeners in the list.
    #####: 5102:bool TestEventListeners::EventForwardingEnabled() const {
    #####: 5103:  return repeater_->forwarding_enabled();
    %%%%%: 5103-block  0
        -: 5104:}
        -: 5105:
    #####: 5106:void TestEventListeners::SuppressEventForwarding() {
    #####: 5107:  repeater_->set_forwarding_enabled(false);
    %%%%%: 5107-block  0
    #####: 5108:}
        -: 5109:
        -: 5110:// class UnitTest
        -: 5111:
        -: 5112:// Gets the singleton UnitTest object.  The first time this method is
        -: 5113:// called, a UnitTest object is constructed and returned.  Consecutive
        -: 5114:// calls will return the same object.
        -: 5115://
        -: 5116:// We don't protect this under mutex_ as a user is not supposed to
        -: 5117:// call this before main() starts, from which point on the return
        -: 5118:// value will never change.
      454: 5119:UnitTest* UnitTest::GetInstance() {
        -: 5120:  // CodeGear C++Builder insists on a public destructor for the
        -: 5121:  // default implementation.  Use this implementation to keep good OO
        -: 5122:  // design with private destructor.
        -: 5123:
        -: 5124:#if defined(__BORLANDC__)
        -: 5125:  static UnitTest* const instance = new UnitTest;
        -: 5126:  return instance;
        -: 5127:#else
      454: 5128:  static UnitTest instance;
      454: 5128-block  0
        1: 5128-block  1
        1: 5128-block  2
        1: 5128-block  3
    $$$$$: 5128-block  4
    $$$$$: 5128-block  5
      454: 5129:  return &instance;
      454: 5129-block  0
      454: 5129-block  1
        -: 5130:#endif  // defined(__BORLANDC__)
        -: 5131:}
        -: 5132:
        -: 5133:// Gets the number of successful test suites.
    #####: 5134:int UnitTest::successful_test_suite_count() const {
    #####: 5135:  return impl()->successful_test_suite_count();
    %%%%%: 5135-block  0
        -: 5136:}
        -: 5137:
        -: 5138:// Gets the number of failed test suites.
    #####: 5139:int UnitTest::failed_test_suite_count() const {
    #####: 5140:  return impl()->failed_test_suite_count();
    %%%%%: 5140-block  0
        -: 5141:}
        -: 5142:
        -: 5143:// Gets the number of all test suites.
    #####: 5144:int UnitTest::total_test_suite_count() const {
    #####: 5145:  return impl()->total_test_suite_count();
    %%%%%: 5145-block  0
        -: 5146:}
        -: 5147:
        -: 5148:// Gets the number of all test suites that contain at least one test
        -: 5149:// that should run.
        2: 5150:int UnitTest::test_suite_to_run_count() const {
        2: 5151:  return impl()->test_suite_to_run_count();
        2: 5151-block  0
        -: 5152:}
        -: 5153:
        -: 5154://  Legacy API is deprecated but still available
        -: 5155:#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
    #####: 5156:int UnitTest::successful_test_case_count() const {
    #####: 5157:  return impl()->successful_test_suite_count();
    %%%%%: 5157-block  0
        -: 5158:}
    #####: 5159:int UnitTest::failed_test_case_count() const {
    #####: 5160:  return impl()->failed_test_suite_count();
    %%%%%: 5160-block  0
        -: 5161:}
    #####: 5162:int UnitTest::total_test_case_count() const {
    #####: 5163:  return impl()->total_test_suite_count();
    %%%%%: 5163-block  0
        -: 5164:}
    #####: 5165:int UnitTest::test_case_to_run_count() const {
    #####: 5166:  return impl()->test_suite_to_run_count();
    %%%%%: 5166-block  0
        -: 5167:}
        -: 5168:#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        -: 5169:
        -: 5170:// Gets the number of successful tests.
        1: 5171:int UnitTest::successful_test_count() const {
        1: 5172:  return impl()->successful_test_count();
        1: 5172-block  0
        -: 5173:}
        -: 5174:
        -: 5175:// Gets the number of skipped tests.
        1: 5176:int UnitTest::skipped_test_count() const {
        1: 5177:  return impl()->skipped_test_count();
        1: 5177-block  0
        -: 5178:}
        -: 5179:
        -: 5180:// Gets the number of failed tests.
    #####: 5181:int UnitTest::failed_test_count() const { return impl()->failed_test_count(); }
    %%%%%: 5181-block  0
        -: 5182:
        -: 5183:// Gets the number of disabled tests that will be reported in the XML report.
        1: 5184:int UnitTest::reportable_disabled_test_count() const {
        1: 5185:  return impl()->reportable_disabled_test_count();
        1: 5185-block  0
        -: 5186:}
        -: 5187:
        -: 5188:// Gets the number of disabled tests.
    #####: 5189:int UnitTest::disabled_test_count() const {
    #####: 5190:  return impl()->disabled_test_count();
    %%%%%: 5190-block  0
        -: 5191:}
        -: 5192:
        -: 5193:// Gets the number of tests to be printed in the XML report.
    #####: 5194:int UnitTest::reportable_test_count() const {
    #####: 5195:  return impl()->reportable_test_count();
    %%%%%: 5195-block  0
        -: 5196:}
        -: 5197:
        -: 5198:// Gets the number of all tests.
    #####: 5199:int UnitTest::total_test_count() const { return impl()->total_test_count(); }
    %%%%%: 5199-block  0
        -: 5200:
        -: 5201:// Gets the number of tests that should run.
        2: 5202:int UnitTest::test_to_run_count() const { return impl()->test_to_run_count(); }
        2: 5202-block  0
        -: 5203:
        -: 5204:// Gets the time of the test program start, in ms from the start of the
        -: 5205:// UNIX epoch.
    #####: 5206:internal::TimeInMillis UnitTest::start_timestamp() const {
    #####: 5207:    return impl()->start_timestamp();
    %%%%%: 5207-block  0
        -: 5208:}
        -: 5209:
        -: 5210:// Gets the elapsed time, in milliseconds.
        1: 5211:internal::TimeInMillis UnitTest::elapsed_time() const {
        1: 5212:  return impl()->elapsed_time();
        1: 5212-block  0
        -: 5213:}
        -: 5214:
        -: 5215:// Returns true if and only if the unit test passed (i.e. all test suites
        -: 5216:// passed).
        1: 5217:bool UnitTest::Passed() const { return impl()->Passed(); }
        1: 5217-block  0
        -: 5218:
        -: 5219:// Returns true if and only if the unit test failed (i.e. some test suite
        -: 5220:// failed or something outside of all tests failed).
    #####: 5221:bool UnitTest::Failed() const { return impl()->Failed(); }
    %%%%%: 5221-block  0
        -: 5222:
        -: 5223:// Gets the i-th test suite among all the test suites. i can range from 0 to
        -: 5224:// total_test_suite_count() - 1. If i is not in that range, returns NULL.
    #####: 5225:const TestSuite* UnitTest::GetTestSuite(int i) const {
    #####: 5226:  return impl()->GetTestSuite(i);
    %%%%%: 5226-block  0
        -: 5227:}
        -: 5228:
        -: 5229://  Legacy API is deprecated but still available
        -: 5230:#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
    #####: 5231:const TestCase* UnitTest::GetTestCase(int i) const {
    #####: 5232:  return impl()->GetTestCase(i);
    %%%%%: 5232-block  0
        -: 5233:}
        -: 5234:#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        -: 5235:
        -: 5236:// Returns the TestResult containing information on test failures and
        -: 5237:// properties logged outside of individual test suites.
    #####: 5238:const TestResult& UnitTest::ad_hoc_test_result() const {
    #####: 5239:  return *impl()->ad_hoc_test_result();
    %%%%%: 5239-block  0
        -: 5240:}
        -: 5241:
        -: 5242:// Gets the i-th test suite among all the test suites. i can range from 0 to
        -: 5243:// total_test_suite_count() - 1. If i is not in that range, returns NULL.
    #####: 5244:TestSuite* UnitTest::GetMutableTestSuite(int i) {
    #####: 5245:  return impl()->GetMutableSuiteCase(i);
    %%%%%: 5245-block  0
        -: 5246:}
        -: 5247:
        -: 5248:// Returns the list of event listeners that can be used to track events
        -: 5249:// inside Google Test.
       32: 5250:TestEventListeners& UnitTest::listeners() {
       32: 5251:  return *impl()->listeners();
       32: 5251-block  0
        -: 5252:}
        -: 5253:
        -: 5254:// Registers and returns a global test environment.  When a test
        -: 5255:// program is run, all global test environments will be set-up in the
        -: 5256:// order they were registered.  After all tests in the program have
        -: 5257:// finished, all global test environments will be torn-down in the
        -: 5258:// *reverse* order they were registered.
        -: 5259://
        -: 5260:// The UnitTest object takes ownership of the given environment.
        -: 5261://
        -: 5262:// We don't protect this under mutex_, as we only support calling it
        -: 5263:// from the main thread.
    #####: 5264:Environment* UnitTest::AddEnvironment(Environment* env) {
    #####: 5265:  if (env == nullptr) {
    %%%%%: 5265-block  0
    #####: 5266:    return nullptr;
    %%%%%: 5266-block  0
        -: 5267:  }
        -: 5268:
    #####: 5269:  impl_->environments().push_back(env);
    %%%%%: 5269-block  0
    #####: 5270:  return env;
        -: 5271:}
        -: 5272:
        -: 5273:// Adds a TestPartResult to the current TestResult object.  All Google Test
        -: 5274:// assertion macros (e.g. ASSERT_TRUE, EXPECT_EQ, etc) eventually call
        -: 5275:// this to report their results.  The user code should use the
        -: 5276:// assertion macros instead of calling this directly.
    #####: 5277:void UnitTest::AddTestPartResult(
        -: 5278:    TestPartResult::Type result_type,
        -: 5279:    const char* file_name,
        -: 5280:    int line_number,
        -: 5281:    const std::string& message,
        -: 5282:    const std::string& os_stack_trace) GTEST_LOCK_EXCLUDED_(mutex_) {
    #####: 5283:  Message msg;
    %%%%%: 5283-block  0
    $$$$$: 5283-block  1
    #####: 5284:  msg << message;
    %%%%%: 5284-block  0
        -: 5285:
    #####: 5286:  internal::MutexLock lock(&mutex_);
    %%%%%: 5286-block  0
    $$$$$: 5286-block  1
    #####: 5287:  if (impl_->gtest_trace_stack().size() > 0) {
    %%%%%: 5287-block  0
    %%%%%: 5287-block  1
    #####: 5288:    msg << "\n" << GTEST_NAME_ << " trace:";
    %%%%%: 5288-block  0
    %%%%%: 5288-block  1
    %%%%%: 5288-block  2
        -: 5289:
    #####: 5290:    for (size_t i = impl_->gtest_trace_stack().size(); i > 0; --i) {
    %%%%%: 5290-block  0
    %%%%%: 5290-block  1
    %%%%%: 5290-block  2
    #####: 5291:      const internal::TraceInfo& trace = impl_->gtest_trace_stack()[i - 1];
    %%%%%: 5291-block  0
    %%%%%: 5291-block  1
    #####: 5292:      msg << "\n" << internal::FormatFileLocation(trace.file, trace.line)
    %%%%%: 5292-block  0
    %%%%%: 5292-block  1
    %%%%%: 5292-block  2
    $$$$$: 5292-block  3
    $$$$$: 5292-block  4
    #####: 5293:          << " " << trace.message;
    %%%%%: 5293-block  0
    %%%%%: 5293-block  1
        -: 5294:    }
        -: 5295:  }
        -: 5296:
    #####: 5297:  if (os_stack_trace.c_str() != nullptr && !os_stack_trace.empty()) {
    %%%%%: 5297-block  0
    %%%%%: 5297-block  1
    %%%%%: 5297-block  2
    %%%%%: 5297-block  3
    %%%%%: 5297-block  4
    #####: 5298:    msg << internal::kStackTraceMarker << os_stack_trace;
    %%%%%: 5298-block  0
    %%%%%: 5298-block  1
        -: 5299:  }
        -: 5300:
        -: 5301:  const TestPartResult result = TestPartResult(
    #####: 5302:      result_type, file_name, line_number, msg.GetString().c_str());
    %%%%%: 5302-block  0
    %%%%%: 5302-block  1
    %%%%%: 5302-block  2
    $$$$$: 5302-block  3
    $$$$$: 5302-block  4
    #####: 5303:  impl_->GetTestPartResultReporterForCurrentThread()->
    #####: 5304:      ReportTestPartResult(result);
    %%%%%: 5304-block  0
        -: 5305:
    #####: 5306:  if (result_type != TestPartResult::kSuccess &&
    %%%%%: 5306-block  0
    %%%%%: 5306-block  1
        -: 5307:      result_type != TestPartResult::kSkip) {
        -: 5308:    // gtest_break_on_failure takes precedence over
        -: 5309:    // gtest_throw_on_failure.  This allows a user to set the latter
        -: 5310:    // in the code (perhaps in order to use Google Test assertions
        -: 5311:    // with another testing framework) and specify the former on the
        -: 5312:    // command line for debugging.
    #####: 5313:    if (GTEST_FLAG(break_on_failure)) {
    %%%%%: 5313-block  0
        -: 5314:#if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT
        -: 5315:      // Using DebugBreak on Windows allows gtest to still break into a debugger
        -: 5316:      // when a failure happens and both the --gtest_break_on_failure and
        -: 5317:      // the --gtest_catch_exceptions flags are specified.
        -: 5318:      DebugBreak();
        -: 5319:#elif (!defined(__native_client__)) &&            \
        -: 5320:    ((defined(__clang__) || defined(__GNUC__)) && \
        -: 5321:     (defined(__x86_64__) || defined(__i386__)))
        -: 5322:      // with clang/gcc we can achieve the same effect on x86 by invoking int3
    #####: 5323:      asm("int3");
    %%%%%: 5323-block  0
        -: 5324:#else
        -: 5325:      // Dereference nullptr through a volatile pointer to prevent the compiler
        -: 5326:      // from removing. We use this rather than abort() or __builtin_trap() for
        -: 5327:      // portability: some debuggers don't correctly trap abort().
        -: 5328:      *static_cast<volatile int*>(nullptr) = 1;
        -: 5329:#endif  // GTEST_OS_WINDOWS
    #####: 5330:    } else if (GTEST_FLAG(throw_on_failure)) {
    %%%%%: 5330-block  0
        -: 5331:#if GTEST_HAS_EXCEPTIONS
    #####: 5332:      throw internal::GoogleTestFailureException(result);
    %%%%%: 5332-block  0
    %%%%%: 5332-block  1
    $$$$$: 5332-block  2
        -: 5333:#else
        -: 5334:      // We cannot call abort() as it generates a pop-up in debug mode
        -: 5335:      // that cannot be suppressed in VC 7.1 or below.
        -: 5336:      exit(1);
        -: 5337:#endif
        -: 5338:    }
        -: 5339:  }
    #####: 5340:}
        -: 5341:
        -: 5342:// Adds a TestProperty to the current TestResult object when invoked from
        -: 5343:// inside a test, to current TestSuite's ad_hoc_test_result_ when invoked
        -: 5344:// from SetUpTestSuite or TearDownTestSuite, or to the global property set
        -: 5345:// when invoked elsewhere.  If the result already contains a property with
        -: 5346:// the same key, the value will be updated.
    #####: 5347:void UnitTest::RecordProperty(const std::string& key,
        -: 5348:                              const std::string& value) {
    #####: 5349:  impl_->RecordProperty(TestProperty(key, value));
    %%%%%: 5349-block  0
    %%%%%: 5349-block  1
    $$$$$: 5349-block  2
    #####: 5350:}
        -: 5351:
        -: 5352:// Runs all tests in this UnitTest object and prints the result.
        -: 5353:// Returns 0 if successful, or 1 otherwise.
        -: 5354://
        -: 5355:// We don't protect this under mutex_, as we only support calling it
        -: 5356:// from the main thread.
        1: 5357:int UnitTest::Run() {
        -: 5358:  const bool in_death_test_child_process =
        1: 5359:      internal::GTEST_FLAG(internal_run_death_test).length() > 0;
        1: 5359-block  0
        -: 5360:
        -: 5361:  // Google Test implements this protocol for catching that a test
        -: 5362:  // program exits before returning control to Google Test:
        -: 5363:  //
        -: 5364:  //   1. Upon start, Google Test creates a file whose absolute path
        -: 5365:  //      is specified by the environment variable
        -: 5366:  //      TEST_PREMATURE_EXIT_FILE.
        -: 5367:  //   2. When Google Test has finished its work, it deletes the file.
        -: 5368:  //
        -: 5369:  // This allows a test runner to set TEST_PREMATURE_EXIT_FILE before
        -: 5370:  // running a Google-Test-based test program and check the existence
        -: 5371:  // of the file at the end of the test execution to see if it has
        -: 5372:  // exited prematurely.
        -: 5373:
        -: 5374:  // If we are in the child process of a death test, don't
        -: 5375:  // create/delete the premature exit file, as doing so is unnecessary
        -: 5376:  // and will confuse the parent process.  Otherwise, create/delete
        -: 5377:  // the file upon entering/leaving this function.  If the program
        -: 5378:  // somehow exits before this function has a chance to return, the
        -: 5379:  // premature-exit file will be left undeleted, causing a test runner
        -: 5380:  // that understands the premature-exit-file protocol to report the
        -: 5381:  // test as having failed.
        -: 5382:  const internal::ScopedPrematureExitFile premature_exit_file(
        -: 5383:      in_death_test_child_process
        -: 5384:          ? nullptr
       1*: 5385:          : internal::posix::GetEnv("TEST_PREMATURE_EXIT_FILE"));
    %%%%%: 5385-block  0
        1: 5385-block  1
        1: 5385-block  2
    $$$$$: 5385-block  3
        -: 5386:
        -: 5387:  // Captures the value of GTEST_FLAG(catch_exceptions).  This value will be
        -: 5388:  // used for the duration of the program.
        1: 5389:  impl()->set_catch_exceptions(GTEST_FLAG(catch_exceptions));
        1: 5389-block  0
        -: 5390:
        -: 5391:#if GTEST_OS_WINDOWS
        -: 5392:  // Either the user wants Google Test to catch exceptions thrown by the
        -: 5393:  // tests or this is executing in the context of death test child
        -: 5394:  // process. In either case the user does not want to see pop-up dialogs
        -: 5395:  // about crashes - they are expected.
        -: 5396:  if (impl()->catch_exceptions() || in_death_test_child_process) {
        -: 5397:# if !GTEST_OS_WINDOWS_MOBILE && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT
        -: 5398:    // SetErrorMode doesn't exist on CE.
        -: 5399:    SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOALIGNMENTFAULTEXCEPT |
        -: 5400:                 SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX);
        -: 5401:# endif  // !GTEST_OS_WINDOWS_MOBILE
        -: 5402:
        -: 5403:# if (defined(_MSC_VER) || GTEST_OS_WINDOWS_MINGW) && !GTEST_OS_WINDOWS_MOBILE
        -: 5404:    // Death test children can be terminated with _abort().  On Windows,
        -: 5405:    // _abort() can show a dialog with a warning message.  This forces the
        -: 5406:    // abort message to go to stderr instead.
        -: 5407:    _set_error_mode(_OUT_TO_STDERR);
        -: 5408:# endif
        -: 5409:
        -: 5410:# if defined(_MSC_VER) && !GTEST_OS_WINDOWS_MOBILE
        -: 5411:    // In the debug version, Visual Studio pops up a separate dialog
        -: 5412:    // offering a choice to debug the aborted program. We need to suppress
        -: 5413:    // this dialog or it will pop up for every EXPECT/ASSERT_DEATH statement
        -: 5414:    // executed. Google Test will notify the user of any unexpected
        -: 5415:    // failure via stderr.
        -: 5416:    if (!GTEST_FLAG(break_on_failure))
        -: 5417:      _set_abort_behavior(
        -: 5418:          0x0,                                    // Clear the following flags:
        -: 5419:          _WRITE_ABORT_MSG | _CALL_REPORTFAULT);  // pop-up window, core dump.
        -: 5420:
        -: 5421:    // In debug mode, the Windows CRT can crash with an assertion over invalid
        -: 5422:    // input (e.g. passing an invalid file descriptor).  The default handling
        -: 5423:    // for these assertions is to pop up a dialog and wait for user input.
        -: 5424:    // Instead ask the CRT to dump such assertions to stderr non-interactively.
        -: 5425:    if (!IsDebuggerPresent()) {
        -: 5426:      (void)_CrtSetReportMode(_CRT_ASSERT,
        -: 5427:                              _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
        -: 5428:      (void)_CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);
        -: 5429:    }
        -: 5430:# endif
        -: 5431:  }
        -: 5432:#endif  // GTEST_OS_WINDOWS
        -: 5433:
        1: 5434:  return internal::HandleExceptionsInMethodIfSupported(
        -: 5435:      impl(),
        -: 5436:      &internal::UnitTestImpl::RunAllTests,
       2*: 5437:      "auxiliary test code (environments or event listeners)") ? 0 : 1;
        1: 5437-block  0
        1: 5437-block  1
    %%%%%: 5437-block  2
        1: 5437-block  3
        1: 5437-block  4
        -: 5438:}
        -: 5439:
        -: 5440:// Returns the working directory when the first TEST() or TEST_F() was
        -: 5441:// executed.
    #####: 5442:const char* UnitTest::original_working_dir() const {
    #####: 5443:  return impl_->original_working_dir_.c_str();
    %%%%%: 5443-block  0
        -: 5444:}
        -: 5445:
        -: 5446:// Returns the TestSuite object for the test that's currently running,
        -: 5447:// or NULL if no test is running.
    #####: 5448:const TestSuite* UnitTest::current_test_suite() const
        -: 5449:    GTEST_LOCK_EXCLUDED_(mutex_) {
    #####: 5450:  internal::MutexLock lock(&mutex_);
    %%%%%: 5450-block  0
    #####: 5451:  return impl_->current_test_suite();
    %%%%%: 5451-block  0
    %%%%%: 5451-block  1
        -: 5452:}
        -: 5453:
        -: 5454:// Legacy API is still available but deprecated
        -: 5455:#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
    #####: 5456:const TestCase* UnitTest::current_test_case() const
        -: 5457:    GTEST_LOCK_EXCLUDED_(mutex_) {
    #####: 5458:  internal::MutexLock lock(&mutex_);
    %%%%%: 5458-block  0
    #####: 5459:  return impl_->current_test_suite();
    %%%%%: 5459-block  0
    %%%%%: 5459-block  1
        -: 5460:}
        -: 5461:#endif
        -: 5462:
        -: 5463:// Returns the TestInfo object for the test that's currently running,
        -: 5464:// or NULL if no test is running.
    #####: 5465:const TestInfo* UnitTest::current_test_info() const
        -: 5466:    GTEST_LOCK_EXCLUDED_(mutex_) {
    #####: 5467:  internal::MutexLock lock(&mutex_);
    %%%%%: 5467-block  0
    #####: 5468:  return impl_->current_test_info();
    %%%%%: 5468-block  0
    %%%%%: 5468-block  1
        -: 5469:}
        -: 5470:
        -: 5471:// Returns the random seed used at the start of the current test run.
    #####: 5472:int UnitTest::random_seed() const { return impl_->random_seed(); }
    %%%%%: 5472-block  0
        -: 5473:
        -: 5474:// Returns ParameterizedTestSuiteRegistry object used to keep track of
        -: 5475:// value-parameterized tests and instantiate and register them.
        -: 5476:internal::ParameterizedTestSuiteRegistry&
    #####: 5477:UnitTest::parameterized_test_registry() GTEST_LOCK_EXCLUDED_(mutex_) {
    #####: 5478:  return impl_->parameterized_test_registry();
    %%%%%: 5478-block  0
        -: 5479:}
        -: 5480:
        -: 5481:// Creates an empty UnitTest.
        1: 5482:UnitTest::UnitTest() {
        1: 5482-block  0
    $$$$$: 5482-block  1
        1: 5483:  impl_ = new internal::UnitTestImpl(this);
        1: 5483-block  0
    $$$$$: 5483-block  1
        1: 5484:}
        1: 5484-block  0
        -: 5485:
        -: 5486:// Destructor of UnitTest.
       1*: 5487:UnitTest::~UnitTest() {
        1: 5488:  delete impl_;
       1*: 5489:}
------------------
_ZN7testing8UnitTestD0Ev:
    #####: 5487:UnitTest::~UnitTest() {
        -: 5488:  delete impl_;
    #####: 5489:}
    %%%%%: 5489-block  0
------------------
_ZN7testing8UnitTestD2Ev:
        1: 5487:UnitTest::~UnitTest() {
        1: 5487-block  0
        1: 5488:  delete impl_;
        1: 5488-block  0
        1: 5488-block  1
        1: 5489:}
------------------
        -: 5490:
        -: 5491:// Pushes a trace defined by SCOPED_TRACE() on to the per-thread
        -: 5492:// Google Test trace stack.
    #####: 5493:void UnitTest::PushGTestTrace(const internal::TraceInfo& trace)
        -: 5494:    GTEST_LOCK_EXCLUDED_(mutex_) {
    #####: 5495:  internal::MutexLock lock(&mutex_);
    %%%%%: 5495-block  0
    %%%%%: 5495-block  1
    $$$$$: 5495-block  2
    #####: 5496:  impl_->gtest_trace_stack().push_back(trace);
    %%%%%: 5496-block  0
    %%%%%: 5496-block  1
    #####: 5497:}
        -: 5498:
        -: 5499:// Pops a trace from the per-thread Google Test trace stack.
    #####: 5500:void UnitTest::PopGTestTrace()
        -: 5501:    GTEST_LOCK_EXCLUDED_(mutex_) {
    #####: 5502:  internal::MutexLock lock(&mutex_);
    %%%%%: 5502-block  0
    $$$$$: 5502-block  1
    #####: 5503:  impl_->gtest_trace_stack().pop_back();
    %%%%%: 5503-block  0
    %%%%%: 5503-block  1
    #####: 5504:}
        -: 5505:
        -: 5506:namespace internal {
        -: 5507:
        1: 5508:UnitTestImpl::UnitTestImpl(UnitTest* parent)
        -: 5509:    : parent_(parent),
        -: 5510:      GTEST_DISABLE_MSC_WARNINGS_PUSH_(4355 /* using this in initializer */)
        -: 5511:          default_global_test_part_result_reporter_(this),
        -: 5512:      default_per_thread_test_part_result_reporter_(this),
        -: 5513:      GTEST_DISABLE_MSC_WARNINGS_POP_() global_test_part_result_repoter_(
        -: 5514:          &default_global_test_part_result_reporter_),
        -: 5515:      per_thread_test_part_result_reporter_(
        -: 5516:          &default_per_thread_test_part_result_reporter_),
        -: 5517:      parameterized_test_registry_(),
        -: 5518:      parameterized_tests_registered_(false),
        -: 5519:      last_death_test_suite_(-1),
        -: 5520:      current_test_suite_(nullptr),
        -: 5521:      current_test_info_(nullptr),
        -: 5522:      ad_hoc_test_result_(),
        -: 5523:      os_stack_trace_getter_(nullptr),
        -: 5524:      post_flag_parse_init_performed_(false),
        -: 5525:      random_seed_(0),  // Will be overridden by the flag before first use.
        -: 5526:      random_(0),       // Will be reseeded before first use.
        -: 5527:      start_timestamp_(0),
        -: 5528:      elapsed_time_(0),
        -: 5529:#if GTEST_HAS_DEATH_TEST
        1: 5530:      death_test_factory_(new DefaultDeathTestFactory),
        1: 5530-block  0
        -: 5531:#endif
        -: 5532:      // Will be overridden by the flag before first use.
        2: 5533:      catch_exceptions_(false) {
        1: 5533-block  0
        1: 5533-block  1
        1: 5533-block  2
        1: 5533-block  3
        1: 5533-block  4
    $$$$$: 5533-block  5
    $$$$$: 5533-block  6
    $$$$$: 5533-block  7
    $$$$$: 5533-block  8
    $$$$$: 5533-block  9
    $$$$$: 5533-block 10
    $$$$$: 5533-block 11
    $$$$$: 5533-block 12
    $$$$$: 5533-block 13
    $$$$$: 5533-block 14
    $$$$$: 5533-block 15
    $$$$$: 5533-block 16
    $$$$$: 5533-block 17
    $$$$$: 5533-block 18
    $$$$$: 5533-block 19
    $$$$$: 5533-block 20
    $$$$$: 5533-block 21
        1: 5534:  listeners()->SetDefaultResultPrinter(new PrettyUnitTestResultPrinter);
        1: 5534-block  0
        1: 5534-block  1
        1: 5535:}
        1: 5535-block  0
        -: 5536:
        2: 5537:UnitTestImpl::~UnitTestImpl() {
        -: 5538:  // Deletes every TestSuite.
        1: 5539:  ForEach(test_suites_, internal::Delete<TestSuite>);
        -: 5540:
        -: 5541:  // Deletes every Environment.
        1: 5542:  ForEach(environments_, internal::Delete<Environment>);
        -: 5543:
        1: 5544:  delete os_stack_trace_getter_;
        2: 5545:}
------------------
_ZN7testing8internal12UnitTestImplD0Ev:
        1: 5537:UnitTestImpl::~UnitTestImpl() {
        -: 5538:  // Deletes every TestSuite.
        -: 5539:  ForEach(test_suites_, internal::Delete<TestSuite>);
        -: 5540:
        -: 5541:  // Deletes every Environment.
        -: 5542:  ForEach(environments_, internal::Delete<Environment>);
        -: 5543:
        -: 5544:  delete os_stack_trace_getter_;
        1: 5545:}
        1: 5545-block  0
------------------
_ZN7testing8internal12UnitTestImplD2Ev:
        1: 5537:UnitTestImpl::~UnitTestImpl() {
        1: 5537-block  0
        -: 5538:  // Deletes every TestSuite.
        1: 5539:  ForEach(test_suites_, internal::Delete<TestSuite>);
        1: 5539-block  0
        -: 5540:
        -: 5541:  // Deletes every Environment.
        1: 5542:  ForEach(environments_, internal::Delete<Environment>);
        -: 5543:
        1: 5544:  delete os_stack_trace_getter_;
        1: 5544-block  0
        1: 5545:}
------------------
        -: 5546:
        -: 5547:// Adds a TestProperty to the current TestResult object when invoked in a
        -: 5548:// context of a test, to current test suite's ad_hoc_test_result when invoke
        -: 5549:// from SetUpTestSuite/TearDownTestSuite, or to the global property set
        -: 5550:// otherwise.  If the result already contains a property with the same key,
        -: 5551:// the value will be updated.
    #####: 5552:void UnitTestImpl::RecordProperty(const TestProperty& test_property) {
    #####: 5553:  std::string xml_element;
    %%%%%: 5553-block  0
    %%%%%: 5553-block  1
    $$$$$: 5553-block  2
        -: 5554:  TestResult* test_result;  // TestResult appropriate for property recording.
        -: 5555:
    #####: 5556:  if (current_test_info_ != nullptr) {
    #####: 5557:    xml_element = "testcase";
    %%%%%: 5557-block  0
    #####: 5558:    test_result = &(current_test_info_->result_);
    %%%%%: 5558-block  0
    #####: 5559:  } else if (current_test_suite_ != nullptr) {
    %%%%%: 5559-block  0
    #####: 5560:    xml_element = "testsuite";
    %%%%%: 5560-block  0
    #####: 5561:    test_result = &(current_test_suite_->ad_hoc_test_result_);
    %%%%%: 5561-block  0
        -: 5562:  } else {
    #####: 5563:    xml_element = "testsuites";
    %%%%%: 5563-block  0
    #####: 5564:    test_result = &ad_hoc_test_result_;
    %%%%%: 5564-block  0
        -: 5565:  }
    #####: 5566:  test_result->RecordProperty(xml_element, test_property);
    %%%%%: 5566-block  0
    #####: 5567:}
        -: 5568:
        -: 5569:#if GTEST_HAS_DEATH_TEST
        -: 5570:// Disables event forwarding if the control is currently in a death test
        -: 5571:// subprocess. Must not be called before InitGoogleTest.
        1: 5572:void UnitTestImpl::SuppressTestEventsIfInSubprocess() {
        1: 5573:  if (internal_run_death_test_flag_.get() != nullptr)
        1: 5573-block  0
    #####: 5574:    listeners()->SuppressEventForwarding();
    %%%%%: 5574-block  0
        1: 5575:}
        -: 5576:#endif  // GTEST_HAS_DEATH_TEST
        -: 5577:
        -: 5578:// Initializes event listeners performing XML output as specified by
        -: 5579:// UnitTestOptions. Must not be called before InitGoogleTest.
        1: 5580:void UnitTestImpl::ConfigureXmlOutput() {
        2: 5581:  const std::string& output_format = UnitTestOptions::GetOutputFormat();
        1: 5581-block  0
        1: 5581-block  1
    $$$$$: 5581-block  2
        1: 5582:  if (output_format == "xml") {
        1: 5582-block  0
    #####: 5583:    listeners()->SetDefaultXmlGenerator(new XmlUnitTestResultPrinter(
    %%%%%: 5583-block  0
    %%%%%: 5583-block  1
    #####: 5584:        UnitTestOptions::GetAbsolutePathToOutputFile().c_str()));
    %%%%%: 5584-block  0
    %%%%%: 5584-block  1
    %%%%%: 5584-block  2
    $$$$$: 5584-block  3
    $$$$$: 5584-block  4
    $$$$$: 5584-block  5
        1: 5585:  } else if (output_format == "json") {
        1: 5585-block  0
    #####: 5586:    listeners()->SetDefaultXmlGenerator(new JsonUnitTestResultPrinter(
    %%%%%: 5586-block  0
    %%%%%: 5586-block  1
    #####: 5587:        UnitTestOptions::GetAbsolutePathToOutputFile().c_str()));
    %%%%%: 5587-block  0
    %%%%%: 5587-block  1
    %%%%%: 5587-block  2
    $$$$$: 5587-block  3
    $$$$$: 5587-block  4
    $$$$$: 5587-block  5
        1: 5588:  } else if (output_format != "") {
        1: 5588-block  0
        1: 5588-block  1
    #####: 5589:    GTEST_LOG_(WARNING) << "WARNING: unrecognized output format \""
    %%%%%: 5589-block  0
    %%%%%: 5589-block  1
    %%%%%: 5589-block  2
    $$$$$: 5589-block  3
    $$$$$: 5589-block  4
    #####: 5590:                        << output_format << "\" ignored.";
    %%%%%: 5590-block  0
    %%%%%: 5590-block  1
        -: 5591:  }
        1: 5592:}
        -: 5593:
        -: 5594:#if GTEST_CAN_STREAM_RESULTS_
        -: 5595:// Initializes event listeners for streaming test results in string form.
        -: 5596:// Must not be called before InitGoogleTest.
        1: 5597:void UnitTestImpl::ConfigureStreamingOutput() {
        1: 5598:  const std::string& target = GTEST_FLAG(stream_result_to);
        1: 5599:  if (!target.empty()) {
        1: 5599-block  0
    #####: 5600:    const size_t pos = target.find(':');
    %%%%%: 5600-block  0
    #####: 5601:    if (pos != std::string::npos) {
    #####: 5602:      listeners()->Append(new StreamingListener(target.substr(0, pos),
    %%%%%: 5602-block  0
    %%%%%: 5602-block  1
    $$$$$: 5602-block  2
    $$$$$: 5602-block  3
    #####: 5603:                                                target.substr(pos+1)));
    %%%%%: 5603-block  0
    %%%%%: 5603-block  1
    %%%%%: 5603-block  2
    $$$$$: 5603-block  3
    $$$$$: 5603-block  4
    $$$$$: 5603-block  5
        -: 5604:    } else {
    #####: 5605:      GTEST_LOG_(WARNING) << "unrecognized streaming target \"" << target
    %%%%%: 5605-block  0
    %%%%%: 5605-block  1
    $$$$$: 5605-block  2
    #####: 5606:                          << "\" ignored.";
    %%%%%: 5606-block  0
    %%%%%: 5606-block  1
        -: 5607:    }
        -: 5608:  }
        1: 5609:}
        1: 5609-block  0
        -: 5610:#endif  // GTEST_CAN_STREAM_RESULTS_
        -: 5611:
        -: 5612:// Performs initialization dependent upon flag values obtained in
        -: 5613:// ParseGoogleTestFlagsOnly.  Is called from InitGoogleTest after the call to
        -: 5614:// ParseGoogleTestFlagsOnly.  In case a user neglects to call InitGoogleTest
        -: 5615:// this function is also called from RunAllTests.  Since this function can be
        -: 5616:// called more than once, it has to be idempotent.
        2: 5617:void UnitTestImpl::PostFlagParsingInit() {
        -: 5618:  // Ensures that this function does not execute more than once.
        2: 5619:  if (!post_flag_parse_init_performed_) {
        2: 5619-block  0
        1: 5620:    post_flag_parse_init_performed_ = true;
        -: 5621:
        -: 5622:#if defined(GTEST_CUSTOM_TEST_EVENT_LISTENER_)
        -: 5623:    // Register to send notifications about key process state changes.
        -: 5624:    listeners()->Append(new GTEST_CUSTOM_TEST_EVENT_LISTENER_());
        -: 5625:#endif  // defined(GTEST_CUSTOM_TEST_EVENT_LISTENER_)
        -: 5626:
        -: 5627:#if GTEST_HAS_DEATH_TEST
        1: 5628:    InitDeathTestSubprocessControlInfo();
        1: 5628-block  0
        1: 5629:    SuppressTestEventsIfInSubprocess();
        -: 5630:#endif  // GTEST_HAS_DEATH_TEST
        -: 5631:
        -: 5632:    // Registers parameterized tests. This makes parameterized tests
        -: 5633:    // available to the UnitTest reflection API without running
        -: 5634:    // RUN_ALL_TESTS.
        1: 5635:    RegisterParameterizedTests();
        -: 5636:
        -: 5637:    // Configures listeners for XML output. This makes it possible for users
        -: 5638:    // to shut down the default XML output before invoking RUN_ALL_TESTS.
        1: 5639:    ConfigureXmlOutput();
        -: 5640:
        1: 5641:    if (GTEST_FLAG(brief)) {
    #####: 5642:      listeners()->SetDefaultResultPrinter(new BriefUnitTestResultPrinter);
    %%%%%: 5642-block  0
        -: 5643:    }
        -: 5644:
        -: 5645:#if GTEST_CAN_STREAM_RESULTS_
        -: 5646:    // Configures listeners for streaming test results to the specified server.
        1: 5647:    ConfigureStreamingOutput();
        1: 5647-block  0
        -: 5648:#endif  // GTEST_CAN_STREAM_RESULTS_
        -: 5649:
        -: 5650:#if GTEST_HAS_ABSL
        -: 5651:    if (GTEST_FLAG(install_failure_signal_handler)) {
        -: 5652:      absl::FailureSignalHandlerOptions options;
        -: 5653:      absl::InstallFailureSignalHandler(options);
        -: 5654:    }
        -: 5655:#endif  // GTEST_HAS_ABSL
        -: 5656:  }
        2: 5657:}
        -: 5658:
        -: 5659:// A predicate that checks the name of a TestSuite against a known
        -: 5660:// value.
        -: 5661://
        -: 5662:// This is used for implementation of the UnitTest class only.  We put
        -: 5663:// it in the anonymous namespace to prevent polluting the outer
        -: 5664:// namespace.
        -: 5665://
        -: 5666:// TestSuiteNameIs is copyable.
        -: 5667:class TestSuiteNameIs {
        -: 5668: public:
        -: 5669:  // Constructor.
       41: 5670:  explicit TestSuiteNameIs(const std::string& name) : name_(name) {}
       41: 5670-block  0
        -: 5671:
        -: 5672:  // Returns true if and only if the name of test_suite matches name_.
       40: 5673:  bool operator()(const TestSuite* test_suite) const {
       80: 5674:    return test_suite != nullptr &&
       40: 5674-block  0
       39: 5674-block  1
        1: 5674-block  2
       80: 5675:           strcmp(test_suite->name(), name_.c_str()) == 0;
       40: 5675-block  0
       40: 5675-block  1
        -: 5676:  }
        -: 5677:
        -: 5678: private:
        -: 5679:  std::string name_;
        -: 5680:};
        -: 5681:
        -: 5682:// Finds and returns a TestSuite with the given name.  If one doesn't
        -: 5683:// exist, creates one and returns it.  It's the CALLER'S
        -: 5684:// RESPONSIBILITY to ensure that this function is only called WHEN THE
        -: 5685:// TESTS ARE NOT SHUFFLED.
        -: 5686://
        -: 5687:// Arguments:
        -: 5688://
        -: 5689://   test_suite_name: name of the test suite
        -: 5690://   type_param:      the name of the test suite's type parameter, or NULL if
        -: 5691://                    this is not a typed or a type-parameterized test suite.
        -: 5692://   set_up_tc:       pointer to the function that sets up the test suite
        -: 5693://   tear_down_tc:    pointer to the function that tears down the test suite
       41: 5694:TestSuite* UnitTestImpl::GetTestSuite(
        -: 5695:    const char* test_suite_name, const char* type_param,
        -: 5696:    internal::SetUpTestSuiteFunc set_up_tc,
        -: 5697:    internal::TearDownTestSuiteFunc tear_down_tc) {
        -: 5698:  // Can we find a TestSuite with the given name?
        -: 5699:  const auto test_suite =
       41: 5700:      std::find_if(test_suites_.rbegin(), test_suites_.rend(),
       41: 5700-block  0
    $$$$$: 5700-block  1
    $$$$$: 5700-block  2
       82: 5701:                   TestSuiteNameIs(test_suite_name));
       41: 5701-block  0
       41: 5701-block  1
       41: 5701-block  2
    $$$$$: 5701-block  3
    $$$$$: 5701-block  4
    $$$$$: 5701-block  5
    $$$$$: 5701-block  6
    $$$$$: 5701-block  7
    $$$$$: 5701-block  8
        -: 5702:
       41: 5703:  if (test_suite != test_suites_.rend()) return *test_suite;
       41: 5703-block  0
       39: 5703-block  1
    $$$$$: 5703-block  2
        -: 5704:
        -: 5705:  // No.  Let's create one.
        -: 5706:  auto* const new_test_suite =
        2: 5707:      new TestSuite(test_suite_name, type_param, set_up_tc, tear_down_tc);
        2: 5707-block  0
        2: 5707-block  1
    $$$$$: 5707-block  2
        -: 5708:
        -: 5709:  // Is this a death test suite?
        2: 5710:  if (internal::UnitTestOptions::MatchesFilter(test_suite_name,
        2: 5710-block  0
        2: 5710-block  1
    $$$$$: 5710-block  2
    $$$$$: 5710-block  3
        -: 5711:                                               kDeathTestSuiteFilter)) {
        -: 5712:    // Yes.  Inserts the test suite after the last death test suite
        -: 5713:    // defined so far.  This only works when the test suites haven't
        -: 5714:    // been shuffled.  Otherwise we may end up running a death test
        -: 5715:    // after a non-death test.
    #####: 5716:    ++last_death_test_suite_;
    #####: 5717:    test_suites_.insert(test_suites_.begin() + last_death_test_suite_,
    $$$$$: 5717-block  0
    $$$$$: 5717-block  1
    #####: 5718:                        new_test_suite);
    %%%%%: 5718-block  0
    %%%%%: 5718-block  1
    $$$$$: 5718-block  2
        -: 5719:  } else {
        -: 5720:    // No.  Appends to the end of the list.
        2: 5721:    test_suites_.push_back(new_test_suite);
        2: 5721-block  0
        -: 5722:  }
        -: 5723:
        2: 5724:  test_suite_indices_.push_back(static_cast<int>(test_suite_indices_.size()));
        2: 5724-block  0
    $$$$$: 5724-block  1
        2: 5725:  return new_test_suite;
        2: 5725-block  0
        -: 5726:}
        -: 5727:
        -: 5728:// Helpers for setting up / tearing down the given environment.  They
        -: 5729:// are for use in the ForEach() function.
    #####: 5730:static void SetUpEnvironment(Environment* env) { env->SetUp(); }
    %%%%%: 5730-block  0
    #####: 5731:static void TearDownEnvironment(Environment* env) { env->TearDown(); }
    %%%%%: 5731-block  0
        -: 5732:
        -: 5733:// Runs all tests in this UnitTest object, prints the result, and
        -: 5734:// returns true if all tests are successful.  If any exception is
        -: 5735:// thrown during a test, the test is considered to be failed, but the
        -: 5736:// rest of the tests will still be run.
        -: 5737://
        -: 5738:// When parameterized tests are enabled, it expands and registers
        -: 5739:// parameterized tests first in RegisterParameterizedTests().
        -: 5740:// All other functions called from RunAllTests() may safely assume that
        -: 5741:// parameterized tests are ready to be counted and run.
        1: 5742:bool UnitTestImpl::RunAllTests() {
        -: 5743:  // True if and only if Google Test is initialized before RUN_ALL_TESTS() is
        -: 5744:  // called.
        1: 5745:  const bool gtest_is_initialized_before_run_all_tests = GTestIsInitialized();
        1: 5745-block  0
        -: 5746:
        -: 5747:  // Do not run any test if the --help flag was specified.
        1: 5748:  if (g_help_flag)
    #####: 5749:    return true;
    %%%%%: 5749-block  0
        -: 5750:
        -: 5751:  // Repeats the call to the post-flag parsing initialization in case the
        -: 5752:  // user didn't call InitGoogleTest.
        1: 5753:  PostFlagParsingInit();
        1: 5753-block  0
        -: 5754:
        -: 5755:  // Even if sharding is not on, test runners may want to use the
        -: 5756:  // GTEST_SHARD_STATUS_FILE to query whether the test supports the sharding
        -: 5757:  // protocol.
        1: 5758:  internal::WriteToShardStatusFileIfNeeded();
        -: 5759:
        -: 5760:  // True if and only if we are in a subprocess for running a thread-safe-style
        -: 5761:  // death test.
        1: 5762:  bool in_subprocess_for_death_test = false;
        -: 5763:
        -: 5764:#if GTEST_HAS_DEATH_TEST
        1: 5765:  in_subprocess_for_death_test =
        1: 5766:      (internal_run_death_test_flag_.get() != nullptr);
        -: 5767:# if defined(GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_)
        -: 5768:  if (in_subprocess_for_death_test) {
        -: 5769:    GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_();
        -: 5770:  }
        -: 5771:# endif  // defined(GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_)
        -: 5772:#endif  // GTEST_HAS_DEATH_TEST
        -: 5773:
        1: 5774:  const bool should_shard = ShouldShard(kTestTotalShards, kTestShardIndex,
        -: 5775:                                        in_subprocess_for_death_test);
        -: 5776:
        -: 5777:  // Compares the full test names with the filter to decide which
        -: 5778:  // tests to run.
       1*: 5779:  const bool has_tests_to_run = FilterTests(should_shard
    %%%%%: 5779-block  0
        1: 5779-block  1
        1: 5779-block  2
        -: 5780:                                              ? HONOR_SHARDING_PROTOCOL
        1: 5781:                                              : IGNORE_SHARDING_PROTOCOL) > 0;
        -: 5782:
        -: 5783:  // Lists the tests and exits if the --gtest_list_tests flag was specified.
        1: 5784:  if (GTEST_FLAG(list_tests)) {
        -: 5785:    // This must be called *after* FilterTests() has been called.
    #####: 5786:    ListTestsMatchingFilter();
    %%%%%: 5786-block  0
    #####: 5787:    return true;
        -: 5788:  }
        -: 5789:
        1: 5790:  random_seed_ = GTEST_FLAG(shuffle) ?
        1: 5790-block  0
        1: 5790-block  1
    #####: 5791:      GetRandomSeedFromFlag(GTEST_FLAG(random_seed)) : 0;
    %%%%%: 5791-block  0
        -: 5792:
        -: 5793:  // True if and only if at least one test has failed.
        1: 5794:  bool failed = false;
        -: 5795:
        1: 5796:  TestEventListener* repeater = listeners()->repeater();
        1: 5796-block  0
        -: 5797:
        1: 5798:  start_timestamp_ = GetTimeInMillis();
        1: 5799:  repeater->OnTestProgramStart(*parent_);
        -: 5800:
        -: 5801:  // How many times to repeat the tests?  We don't want to repeat them
        -: 5802:  // when we are inside the subprocess of a death test.
       1*: 5803:  const int repeat = in_subprocess_for_death_test ? 1 : GTEST_FLAG(repeat);
    %%%%%: 5803-block  0
        1: 5803-block  1
        -: 5804:  // Repeats forever if the repeat count is negative.
        1: 5805:  const bool gtest_repeat_forever = repeat < 0;
        2: 5806:  for (int i = 0; gtest_repeat_forever || i != repeat; i++) {
        1: 5806-block  0
        2: 5806-block  1
        2: 5806-block  2
        1: 5806-block  3
        -: 5807:    // We want to preserve failures generated by ad-hoc test
        -: 5808:    // assertions executed before RUN_ALL_TESTS().
        1: 5809:    ClearNonAdHocTestResult();
        1: 5809-block  0
        -: 5810:
        1: 5811:    Timer timer;
        1: 5811-block  0
        -: 5812:
        -: 5813:    // Shuffles test suites and tests if requested.
        1: 5814:    if (has_tests_to_run && GTEST_FLAG(shuffle)) {
        1: 5814-block  0
    #####: 5815:      random()->Reseed(static_cast<uint32_t>(random_seed_));
    %%%%%: 5815-block  0
        -: 5816:      // This should be done before calling OnTestIterationStart(),
        -: 5817:      // such that a test event listener can see the actual test order
        -: 5818:      // in the event.
    #####: 5819:      ShuffleTests();
        -: 5820:    }
        -: 5821:
        -: 5822:    // Tells the unit test event listeners that the tests are about to start.
        1: 5823:    repeater->OnTestIterationStart(*parent_, i);
        1: 5823-block  0
        -: 5824:
        -: 5825:    // Runs each test suite if there is at least one test to run.
        1: 5826:    if (has_tests_to_run) {
        1: 5826-block  0
        -: 5827:      // Sets up all environments beforehand.
        1: 5828:      repeater->OnEnvironmentsSetUpStart(*parent_);
        1: 5828-block  0
        1: 5829:      ForEach(environments_, SetUpEnvironment);
        1: 5829-block  0
        1: 5830:      repeater->OnEnvironmentsSetUpEnd(*parent_);
        1: 5830-block  0
        -: 5831:
        -: 5832:      // Runs the tests only if there was no fatal failure or skip triggered
        -: 5833:      // during global set-up.
        1: 5834:      if (Test::IsSkipped()) {
        1: 5834-block  0
        1: 5834-block  1
        -: 5835:        // Emit diagnostics when global set-up calls skip, as it will not be
        -: 5836:        // emitted by default.
        -: 5837:        TestResult& test_result =
    #####: 5838:            *internal::GetUnitTestImpl()->current_test_result();
    %%%%%: 5838-block  0
    %%%%%: 5838-block  1
    #####: 5839:        for (int j = 0; j < test_result.total_part_count(); ++j) {
    %%%%%: 5839-block  0
    %%%%%: 5839-block  1
        -: 5840:          const TestPartResult& test_part_result =
    #####: 5841:              test_result.GetTestPartResult(j);
    %%%%%: 5841-block  0
    #####: 5842:          if (test_part_result.type() == TestPartResult::kSkip) {
    %%%%%: 5842-block  0
    #####: 5843:            const std::string& result = test_part_result.message();
    %%%%%: 5843-block  0
    %%%%%: 5843-block  1
    %%%%%: 5843-block  2
    $$$$$: 5843-block  3
    $$$$$: 5843-block  4
    $$$$$: 5843-block  5
    #####: 5844:            printf("%s\n", result.c_str());
        -: 5845:          }
        -: 5846:        }
    #####: 5847:        fflush(stdout);
    %%%%%: 5847-block  0
        1: 5848:      } else if (!Test::HasFatalFailure()) {
        1: 5848-block  0
        1: 5848-block  1
        3: 5849:        for (int test_index = 0; test_index < total_test_suite_count();
        1: 5849-block  0
        3: 5849-block  1
        2: 5849-block  2
        -: 5850:             test_index++) {
        2: 5851:          GetMutableSuiteCase(test_index)->Run();
        2: 5851-block  0
        2: 5851-block  1
       2*: 5852:          if (GTEST_FLAG(fail_fast) &&
        2: 5852-block  0
    %%%%%: 5852-block  1
        2: 5852-block  2
        2: 5852-block  3
    #####: 5853:              GetMutableSuiteCase(test_index)->Failed()) {
    %%%%%: 5853-block  0
    %%%%%: 5853-block  1
    %%%%%: 5853-block  2
    #####: 5854:            for (int j = test_index + 1; j < total_test_suite_count(); j++) {
    %%%%%: 5854-block  0
    %%%%%: 5854-block  1
    %%%%%: 5854-block  2
    #####: 5855:              GetMutableSuiteCase(j)->Skip();
    %%%%%: 5855-block  0
    %%%%%: 5855-block  1
        -: 5856:            }
    #####: 5857:            break;
    %%%%%: 5857-block  0
        -: 5858:          }
        -: 5859:        }
    #####: 5860:      } else if (Test::HasFatalFailure()) {
    %%%%%: 5860-block  0
    %%%%%: 5860-block  1
        -: 5861:        // If there was a fatal failure during the global setup then we know we
        -: 5862:        // aren't going to run any tests. Explicitly mark all of the tests as
        -: 5863:        // skipped to make this obvious in the output.
    #####: 5864:        for (int test_index = 0; test_index < total_test_suite_count();
    %%%%%: 5864-block  0
    %%%%%: 5864-block  1
    %%%%%: 5864-block  2
        -: 5865:             test_index++) {
    #####: 5866:          GetMutableSuiteCase(test_index)->Skip();
    %%%%%: 5866-block  0
    %%%%%: 5866-block  1
        -: 5867:        }
        -: 5868:      }
        -: 5869:
        -: 5870:      // Tears down all environments in reverse order afterwards.
        1: 5871:      repeater->OnEnvironmentsTearDownStart(*parent_);
        1: 5871-block  0
        1: 5872:      std::for_each(environments_.rbegin(), environments_.rend(),
        1: 5872-block  0
    $$$$$: 5872-block  1
    $$$$$: 5872-block  2
        -: 5873:                    TearDownEnvironment);
        1: 5874:      repeater->OnEnvironmentsTearDownEnd(*parent_);
        1: 5874-block  0
        -: 5875:    }
        -: 5876:
        1: 5877:    elapsed_time_ = timer.Elapsed();
        1: 5877-block  0
        -: 5878:
        -: 5879:    // Tells the unit test event listener that the tests have just finished.
        1: 5880:    repeater->OnTestIterationEnd(*parent_, i);
        1: 5880-block  0
        -: 5881:
        -: 5882:    // Gets the result and clears it.
        1: 5883:    if (!Passed()) {
        1: 5883-block  0
        1: 5883-block  1
    #####: 5884:      failed = true;
    %%%%%: 5884-block  0
        -: 5885:    }
        -: 5886:
        -: 5887:    // Restores the original test order after the iteration.  This
        -: 5888:    // allows the user to quickly repro a failure that happens in the
        -: 5889:    // N-th iteration without repeating the first (N - 1) iterations.
        -: 5890:    // This is not enclosed in "if (GTEST_FLAG(shuffle)) { ... }", in
        -: 5891:    // case the user somehow changes the value of the flag somewhere
        -: 5892:    // (it's always safe to unshuffle the tests).
        1: 5893:    UnshuffleTests();
        1: 5893-block  0
        -: 5894:
        1: 5895:    if (GTEST_FLAG(shuffle)) {
        -: 5896:      // Picks a new random seed for each iteration.
    #####: 5897:      random_seed_ = GetNextRandomSeed(random_seed_);
    %%%%%: 5897-block  0
    %%%%%: 5897-block  1
        -: 5898:    }
        -: 5899:  }
        -: 5900:
        1: 5901:  repeater->OnTestProgramEnd(*parent_);
        1: 5901-block  0
        -: 5902:
        1: 5903:  if (!gtest_is_initialized_before_run_all_tests) {
    #####: 5904:    ColoredPrintf(
    %%%%%: 5904-block  0
        -: 5905:        GTestColor::kRed,
        -: 5906:        "\nIMPORTANT NOTICE - DO NOT IGNORE:\n"
        -: 5907:        "This test program did NOT call " GTEST_INIT_GOOGLE_TEST_NAME_
        -: 5908:        "() before calling RUN_ALL_TESTS(). This is INVALID. Soon " GTEST_NAME_
        -: 5909:        " will start to enforce the valid usage. "
        -: 5910:        "Please fix it ASAP, or IT WILL START TO FAIL.\n");  // NOLINT
        -: 5911:#if GTEST_FOR_GOOGLE_
        -: 5912:    ColoredPrintf(GTestColor::kRed,
        -: 5913:                  "For more details, see http://wiki/Main/ValidGUnitMain.\n");
        -: 5914:#endif  // GTEST_FOR_GOOGLE_
        -: 5915:  }
        -: 5916:
        1: 5917:  return !failed;
        1: 5917-block  0
        -: 5918:}
        -: 5919:
        -: 5920:// Reads the GTEST_SHARD_STATUS_FILE environment variable, and creates the file
        -: 5921:// if the variable is present. If a file already exists at this location, this
        -: 5922:// function will write over it. If the variable is present, but the file cannot
        -: 5923:// be created, prints an error and exits.
        1: 5924:void WriteToShardStatusFileIfNeeded() {
        1: 5925:  const char* const test_shard_file = posix::GetEnv(kTestShardStatusFile);
        1: 5925-block  0
        1: 5926:  if (test_shard_file != nullptr) {
    #####: 5927:    FILE* const file = posix::FOpen(test_shard_file, "w");
    %%%%%: 5927-block  0
    #####: 5928:    if (file == nullptr) {
    #####: 5929:      ColoredPrintf(GTestColor::kRed,
    %%%%%: 5929-block  0
        -: 5930:                    "Could not write to the test shard status file \"%s\" "
        -: 5931:                    "specified by the %s environment variable.\n",
        -: 5932:                    test_shard_file, kTestShardStatusFile);
    #####: 5933:      fflush(stdout);
    #####: 5934:      exit(EXIT_FAILURE);
        -: 5935:    }
    #####: 5936:    fclose(file);
    %%%%%: 5936-block  0
        -: 5937:  }
        1: 5938:}
        -: 5939:
        -: 5940:// Checks whether sharding is enabled by examining the relevant
        -: 5941:// environment variable values. If the variables are present,
        -: 5942:// but inconsistent (i.e., shard_index >= total_shards), prints
        -: 5943:// an error and exits. If in_subprocess_for_death_test, sharding is
        -: 5944:// disabled because it must only be applied to the original test
        -: 5945:// process. Otherwise, we could filter out death tests we intended to execute.
        2: 5946:bool ShouldShard(const char* total_shards_env,
        -: 5947:                 const char* shard_index_env,
        -: 5948:                 bool in_subprocess_for_death_test) {
        2: 5949:  if (in_subprocess_for_death_test) {
        2: 5949-block  0
    #####: 5950:    return false;
    %%%%%: 5950-block  0
        -: 5951:  }
        -: 5952:
        2: 5953:  const int32_t total_shards = Int32FromEnvOrDie(total_shards_env, -1);
        2: 5953-block  0
        2: 5954:  const int32_t shard_index = Int32FromEnvOrDie(shard_index_env, -1);
        2: 5954-block  0
        -: 5955:
        2: 5956:  if (total_shards == -1 && shard_index == -1) {
        2: 5956-block  0
        2: 5956-block  1
        2: 5957:    return false;
        2: 5957-block  0
    #####: 5958:  } else if (total_shards == -1 && shard_index != -1) {
    %%%%%: 5958-block  0
    %%%%%: 5958-block  1
    #####: 5959:    const Message msg = Message()
    %%%%%: 5959-block  0
    $$$$$: 5959-block  1
    #####: 5960:      << "Invalid environment variables: you have "
    %%%%%: 5960-block  0
    #####: 5961:      << kTestShardIndex << " = " << shard_index
    %%%%%: 5961-block  0
    %%%%%: 5961-block  1
    %%%%%: 5961-block  2
    #####: 5962:      << ", but have left " << kTestTotalShards << " unset.\n";
    %%%%%: 5962-block  0
    %%%%%: 5962-block  1
    %%%%%: 5962-block  2
    %%%%%: 5962-block  3
    $$$$$: 5962-block  4
    #####: 5963:    ColoredPrintf(GTestColor::kRed, "%s", msg.GetString().c_str());
    %%%%%: 5963-block  0
    %%%%%: 5963-block  1
    $$$$$: 5963-block  2
    $$$$$: 5963-block  3
    #####: 5964:    fflush(stdout);
    #####: 5965:    exit(EXIT_FAILURE);
    %%%%%: 5965-block  0
    #####: 5966:  } else if (total_shards != -1 && shard_index == -1) {
    %%%%%: 5966-block  0
    %%%%%: 5966-block  1
    #####: 5967:    const Message msg = Message()
    %%%%%: 5967-block  0
    $$$$$: 5967-block  1
    #####: 5968:      << "Invalid environment variables: you have "
    %%%%%: 5968-block  0
    #####: 5969:      << kTestTotalShards << " = " << total_shards
    %%%%%: 5969-block  0
    %%%%%: 5969-block  1
    %%%%%: 5969-block  2
    #####: 5970:      << ", but have left " << kTestShardIndex << " unset.\n";
    %%%%%: 5970-block  0
    %%%%%: 5970-block  1
    %%%%%: 5970-block  2
    %%%%%: 5970-block  3
    $$$$$: 5970-block  4
    #####: 5971:    ColoredPrintf(GTestColor::kRed, "%s", msg.GetString().c_str());
    %%%%%: 5971-block  0
    %%%%%: 5971-block  1
    $$$$$: 5971-block  2
    $$$$$: 5971-block  3
    #####: 5972:    fflush(stdout);
    #####: 5973:    exit(EXIT_FAILURE);
    %%%%%: 5973-block  0
    #####: 5974:  } else if (shard_index < 0 || shard_index >= total_shards) {
    %%%%%: 5974-block  0
    %%%%%: 5974-block  1
    #####: 5975:    const Message msg = Message()
    %%%%%: 5975-block  0
    $$$$$: 5975-block  1
    #####: 5976:      << "Invalid environment variables: we require 0 <= "
    %%%%%: 5976-block  0
    #####: 5977:      << kTestShardIndex << " < " << kTestTotalShards
    %%%%%: 5977-block  0
    %%%%%: 5977-block  1
    %%%%%: 5977-block  2
    #####: 5978:      << ", but you have " << kTestShardIndex << "=" << shard_index
    %%%%%: 5978-block  0
    %%%%%: 5978-block  1
    %%%%%: 5978-block  2
    %%%%%: 5978-block  3
    #####: 5979:      << ", " << kTestTotalShards << "=" << total_shards << ".\n";
    %%%%%: 5979-block  0
    %%%%%: 5979-block  1
    %%%%%: 5979-block  2
    %%%%%: 5979-block  3
    %%%%%: 5979-block  4
    %%%%%: 5979-block  5
    $$$$$: 5979-block  6
    #####: 5980:    ColoredPrintf(GTestColor::kRed, "%s", msg.GetString().c_str());
    %%%%%: 5980-block  0
    %%%%%: 5980-block  1
    $$$$$: 5980-block  2
    $$$$$: 5980-block  3
    #####: 5981:    fflush(stdout);
    #####: 5982:    exit(EXIT_FAILURE);
    %%%%%: 5982-block  0
        -: 5983:  }
        -: 5984:
    #####: 5985:  return total_shards > 1;
    %%%%%: 5985-block  0
        -: 5986:}
        -: 5987:
        -: 5988:// Parses the environment variable var as an Int32. If it is unset,
        -: 5989:// returns default_val. If it is not an Int32, prints an error
        -: 5990:// and aborts.
        4: 5991:int32_t Int32FromEnvOrDie(const char* var, int32_t default_val) {
        4: 5992:  const char* str_val = posix::GetEnv(var);
        4: 5992-block  0
        4: 5993:  if (str_val == nullptr) {
        4: 5994:    return default_val;
        4: 5994-block  0
        -: 5995:  }
        -: 5996:
        -: 5997:  int32_t result;
    #####: 5998:  if (!ParseInt32(Message() << "The value of environment variable " << var,
    %%%%%: 5998-block  0
    %%%%%: 5998-block  1
    %%%%%: 5998-block  2
    %%%%%: 5998-block  3
    %%%%%: 5998-block  4
    $$$$$: 5998-block  5
    $$$$$: 5998-block  6
        -: 5999:                  str_val, &result)) {
    #####: 6000:    exit(EXIT_FAILURE);
    %%%%%: 6000-block  0
        -: 6001:  }
    #####: 6002:  return result;
    %%%%%: 6002-block  0
        -: 6003:}
        -: 6004:
        -: 6005:// Given the total number of shards, the shard index, and the test id,
        -: 6006:// returns true if and only if the test should be run on this shard. The test id
        -: 6007:// is some arbitrary but unique non-negative integer assigned to each test
        -: 6008:// method. Assumes that 0 <= shard_index < total_shards.
    #####: 6009:bool ShouldRunTestOnShard(int total_shards, int shard_index, int test_id) {
    #####: 6010:  return (test_id % total_shards) == shard_index;
    %%%%%: 6010-block  0
        -: 6011:}
        -: 6012:
        -: 6013:// Compares the name of each test with the user-specified filter to
        -: 6014:// decide whether the test should be run, then records the result in
        -: 6015:// each TestSuite and TestInfo object.
        -: 6016:// If shard_tests == true, further filters tests based on sharding
        -: 6017:// variables in the environment - see
        -: 6018:// https://github.com/google/googletest/blob/master/googletest/docs/advanced.md
        -: 6019:// . Returns the number of tests that should run.
        1: 6020:int UnitTestImpl::FilterTests(ReactionToSharding shard_tests) {
        1: 6021:  const int32_t total_shards = shard_tests == HONOR_SHARDING_PROTOCOL ?
        1: 6021-block  0
        1: 6021-block  1
    #####: 6022:      Int32FromEnvOrDie(kTestTotalShards, -1) : -1;
    %%%%%: 6022-block  0
        1: 6023:  const int32_t shard_index = shard_tests == HONOR_SHARDING_PROTOCOL ?
        1: 6023-block  0
        1: 6023-block  1
    #####: 6024:      Int32FromEnvOrDie(kTestShardIndex, -1) : -1;
    %%%%%: 6024-block  0
        -: 6025:
        -: 6026:  // num_runnable_tests are the number of tests that will
        -: 6027:  // run across all shards (i.e., match filter and are not disabled).
        -: 6028:  // num_selected_tests are the number of tests to be run on
        -: 6029:  // this shard.
        1: 6030:  int num_runnable_tests = 0;
        1: 6031:  int num_selected_tests = 0;
        3: 6032:  for (auto* test_suite : test_suites_) {
        1: 6032-block  0
        3: 6032-block  1
        2: 6032-block  2
        4: 6033:    const std::string& test_suite_name = test_suite->name();
        2: 6033-block  0
        2: 6033-block  1
    $$$$$: 6033-block  2
    $$$$$: 6033-block  3
    $$$$$: 6033-block  4
        2: 6034:    test_suite->set_should_run(false);
        -: 6035:
       43: 6036:    for (size_t j = 0; j < test_suite->test_info_list().size(); j++) {
       43: 6036-block  0
       41: 6037:      TestInfo* const test_info = test_suite->test_info_list()[j];
       41: 6037-block  0
       82: 6038:      const std::string test_name(test_info->name());
    $$$$$: 6038-block  0
    $$$$$: 6038-block  1
        -: 6039:      // A test is disabled if test suite name or test name matches
        -: 6040:      // kDisableTestFilter.
       41: 6041:      const bool is_disabled = internal::UnitTestOptions::MatchesFilter(
      82*: 6042:                                   test_suite_name, kDisableTestFilter) ||
    %%%%%: 6042-block  0
       41: 6042-block  1
       41: 6043:                               internal::UnitTestOptions::MatchesFilter(
       41: 6043-block  0
       41: 6044:                                   test_name, kDisableTestFilter);
       41: 6045:      test_info->is_disabled_ = is_disabled;
        -: 6046:
       41: 6047:      const bool matches_filter = internal::UnitTestOptions::FilterMatchesTest(
       41: 6047-block  0
        -: 6048:          test_suite_name, test_name);
       41: 6049:      test_info->matches_filter_ = matches_filter;
        -: 6050:
       41: 6051:      const bool is_runnable =
       41: 6052:          (GTEST_FLAG(also_run_disabled_tests) || !is_disabled) &&
       41: 6052-block  0
       41: 6052-block  1
       41: 6052-block  2
       31: 6052-block  3
       10: 6052-block  4
        -: 6053:          matches_filter;
        -: 6054:
        -: 6055:      const bool is_in_another_shard =
      41*: 6056:          shard_tests != IGNORE_SHARDING_PROTOCOL &&
       41: 6056-block  0
    %%%%%: 6056-block  1
       41: 6056-block  2
    #####: 6057:          !ShouldRunTestOnShard(total_shards, shard_index, num_runnable_tests);
    %%%%%: 6057-block  0
       41: 6058:      test_info->is_in_another_shard_ = is_in_another_shard;
       41: 6059:      const bool is_selected = is_runnable && !is_in_another_shard;
       41: 6059-block  0
       31: 6059-block  1
       31: 6059-block  2
       10: 6059-block  3
        -: 6060:
       41: 6061:      num_runnable_tests += is_runnable;
       41: 6062:      num_selected_tests += is_selected;
        -: 6063:
       41: 6064:      test_info->should_run_ = is_selected;
       41: 6065:      test_suite->set_should_run(test_suite->should_run() || is_selected);
       41: 6065-block  0
       11: 6065-block  1
       31: 6065-block  2
       10: 6065-block  3
       41: 6065-block  4
        -: 6066:    }
        -: 6067:  }
        1: 6068:  return num_selected_tests;
        1: 6068-block  0
        1: 6068-block  1
        -: 6069:}
        -: 6070:
        -: 6071:// Prints the given C-string on a single line by replacing all '\n'
        -: 6072:// characters with string "\\n".  If the output takes more than
        -: 6073:// max_length characters, only prints the first max_length characters
        -: 6074:// and "...".
    #####: 6075:static void PrintOnOneLine(const char* str, int max_length) {
    #####: 6076:  if (str != nullptr) {
    %%%%%: 6076-block  0
    #####: 6077:    for (int i = 0; *str != '\0'; ++str) {
    %%%%%: 6077-block  0
    %%%%%: 6077-block  1
    %%%%%: 6077-block  2
    #####: 6078:      if (i >= max_length) {
    %%%%%: 6078-block  0
    #####: 6079:        printf("...");
    %%%%%: 6079-block  0
    #####: 6080:        break;
        -: 6081:      }
    #####: 6082:      if (*str == '\n') {
    %%%%%: 6082-block  0
    #####: 6083:        printf("\\n");
    %%%%%: 6083-block  0
    #####: 6084:        i += 2;
        -: 6085:      } else {
    #####: 6086:        printf("%c", *str);
    %%%%%: 6086-block  0
    #####: 6087:        ++i;
        -: 6088:      }
        -: 6089:    }
        -: 6090:  }
    #####: 6091:}
        -: 6092:
        -: 6093:// Prints the names of the tests matching the user-specified filter flag.
    #####: 6094:void UnitTestImpl::ListTestsMatchingFilter() {
        -: 6095:  // Print at most this many characters for each type/value parameter.
    #####: 6096:  const int kMaxParamLength = 250;
        -: 6097:
    #####: 6098:  for (auto* test_suite : test_suites_) {
    %%%%%: 6098-block  0
    %%%%%: 6098-block  1
    %%%%%: 6098-block  2
    %%%%%: 6098-block  3
    #####: 6099:    bool printed_test_suite_name = false;
        -: 6100:
    #####: 6101:    for (size_t j = 0; j < test_suite->test_info_list().size(); j++) {
    %%%%%: 6101-block  0
    %%%%%: 6101-block  1
    #####: 6102:      const TestInfo* const test_info = test_suite->test_info_list()[j];
    %%%%%: 6102-block  0
    #####: 6103:      if (test_info->matches_filter_) {
    #####: 6104:        if (!printed_test_suite_name) {
    %%%%%: 6104-block  0
    #####: 6105:          printed_test_suite_name = true;
    #####: 6106:          printf("%s.", test_suite->name());
    %%%%%: 6106-block  0
    #####: 6107:          if (test_suite->type_param() != nullptr) {
    %%%%%: 6107-block  0
    #####: 6108:            printf("  # %s = ", kTypeParamLabel);
    %%%%%: 6108-block  0
        -: 6109:            // We print the type parameter on a single line to make
        -: 6110:            // the output easy to parse by a program.
    #####: 6111:            PrintOnOneLine(test_suite->type_param(), kMaxParamLength);
    %%%%%: 6111-block  0
        -: 6112:          }
    #####: 6113:          printf("\n");
    %%%%%: 6113-block  0
        -: 6114:        }
    #####: 6115:        printf("  %s", test_info->name());
    %%%%%: 6115-block  0
    #####: 6116:        if (test_info->value_param() != nullptr) {
    %%%%%: 6116-block  0
    #####: 6117:          printf("  # %s = ", kValueParamLabel);
    %%%%%: 6117-block  0
        -: 6118:          // We print the value parameter on a single line to make the
        -: 6119:          // output easy to parse by a program.
    #####: 6120:          PrintOnOneLine(test_info->value_param(), kMaxParamLength);
    %%%%%: 6120-block  0
        -: 6121:        }
    #####: 6122:        printf("\n");
    %%%%%: 6122-block  0
        -: 6123:      }
        -: 6124:    }
        -: 6125:  }
    #####: 6126:  fflush(stdout);
    %%%%%: 6126-block  0
    #####: 6127:  const std::string& output_format = UnitTestOptions::GetOutputFormat();
    %%%%%: 6127-block  0
    %%%%%: 6127-block  1
    $$$$$: 6127-block  2
    #####: 6128:  if (output_format == "xml" || output_format == "json") {
    %%%%%: 6128-block  0
    %%%%%: 6128-block  1
    %%%%%: 6128-block  2
    %%%%%: 6128-block  3
    %%%%%: 6128-block  4
    #####: 6129:    FILE* fileout = OpenFileForWriting(
    %%%%%: 6129-block  0
    %%%%%: 6129-block  1
    %%%%%: 6129-block  2
    %%%%%: 6129-block  3
    $$$$$: 6129-block  4
    $$$$$: 6129-block  5
    $$$$$: 6129-block  6
    $$$$$: 6129-block  7
    #####: 6130:        UnitTestOptions::GetAbsolutePathToOutputFile().c_str());
    $$$$$: 6130-block  0
    $$$$$: 6130-block  1
    #####: 6131:    std::stringstream stream;
    %%%%%: 6131-block  0
    $$$$$: 6131-block  1
    #####: 6132:    if (output_format == "xml") {
    %%%%%: 6132-block  0
    #####: 6133:      XmlUnitTestResultPrinter(
    %%%%%: 6133-block  0
    %%%%%: 6133-block  1
    $$$$$: 6133-block  2
    $$$$$: 6133-block  3
    #####: 6134:          UnitTestOptions::GetAbsolutePathToOutputFile().c_str())
    %%%%%: 6134-block  0
    $$$$$: 6134-block  1
    $$$$$: 6134-block  2
    #####: 6135:          .PrintXmlTestsList(&stream, test_suites_);
    %%%%%: 6135-block  0
    #####: 6136:    } else if (output_format == "json") {
    %%%%%: 6136-block  0
    #####: 6137:      JsonUnitTestResultPrinter(
    %%%%%: 6137-block  0
    %%%%%: 6137-block  1
    $$$$$: 6137-block  2
    $$$$$: 6137-block  3
    #####: 6138:          UnitTestOptions::GetAbsolutePathToOutputFile().c_str())
    %%%%%: 6138-block  0
    $$$$$: 6138-block  1
    $$$$$: 6138-block  2
    #####: 6139:          .PrintJsonTestList(&stream, test_suites_);
    %%%%%: 6139-block  0
        -: 6140:    }
    #####: 6141:    fprintf(fileout, "%s", StringStreamToString(&stream).c_str());
    %%%%%: 6141-block  0
    %%%%%: 6141-block  1
    %%%%%: 6141-block  2
    $$$$$: 6141-block  3
    $$$$$: 6141-block  4
    #####: 6142:    fclose(fileout);
        -: 6143:  }
    #####: 6144:}
        -: 6145:
        -: 6146:// Sets the OS stack trace getter.
        -: 6147://
        -: 6148:// Does nothing if the input and the current OS stack trace getter are
        -: 6149:// the same; otherwise, deletes the old getter and makes the input the
        -: 6150:// current getter.
    #####: 6151:void UnitTestImpl::set_os_stack_trace_getter(
        -: 6152:    OsStackTraceGetterInterface* getter) {
    #####: 6153:  if (os_stack_trace_getter_ != getter) {
    %%%%%: 6153-block  0
    #####: 6154:    delete os_stack_trace_getter_;
    %%%%%: 6154-block  0
    %%%%%: 6154-block  1
    #####: 6155:    os_stack_trace_getter_ = getter;
    %%%%%: 6155-block  0
        -: 6156:  }
    #####: 6157:}
        -: 6158:
        -: 6159:// Returns the current OS stack trace getter if it is not NULL;
        -: 6160:// otherwise, creates an OsStackTraceGetter, makes it the current
        -: 6161:// getter, and returns it.
      157: 6162:OsStackTraceGetterInterface* UnitTestImpl::os_stack_trace_getter() {
      157: 6163:  if (os_stack_trace_getter_ == nullptr) {
      157: 6163-block  0
        -: 6164:#ifdef GTEST_OS_STACK_TRACE_GETTER_
        -: 6165:    os_stack_trace_getter_ = new GTEST_OS_STACK_TRACE_GETTER_;
        -: 6166:#else
        1: 6167:    os_stack_trace_getter_ = new OsStackTraceGetter;
        1: 6167-block  0
        -: 6168:#endif  // GTEST_OS_STACK_TRACE_GETTER_
        -: 6169:  }
        -: 6170:
      157: 6171:  return os_stack_trace_getter_;
      157: 6171-block  0
        -: 6172:}
        -: 6173:
        -: 6174:// Returns the most specific TestResult currently running.
      126: 6175:TestResult* UnitTestImpl::current_test_result() {
      126: 6176:  if (current_test_info_ != nullptr) {
      126: 6176-block  0
      124: 6177:    return &current_test_info_->result_;
      124: 6177-block  0
        -: 6178:  }
        2: 6179:  if (current_test_suite_ != nullptr) {
        2: 6179-block  0
    #####: 6180:    return &current_test_suite_->ad_hoc_test_result_;
    %%%%%: 6180-block  0
        -: 6181:  }
        2: 6182:  return &ad_hoc_test_result_;
        2: 6182-block  0
        -: 6183:}
        -: 6184:
        -: 6185:// Shuffles all test suites, and the tests within each test suite,
        -: 6186:// making sure that death tests are still run first.
    #####: 6187:void UnitTestImpl::ShuffleTests() {
        -: 6188:  // Shuffles the death test suites.
    #####: 6189:  ShuffleRange(random(), 0, last_death_test_suite_ + 1, &test_suite_indices_);
    %%%%%: 6189-block  0
        -: 6190:
        -: 6191:  // Shuffles the non-death test suites.
    #####: 6192:  ShuffleRange(random(), last_death_test_suite_ + 1,
    #####: 6193:               static_cast<int>(test_suites_.size()), &test_suite_indices_);
        -: 6194:
        -: 6195:  // Shuffles the tests inside each test suite.
    #####: 6196:  for (auto& test_suite : test_suites_) {
    %%%%%: 6196-block  0
    %%%%%: 6196-block  1
    %%%%%: 6196-block  2
    #####: 6197:    test_suite->ShuffleTests(random());
        -: 6198:  }
    #####: 6199:}
    %%%%%: 6199-block  0
        -: 6200:
        -: 6201:// Restores the test suites and tests to their order before the first shuffle.
        1: 6202:void UnitTestImpl::UnshuffleTests() {
        3: 6203:  for (size_t i = 0; i < test_suites_.size(); i++) {
        1: 6203-block  0
        3: 6203-block  1
        -: 6204:    // Unshuffles the tests in each test suite.
        2: 6205:    test_suites_[i]->UnshuffleTests();
        2: 6205-block  0
        -: 6206:    // Resets the index of each test suite.
        2: 6207:    test_suite_indices_[i] = static_cast<int>(i);
        -: 6208:  }
        1: 6209:}
        -: 6210:
        -: 6211:// Returns the current OS stack trace as an std::string.
        -: 6212://
        -: 6213:// The maximum number of stack frames to be included is specified by
        -: 6214:// the gtest_stack_trace_depth flag.  The skip_count parameter
        -: 6215:// specifies the number of top frames to be skipped, which doesn't
        -: 6216:// count against the number of frames to be included.
        -: 6217://
        -: 6218:// For example, if Foo() calls Bar(), which in turn calls
        -: 6219:// GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in
        -: 6220:// the trace but Bar() and GetCurrentOsStackTraceExceptTop() won't.
    #####: 6221:std::string GetCurrentOsStackTraceExceptTop(UnitTest* /*unit_test*/,
        -: 6222:                                            int skip_count) {
        -: 6223:  // We pass skip_count + 1 to skip this wrapper function in addition
        -: 6224:  // to what the user really wants to skip.
    #####: 6225:  return GetUnitTestImpl()->CurrentOsStackTraceExceptTop(skip_count + 1);
    %%%%%: 6225-block  0
        -: 6226:}
        -: 6227:
        -: 6228:// Used by the GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_ macro to
        -: 6229:// suppress unreachable code warnings.
        -: 6230:namespace {
        -: 6231:class ClassUniqueToAlwaysTrue {};
        -: 6232:}
        -: 6233:
       88: 6234:bool IsTrue(bool condition) { return condition; }
       88: 6234-block  0
        -: 6235:
        5: 6236:bool AlwaysTrue() {
        -: 6237:#if GTEST_HAS_EXCEPTIONS
        -: 6238:  // This condition is always false so AlwaysTrue() never actually throws,
        -: 6239:  // but it makes the compiler think that it may throw.
        5: 6240:  if (IsTrue(false))
        5: 6240-block  0
    #####: 6241:    throw ClassUniqueToAlwaysTrue();
    %%%%%: 6241-block  0
        -: 6242:#endif  // GTEST_HAS_EXCEPTIONS
        5: 6243:  return true;
        5: 6243-block  0
        -: 6244:}
        -: 6245:
        -: 6246:// If *pstr starts with the given prefix, modifies *pstr to be right
        -: 6247:// past the prefix and returns true; otherwise leaves *pstr unchanged
        -: 6248:// and returns false.  None of pstr, *pstr, and prefix can be NULL.
    #####: 6249:bool SkipPrefix(const char* prefix, const char** pstr) {
    #####: 6250:  const size_t prefix_len = strlen(prefix);
    #####: 6251:  if (strncmp(*pstr, prefix, prefix_len) == 0) {
    %%%%%: 6251-block  0
    #####: 6252:    *pstr += prefix_len;
    #####: 6253:    return true;
    %%%%%: 6253-block  0
        -: 6254:  }
    #####: 6255:  return false;
    %%%%%: 6255-block  0
        -: 6256:}
        -: 6257:
        -: 6258:// Parses a string as a command line flag.  The string should have
        -: 6259:// the format "--flag=value".  When def_optional is true, the "=value"
        -: 6260:// part can be omitted.
        -: 6261://
        -: 6262:// Returns the value of the flag, or NULL if the parsing failed.
       12: 6263:static const char* ParseFlagValue(const char* str, const char* flag,
        -: 6264:                                  bool def_optional) {
        -: 6265:  // str and flag must not be NULL.
      12*: 6266:  if (str == nullptr || flag == nullptr) return nullptr;
       12: 6266-block  0
       12: 6266-block  1
    %%%%%: 6266-block  2
        -: 6267:
        -: 6268:  // The flag must start with "--" followed by GTEST_FLAG_PREFIX_.
       36: 6269:  const std::string flag_str = std::string("--") + GTEST_FLAG_PREFIX_ + flag;
       12: 6269-block  0
       12: 6269-block  1
       12: 6269-block  2
       12: 6269-block  3
    $$$$$: 6269-block  4
    $$$$$: 6269-block  5
    $$$$$: 6269-block  6
       12: 6270:  const size_t flag_len = flag_str.length();
       12: 6271:  if (strncmp(str, flag_str.c_str(), flag_len) != 0) return nullptr;
       10: 6271-block  0
        -: 6272:
        -: 6273:  // Skips the flag name.
        2: 6274:  const char* flag_end = str + flag_len;
        -: 6275:
        -: 6276:  // When def_optional is true, it's OK to not have a "=value" part.
       2*: 6277:  if (def_optional && (flag_end[0] == '\0')) {
        2: 6277-block  0
    %%%%%: 6277-block  1
    #####: 6278:    return flag_end;
    %%%%%: 6278-block  0
        -: 6279:  }
        -: 6280:
        -: 6281:  // If def_optional is true and there are more characters after the
        -: 6282:  // flag name, or if def_optional is false, there must be a '=' after
        -: 6283:  // the flag name.
       2*: 6284:  if (flag_end[0] != '=') return nullptr;
        2: 6284-block  0
    %%%%%: 6284-block  1
        -: 6285:
        -: 6286:  // Returns the string after "=".
        2: 6287:  return flag_end + 1;
        2: 6287-block  0
        -: 6288:}
        -: 6289:
        -: 6290:// Parses a string for a bool flag, in the form of either
        -: 6291:// "--flag=value" or "--flag".
        -: 6292://
        -: 6293:// In the former case, the value is taken as true as long as it does
        -: 6294:// not start with '0', 'f', or 'F'.
        -: 6295://
        -: 6296:// In the latter case, the value is taken as true.
        -: 6297://
        -: 6298:// On success, stores the value of the flag in *value, and returns
        -: 6299:// true.  On failure, returns false without changing *value.
        8: 6300:static bool ParseBoolFlag(const char* str, const char* flag, bool* value) {
        -: 6301:  // Gets the value of the flag as a string.
        8: 6302:  const char* const value_str = ParseFlagValue(str, flag, true);
        8: 6302-block  0
        -: 6303:
        -: 6304:  // Aborts if the parsing failed.
        8: 6305:  if (value_str == nullptr) return false;
        8: 6305-block  0
        -: 6306:
        -: 6307:  // Converts the string value to a bool.
    #####: 6308:  *value = !(*value_str == '0' || *value_str == 'f' || *value_str == 'F');
    %%%%%: 6308-block  0
    %%%%%: 6308-block  1
    %%%%%: 6308-block  2
    %%%%%: 6308-block  3
    %%%%%: 6308-block  4
    #####: 6309:  return true;
    %%%%%: 6309-block  0
        -: 6310:}
        -: 6311:
        -: 6312:// Parses a string for an int32_t flag, in the form of "--flag=value".
        -: 6313://
        -: 6314:// On success, stores the value of the flag in *value, and returns
        -: 6315:// true.  On failure, returns false without changing *value.
    #####: 6316:bool ParseInt32Flag(const char* str, const char* flag, int32_t* value) {
        -: 6317:  // Gets the value of the flag as a string.
    #####: 6318:  const char* const value_str = ParseFlagValue(str, flag, false);
    %%%%%: 6318-block  0
        -: 6319:
        -: 6320:  // Aborts if the parsing failed.
    #####: 6321:  if (value_str == nullptr) return false;
    %%%%%: 6321-block  0
        -: 6322:
        -: 6323:  // Sets *value to the value of the flag.
    #####: 6324:  return ParseInt32(Message() << "The value of flag --" << flag,
    %%%%%: 6324-block  0
    %%%%%: 6324-block  1
    %%%%%: 6324-block  2
    %%%%%: 6324-block  3
    $$$$$: 6324-block  4
    #####: 6325:                    value_str, value);
    %%%%%: 6325-block  0
        -: 6326:}
        -: 6327:
        -: 6328:// Parses a string for a string flag, in the form of "--flag=value".
        -: 6329://
        -: 6330:// On success, stores the value of the flag in *value, and returns
        -: 6331:// true.  On failure, returns false without changing *value.
        -: 6332:template <typename String>
        4: 6333:static bool ParseStringFlag(const char* str, const char* flag, String* value) {
        -: 6334:  // Gets the value of the flag as a string.
        4: 6335:  const char* const value_str = ParseFlagValue(str, flag, false);
        4: 6335-block  0
        -: 6336:
        -: 6337:  // Aborts if the parsing failed.
        4: 6338:  if (value_str == nullptr) return false;
        2: 6338-block  0
        -: 6339:
        -: 6340:  // Sets *value to the value of the flag.
        2: 6341:  *value = value_str;
        2: 6341-block  0
        2: 6342:  return true;
        -: 6343:}
        -: 6344:
        -: 6345:// Determines whether a string has a prefix that Google Test uses for its
        -: 6346:// flags, i.e., starts with GTEST_FLAG_PREFIX_ or GTEST_FLAG_PREFIX_DASH_.
        -: 6347:// If Google Test detects that a command line flag has its prefix but is not
        -: 6348:// recognized, it will print its help message. Flags starting with
        -: 6349:// GTEST_INTERNAL_PREFIX_ followed by "internal_" are considered Google Test
        -: 6350:// internal flags and do not trigger the help message.
    #####: 6351:static bool HasGoogleTestFlagPrefix(const char* str) {
    #####: 6352:  return (SkipPrefix("--", &str) ||
    %%%%%: 6352-block  0
    #####: 6353:          SkipPrefix("-", &str) ||
    %%%%%: 6353-block  0
    #####: 6354:          SkipPrefix("/", &str)) &&
    %%%%%: 6354-block  0
    #####: 6355:         !SkipPrefix(GTEST_FLAG_PREFIX_ "internal_", &str) &&
    %%%%%: 6355-block  0
    %%%%%: 6355-block  1
    %%%%%: 6355-block  2
    #####: 6356:         (SkipPrefix(GTEST_FLAG_PREFIX_, &str) ||
    %%%%%: 6356-block  0
    #####: 6357:          SkipPrefix(GTEST_FLAG_PREFIX_DASH_, &str));
    %%%%%: 6357-block  0
    %%%%%: 6357-block  1
        -: 6358:}
        -: 6359:
        -: 6360:// Prints a string containing code-encoded text.  The following escape
        -: 6361:// sequences can be used in the string to control the text color:
        -: 6362://
        -: 6363://   @@    prints a single '@' character.
        -: 6364://   @R    changes the color to red.
        -: 6365://   @G    changes the color to green.
        -: 6366://   @Y    changes the color to yellow.
        -: 6367://   @D    changes to the default terminal text color.
        -: 6368://
    #####: 6369:static void PrintColorEncoded(const char* str) {
    #####: 6370:  GTestColor color = GTestColor::kDefault;  // The current color.
    %%%%%: 6370-block  0
        -: 6371:
        -: 6372:  // Conceptually, we split the string into segments divided by escape
        -: 6373:  // sequences.  Then we print one segment at a time.  At the end of
        -: 6374:  // each iteration, the str pointer advances to the beginning of the
        -: 6375:  // next segment.
        -: 6376:  for (;;) {
    #####: 6377:    const char* p = strchr(str, '@');
    #####: 6378:    if (p == nullptr) {
    %%%%%: 6378-block  0
    #####: 6379:      ColoredPrintf(color, "%s", str);
    %%%%%: 6379-block  0
    #####: 6380:      return;
    %%%%%: 6380-block  0
        -: 6381:    }
        -: 6382:
    #####: 6383:    ColoredPrintf(color, "%s", std::string(str, p).c_str());
    %%%%%: 6383-block  0
    %%%%%: 6383-block  1
    %%%%%: 6383-block  2
    $$$$$: 6383-block  3
    $$$$$: 6383-block  4
    $$$$$: 6383-block  5
        -: 6384:
    #####: 6385:    const char ch = p[1];
    #####: 6386:    str = p + 2;
    #####: 6387:    if (ch == '@') {
    #####: 6388:      ColoredPrintf(color, "@");
    %%%%%: 6388-block  0
    #####: 6389:    } else if (ch == 'D') {
    %%%%%: 6389-block  0
    #####: 6390:      color = GTestColor::kDefault;
    %%%%%: 6390-block  0
    #####: 6391:    } else if (ch == 'R') {
    %%%%%: 6391-block  0
    #####: 6392:      color = GTestColor::kRed;
    %%%%%: 6392-block  0
    #####: 6393:    } else if (ch == 'G') {
    %%%%%: 6393-block  0
    #####: 6394:      color = GTestColor::kGreen;
    %%%%%: 6394-block  0
    #####: 6395:    } else if (ch == 'Y') {
    %%%%%: 6395-block  0
    #####: 6396:      color = GTestColor::kYellow;
    %%%%%: 6396-block  0
        -: 6397:    } else {
    #####: 6398:      --str;
    %%%%%: 6398-block  0
        -: 6399:    }
    #####: 6400:  }
    %%%%%: 6400-block  0
        -: 6401:}
        -: 6402:
        -: 6403:static const char kColorEncodedHelpMessage[] =
        -: 6404:    "This program contains tests written using " GTEST_NAME_
        -: 6405:    ". You can use the\n"
        -: 6406:    "following command line flags to control its behavior:\n"
        -: 6407:    "\n"
        -: 6408:    "Test Selection:\n"
        -: 6409:    "  @G--" GTEST_FLAG_PREFIX_
        -: 6410:    "list_tests@D\n"
        -: 6411:    "      List the names of all tests instead of running them. The name of\n"
        -: 6412:    "      TEST(Foo, Bar) is \"Foo.Bar\".\n"
        -: 6413:    "  @G--" GTEST_FLAG_PREFIX_
        -: 6414:    "filter=@YPOSITIVE_PATTERNS"
        -: 6415:    "[@G-@YNEGATIVE_PATTERNS]@D\n"
        -: 6416:    "      Run only the tests whose name matches one of the positive patterns "
        -: 6417:    "but\n"
        -: 6418:    "      none of the negative patterns. '?' matches any single character; "
        -: 6419:    "'*'\n"
        -: 6420:    "      matches any substring; ':' separates two patterns.\n"
        -: 6421:    "  @G--" GTEST_FLAG_PREFIX_
        -: 6422:    "also_run_disabled_tests@D\n"
        -: 6423:    "      Run all disabled tests too.\n"
        -: 6424:    "\n"
        -: 6425:    "Test Execution:\n"
        -: 6426:    "  @G--" GTEST_FLAG_PREFIX_
        -: 6427:    "repeat=@Y[COUNT]@D\n"
        -: 6428:    "      Run the tests repeatedly; use a negative count to repeat forever.\n"
        -: 6429:    "  @G--" GTEST_FLAG_PREFIX_
        -: 6430:    "shuffle@D\n"
        -: 6431:    "      Randomize tests' orders on every iteration.\n"
        -: 6432:    "  @G--" GTEST_FLAG_PREFIX_
        -: 6433:    "random_seed=@Y[NUMBER]@D\n"
        -: 6434:    "      Random number seed to use for shuffling test orders (between 1 and\n"
        -: 6435:    "      99999, or 0 to use a seed based on the current time).\n"
        -: 6436:    "\n"
        -: 6437:    "Test Output:\n"
        -: 6438:    "  @G--" GTEST_FLAG_PREFIX_
        -: 6439:    "color=@Y(@Gyes@Y|@Gno@Y|@Gauto@Y)@D\n"
        -: 6440:    "      Enable/disable colored output. The default is @Gauto@D.\n"
        -: 6441:    "  @G--" GTEST_FLAG_PREFIX_
        -: 6442:    "brief=1@D\n"
        -: 6443:    "      Only print test failures.\n"
        -: 6444:    "  @G--" GTEST_FLAG_PREFIX_
        -: 6445:    "print_time=0@D\n"
        -: 6446:    "      Don't print the elapsed time of each test.\n"
        -: 6447:    "  @G--" GTEST_FLAG_PREFIX_
        -: 6448:    "output=@Y(@Gjson@Y|@Gxml@Y)[@G:@YDIRECTORY_PATH@G" GTEST_PATH_SEP_
        -: 6449:    "@Y|@G:@YFILE_PATH]@D\n"
        -: 6450:    "      Generate a JSON or XML report in the given directory or with the "
        -: 6451:    "given\n"
        -: 6452:    "      file name. @YFILE_PATH@D defaults to @Gtest_detail.xml@D.\n"
        -: 6453:# if GTEST_CAN_STREAM_RESULTS_
        -: 6454:    "  @G--" GTEST_FLAG_PREFIX_
        -: 6455:    "stream_result_to=@YHOST@G:@YPORT@D\n"
        -: 6456:    "      Stream test results to the given server.\n"
        -: 6457:# endif  // GTEST_CAN_STREAM_RESULTS_
        -: 6458:    "\n"
        -: 6459:    "Assertion Behavior:\n"
        -: 6460:# if GTEST_HAS_DEATH_TEST && !GTEST_OS_WINDOWS
        -: 6461:    "  @G--" GTEST_FLAG_PREFIX_
        -: 6462:    "death_test_style=@Y(@Gfast@Y|@Gthreadsafe@Y)@D\n"
        -: 6463:    "      Set the default death test style.\n"
        -: 6464:# endif  // GTEST_HAS_DEATH_TEST && !GTEST_OS_WINDOWS
        -: 6465:    "  @G--" GTEST_FLAG_PREFIX_
        -: 6466:    "break_on_failure@D\n"
        -: 6467:    "      Turn assertion failures into debugger break-points.\n"
        -: 6468:    "  @G--" GTEST_FLAG_PREFIX_
        -: 6469:    "throw_on_failure@D\n"
        -: 6470:    "      Turn assertion failures into C++ exceptions for use by an external\n"
        -: 6471:    "      test framework.\n"
        -: 6472:    "  @G--" GTEST_FLAG_PREFIX_
        -: 6473:    "catch_exceptions=0@D\n"
        -: 6474:    "      Do not report exceptions as test failures. Instead, allow them\n"
        -: 6475:    "      to crash the program or throw a pop-up (on Windows).\n"
        -: 6476:    "\n"
        -: 6477:    "Except for @G--" GTEST_FLAG_PREFIX_
        -: 6478:    "list_tests@D, you can alternatively set "
        -: 6479:    "the corresponding\n"
        -: 6480:    "environment variable of a flag (all letters in upper-case). For example, "
        -: 6481:    "to\n"
        -: 6482:    "disable colored text output, you can either specify "
        -: 6483:    "@G--" GTEST_FLAG_PREFIX_
        -: 6484:    "color=no@D or set\n"
        -: 6485:    "the @G" GTEST_FLAG_PREFIX_UPPER_
        -: 6486:    "COLOR@D environment variable to @Gno@D.\n"
        -: 6487:    "\n"
        -: 6488:    "For more information, please read the " GTEST_NAME_
        -: 6489:    " documentation at\n"
        -: 6490:    "@G" GTEST_PROJECT_URL_ "@D. If you find a bug in " GTEST_NAME_
        -: 6491:    "\n"
        -: 6492:    "(not one in your own code or tests), please report it to\n"
        -: 6493:    "@G<" GTEST_DEV_EMAIL_ ">@D.\n";
        -: 6494:
        2: 6495:static bool ParseGoogleTestFlag(const char* const arg) {
        2: 6496:  return ParseBoolFlag(arg, kAlsoRunDisabledTestsFlag,
        2: 6496-block  0
        2: 6497:                       &GTEST_FLAG(also_run_disabled_tests)) ||
        2: 6498:         ParseBoolFlag(arg, kBreakOnFailureFlag,
        2: 6498-block  0
        2: 6499:                       &GTEST_FLAG(break_on_failure)) ||
        2: 6500:         ParseBoolFlag(arg, kCatchExceptionsFlag,
        2: 6500-block  0
        2: 6501:                       &GTEST_FLAG(catch_exceptions)) ||
        2: 6502:         ParseStringFlag(arg, kColorFlag, &GTEST_FLAG(color)) ||
        2: 6502-block  0
        1: 6503:         ParseStringFlag(arg, kDeathTestStyleFlag,
        1: 6503-block  0
        1: 6504:                         &GTEST_FLAG(death_test_style)) ||
        1: 6505:         ParseBoolFlag(arg, kDeathTestUseFork,
        1: 6505-block  0
        1: 6506:                       &GTEST_FLAG(death_test_use_fork)) ||
        1: 6507:         ParseBoolFlag(arg, kFailFast, &GTEST_FLAG(fail_fast)) ||
        1: 6507-block  0
       1*: 6508:         ParseStringFlag(arg, kFilterFlag, &GTEST_FLAG(filter)) ||
        1: 6508-block  0
    #####: 6509:         ParseStringFlag(arg, kInternalRunDeathTestFlag,
    %%%%%: 6509-block  0
    #####: 6510:                         &GTEST_FLAG(internal_run_death_test)) ||
    #####: 6511:         ParseBoolFlag(arg, kListTestsFlag, &GTEST_FLAG(list_tests)) ||
    %%%%%: 6511-block  0
    #####: 6512:         ParseStringFlag(arg, kOutputFlag, &GTEST_FLAG(output)) ||
    %%%%%: 6512-block  0
    #####: 6513:         ParseBoolFlag(arg, kBriefFlag, &GTEST_FLAG(brief)) ||
    %%%%%: 6513-block  0
    #####: 6514:         ParseBoolFlag(arg, kPrintTimeFlag, &GTEST_FLAG(print_time)) ||
    %%%%%: 6514-block  0
    #####: 6515:         ParseBoolFlag(arg, kPrintUTF8Flag, &GTEST_FLAG(print_utf8)) ||
    %%%%%: 6515-block  0
    #####: 6516:         ParseInt32Flag(arg, kRandomSeedFlag, &GTEST_FLAG(random_seed)) ||
    %%%%%: 6516-block  0
    #####: 6517:         ParseInt32Flag(arg, kRepeatFlag, &GTEST_FLAG(repeat)) ||
    %%%%%: 6517-block  0
    #####: 6518:         ParseBoolFlag(arg, kShuffleFlag, &GTEST_FLAG(shuffle)) ||
    %%%%%: 6518-block  0
    #####: 6519:         ParseInt32Flag(arg, kStackTraceDepthFlag,
    %%%%%: 6519-block  0
    #####: 6520:                        &GTEST_FLAG(stack_trace_depth)) ||
    #####: 6521:         ParseStringFlag(arg, kStreamResultToFlag,
    %%%%%: 6521-block  0
       4*: 6522:                         &GTEST_FLAG(stream_result_to)) ||
        2: 6522-block  0
    %%%%%: 6522-block  1
       2*: 6523:         ParseBoolFlag(arg, kThrowOnFailureFlag, &GTEST_FLAG(throw_on_failure));
    %%%%%: 6523-block  0
        2: 6523-block  1
        -: 6524:}
        -: 6525:
        -: 6526:#if GTEST_USE_OWN_FLAGFILE_FLAG_
    #####: 6527:static void LoadFlagsFromFile(const std::string& path) {
    #####: 6528:  FILE* flagfile = posix::FOpen(path.c_str(), "r");
    %%%%%: 6528-block  0
    #####: 6529:  if (!flagfile) {
    %%%%%: 6529-block  0
    #####: 6530:    GTEST_LOG_(FATAL) << "Unable to open file \"" << GTEST_FLAG(flagfile)
    %%%%%: 6530-block  0
    %%%%%: 6530-block  1
    %%%%%: 6530-block  2
    $$$$$: 6530-block  3
    $$$$$: 6530-block  4
    #####: 6531:                      << "\"";
    %%%%%: 6531-block  0
    %%%%%: 6531-block  1
        -: 6532:  }
    #####: 6533:  std::string contents(ReadEntireFile(flagfile));
    %%%%%: 6533-block  0
    $$$$$: 6533-block  1
    #####: 6534:  posix::FClose(flagfile);
    %%%%%: 6534-block  0
    #####: 6535:  std::vector<std::string> lines;
    %%%%%: 6535-block  0
    %%%%%: 6535-block  1
    $$$$$: 6535-block  2
    #####: 6536:  SplitString(contents, '\n', &lines);
    #####: 6537:  for (size_t i = 0; i < lines.size(); ++i) {
    %%%%%: 6537-block  0
    %%%%%: 6537-block  1
    %%%%%: 6537-block  2
    #####: 6538:    if (lines[i].empty())
    %%%%%: 6538-block  0
    #####: 6539:      continue;
    %%%%%: 6539-block  0
    #####: 6540:    if (!ParseGoogleTestFlag(lines[i].c_str()))
    %%%%%: 6540-block  0
    %%%%%: 6540-block  1
    #####: 6541:      g_help_flag = true;
    %%%%%: 6541-block  0
        -: 6542:  }
    #####: 6543:}
        -: 6544:#endif  // GTEST_USE_OWN_FLAGFILE_FLAG_
        -: 6545:
        -: 6546:// Parses the command line for Google Test flags, without initializing
        -: 6547:// other parts of Google Test.  The type parameter CharType can be
        -: 6548:// instantiated to either char or wchar_t.
        -: 6549:template <typename CharType>
       1*: 6550:void ParseGoogleTestFlagsOnlyImpl(int* argc, CharType** argv) {
       3*: 6551:  for (int i = 1; i < *argc; i++) {
       4*: 6552:    const std::string arg_string = StreamableToString(argv[i]);
       2*: 6553:    const char* const arg = arg_string.c_str();
        -: 6554:
        -: 6555:    using internal::ParseBoolFlag;
        -: 6556:    using internal::ParseInt32Flag;
        -: 6557:    using internal::ParseStringFlag;
        -: 6558:
       2*: 6559:    bool remove_flag = false;
       2*: 6560:    if (ParseGoogleTestFlag(arg)) {
       2*: 6561:      remove_flag = true;
        -: 6562:#if GTEST_USE_OWN_FLAGFILE_FLAG_
    #####: 6563:    } else if (ParseStringFlag(arg, kFlagfileFlag, &GTEST_FLAG(flagfile))) {
    #####: 6564:      LoadFlagsFromFile(GTEST_FLAG(flagfile));
    #####: 6565:      remove_flag = true;
        -: 6566:#endif  // GTEST_USE_OWN_FLAGFILE_FLAG_
    #####: 6567:    } else if (arg_string == "--help" || arg_string == "-h" ||
    #####: 6568:               arg_string == "-?" || arg_string == "/?" ||
    #####: 6569:               HasGoogleTestFlagPrefix(arg)) {
        -: 6570:      // Both help flag and unrecognized Google Test flags (excluding
        -: 6571:      // internal ones) trigger help display.
    #####: 6572:      g_help_flag = true;
        -: 6573:    }
        -: 6574:
       2*: 6575:    if (remove_flag) {
        -: 6576:      // Shift the remainder of the argv list left by one.  Note
        -: 6577:      // that argv has (*argc + 1) elements, the last one always being
        -: 6578:      // NULL.  The following loop moves the trailing NULL element as
        -: 6579:      // well.
       5*: 6580:      for (int j = i; j != *argc; j++) {
       3*: 6581:        argv[j] = argv[j + 1];
        -: 6582:      }
        -: 6583:
        -: 6584:      // Decrements the argument count.
       2*: 6585:      (*argc)--;
        -: 6586:
        -: 6587:      // We also need to decrement the iterator as we just removed
        -: 6588:      // an element.
       2*: 6589:      i--;
        -: 6590:    }
        -: 6591:  }
        -: 6592:
       1*: 6593:  if (g_help_flag) {
        -: 6594:    // We print the help here instead of in RUN_ALL_TESTS(), as the
        -: 6595:    // latter may not be called at all if the user is using Google
        -: 6596:    // Test with another testing framework.
    #####: 6597:    PrintColorEncoded(kColorEncodedHelpMessage);
        -: 6598:  }
       1*: 6599:}
------------------
_ZN7testing8internal28ParseGoogleTestFlagsOnlyImplIwEEvPiPPT_:
    #####: 6550:void ParseGoogleTestFlagsOnlyImpl(int* argc, CharType** argv) {
    #####: 6551:  for (int i = 1; i < *argc; i++) {
    %%%%%: 6551-block  0
    %%%%%: 6551-block  1
    #####: 6552:    const std::string arg_string = StreamableToString(argv[i]);
    %%%%%: 6552-block  0
    %%%%%: 6552-block  1
    $$$$$: 6552-block  2
    #####: 6553:    const char* const arg = arg_string.c_str();
    %%%%%: 6553-block  0
        -: 6554:
        -: 6555:    using internal::ParseBoolFlag;
        -: 6556:    using internal::ParseInt32Flag;
        -: 6557:    using internal::ParseStringFlag;
        -: 6558:
    #####: 6559:    bool remove_flag = false;
    #####: 6560:    if (ParseGoogleTestFlag(arg)) {
    %%%%%: 6560-block  0
    #####: 6561:      remove_flag = true;
    %%%%%: 6561-block  0
        -: 6562:#if GTEST_USE_OWN_FLAGFILE_FLAG_
    #####: 6563:    } else if (ParseStringFlag(arg, kFlagfileFlag, &GTEST_FLAG(flagfile))) {
    %%%%%: 6563-block  0
    %%%%%: 6563-block  1
    #####: 6564:      LoadFlagsFromFile(GTEST_FLAG(flagfile));
    %%%%%: 6564-block  0
    #####: 6565:      remove_flag = true;
    %%%%%: 6565-block  0
        -: 6566:#endif  // GTEST_USE_OWN_FLAGFILE_FLAG_
    #####: 6567:    } else if (arg_string == "--help" || arg_string == "-h" ||
    %%%%%: 6567-block  0
    %%%%%: 6567-block  1
    #####: 6568:               arg_string == "-?" || arg_string == "/?" ||
    %%%%%: 6568-block  0
    %%%%%: 6568-block  1
    %%%%%: 6568-block  2
    %%%%%: 6568-block  3
    %%%%%: 6568-block  4
    #####: 6569:               HasGoogleTestFlagPrefix(arg)) {
    %%%%%: 6569-block  0
        -: 6570:      // Both help flag and unrecognized Google Test flags (excluding
        -: 6571:      // internal ones) trigger help display.
    #####: 6572:      g_help_flag = true;
    %%%%%: 6572-block  0
        -: 6573:    }
        -: 6574:
    #####: 6575:    if (remove_flag) {
    %%%%%: 6575-block  0
        -: 6576:      // Shift the remainder of the argv list left by one.  Note
        -: 6577:      // that argv has (*argc + 1) elements, the last one always being
        -: 6578:      // NULL.  The following loop moves the trailing NULL element as
        -: 6579:      // well.
    #####: 6580:      for (int j = i; j != *argc; j++) {
    %%%%%: 6580-block  0
    %%%%%: 6580-block  1
    #####: 6581:        argv[j] = argv[j + 1];
    %%%%%: 6581-block  0
        -: 6582:      }
        -: 6583:
        -: 6584:      // Decrements the argument count.
    #####: 6585:      (*argc)--;
        -: 6586:
        -: 6587:      // We also need to decrement the iterator as we just removed
        -: 6588:      // an element.
    #####: 6589:      i--;
    %%%%%: 6589-block  0
        -: 6590:    }
        -: 6591:  }
        -: 6592:
    #####: 6593:  if (g_help_flag) {
    %%%%%: 6593-block  0
        -: 6594:    // We print the help here instead of in RUN_ALL_TESTS(), as the
        -: 6595:    // latter may not be called at all if the user is using Google
        -: 6596:    // Test with another testing framework.
    #####: 6597:    PrintColorEncoded(kColorEncodedHelpMessage);
    %%%%%: 6597-block  0
        -: 6598:  }
    #####: 6599:}
    %%%%%: 6599-block  0
------------------
_ZN7testing8internal28ParseGoogleTestFlagsOnlyImplIcEEvPiPPT_:
        1: 6550:void ParseGoogleTestFlagsOnlyImpl(int* argc, CharType** argv) {
        3: 6551:  for (int i = 1; i < *argc; i++) {
        1: 6551-block  0
        3: 6551-block  1
        4: 6552:    const std::string arg_string = StreamableToString(argv[i]);
        2: 6552-block  0
        2: 6552-block  1
    $$$$$: 6552-block  2
        2: 6553:    const char* const arg = arg_string.c_str();
        2: 6553-block  0
        -: 6554:
        -: 6555:    using internal::ParseBoolFlag;
        -: 6556:    using internal::ParseInt32Flag;
        -: 6557:    using internal::ParseStringFlag;
        -: 6558:
        2: 6559:    bool remove_flag = false;
        2: 6560:    if (ParseGoogleTestFlag(arg)) {
        2: 6560-block  0
        2: 6561:      remove_flag = true;
        2: 6561-block  0
        -: 6562:#if GTEST_USE_OWN_FLAGFILE_FLAG_
    #####: 6563:    } else if (ParseStringFlag(arg, kFlagfileFlag, &GTEST_FLAG(flagfile))) {
    %%%%%: 6563-block  0
    %%%%%: 6563-block  1
    #####: 6564:      LoadFlagsFromFile(GTEST_FLAG(flagfile));
    %%%%%: 6564-block  0
    #####: 6565:      remove_flag = true;
    %%%%%: 6565-block  0
        -: 6566:#endif  // GTEST_USE_OWN_FLAGFILE_FLAG_
    #####: 6567:    } else if (arg_string == "--help" || arg_string == "-h" ||
    %%%%%: 6567-block  0
    %%%%%: 6567-block  1
    #####: 6568:               arg_string == "-?" || arg_string == "/?" ||
    %%%%%: 6568-block  0
    %%%%%: 6568-block  1
    %%%%%: 6568-block  2
    %%%%%: 6568-block  3
    %%%%%: 6568-block  4
    #####: 6569:               HasGoogleTestFlagPrefix(arg)) {
    %%%%%: 6569-block  0
        -: 6570:      // Both help flag and unrecognized Google Test flags (excluding
        -: 6571:      // internal ones) trigger help display.
    #####: 6572:      g_help_flag = true;
    %%%%%: 6572-block  0
        -: 6573:    }
        -: 6574:
        2: 6575:    if (remove_flag) {
        2: 6575-block  0
        -: 6576:      // Shift the remainder of the argv list left by one.  Note
        -: 6577:      // that argv has (*argc + 1) elements, the last one always being
        -: 6578:      // NULL.  The following loop moves the trailing NULL element as
        -: 6579:      // well.
        5: 6580:      for (int j = i; j != *argc; j++) {
        2: 6580-block  0
        5: 6580-block  1
        3: 6581:        argv[j] = argv[j + 1];
        3: 6581-block  0
        -: 6582:      }
        -: 6583:
        -: 6584:      // Decrements the argument count.
        2: 6585:      (*argc)--;
        -: 6586:
        -: 6587:      // We also need to decrement the iterator as we just removed
        -: 6588:      // an element.
        2: 6589:      i--;
        2: 6589-block  0
        -: 6590:    }
        -: 6591:  }
        -: 6592:
        1: 6593:  if (g_help_flag) {
        1: 6593-block  0
        -: 6594:    // We print the help here instead of in RUN_ALL_TESTS(), as the
        -: 6595:    // latter may not be called at all if the user is using Google
        -: 6596:    // Test with another testing framework.
    #####: 6597:    PrintColorEncoded(kColorEncodedHelpMessage);
    %%%%%: 6597-block  0
        -: 6598:  }
        1: 6599:}
        1: 6599-block  0
------------------
        -: 6600:
        -: 6601:// Parses the command line for Google Test flags, without initializing
        -: 6602:// other parts of Google Test.
        1: 6603:void ParseGoogleTestFlagsOnly(int* argc, char** argv) {
        1: 6604:  ParseGoogleTestFlagsOnlyImpl(argc, argv);
        1: 6604-block  0
        -: 6605:
        -: 6606:  // Fix the value of *_NSGetArgc() on macOS, but if and only if
        -: 6607:  // *_NSGetArgv() == argv
        -: 6608:  // Only applicable to char** version of argv
        -: 6609:#if GTEST_OS_MAC
        -: 6610:#ifndef GTEST_OS_IOS
        -: 6611:  if (*_NSGetArgv() == argv) {
        -: 6612:    *_NSGetArgc() = *argc;
        -: 6613:  }
        -: 6614:#endif
        -: 6615:#endif
        1: 6616:}
    #####: 6617:void ParseGoogleTestFlagsOnly(int* argc, wchar_t** argv) {
    #####: 6618:  ParseGoogleTestFlagsOnlyImpl(argc, argv);
    %%%%%: 6618-block  0
    #####: 6619:}
        -: 6620:
        -: 6621:// The internal implementation of InitGoogleTest().
        -: 6622://
        -: 6623:// The type parameter CharType can be instantiated to either char or
        -: 6624:// wchar_t.
        -: 6625:template <typename CharType>
       1*: 6626:void InitGoogleTestImpl(int* argc, CharType** argv) {
        -: 6627:  // We don't want to run the initialization code twice.
       1*: 6628:  if (GTestIsInitialized()) return;
        -: 6629:
       1*: 6630:  if (*argc <= 0) return;
        -: 6631:
       1*: 6632:  g_argvs.clear();
       4*: 6633:  for (int i = 0; i != *argc; i++) {
       3*: 6634:    g_argvs.push_back(StreamableToString(argv[i]));
        -: 6635:  }
        -: 6636:
        -: 6637:#if GTEST_HAS_ABSL
        -: 6638:  absl::InitializeSymbolizer(g_argvs[0].c_str());
        -: 6639:#endif  // GTEST_HAS_ABSL
        -: 6640:
       1*: 6641:  ParseGoogleTestFlagsOnly(argc, argv);
       1*: 6642:  GetUnitTestImpl()->PostFlagParsingInit();
        -: 6643:}
------------------
_ZN7testing8internal18InitGoogleTestImplIwEEvPiPPT_:
    #####: 6626:void InitGoogleTestImpl(int* argc, CharType** argv) {
        -: 6627:  // We don't want to run the initialization code twice.
    #####: 6628:  if (GTestIsInitialized()) return;
    %%%%%: 6628-block  0
    %%%%%: 6628-block  1
        -: 6629:
    #####: 6630:  if (*argc <= 0) return;
    %%%%%: 6630-block  0
    %%%%%: 6630-block  1
        -: 6631:
    #####: 6632:  g_argvs.clear();
    %%%%%: 6632-block  0
    #####: 6633:  for (int i = 0; i != *argc; i++) {
    %%%%%: 6633-block  0
    #####: 6634:    g_argvs.push_back(StreamableToString(argv[i]));
    %%%%%: 6634-block  0
    %%%%%: 6634-block  1
    $$$$$: 6634-block  2
        -: 6635:  }
        -: 6636:
        -: 6637:#if GTEST_HAS_ABSL
        -: 6638:  absl::InitializeSymbolizer(g_argvs[0].c_str());
        -: 6639:#endif  // GTEST_HAS_ABSL
        -: 6640:
    #####: 6641:  ParseGoogleTestFlagsOnly(argc, argv);
    %%%%%: 6641-block  0
    #####: 6642:  GetUnitTestImpl()->PostFlagParsingInit();
        -: 6643:}
------------------
_ZN7testing8internal18InitGoogleTestImplIcEEvPiPPT_:
        1: 6626:void InitGoogleTestImpl(int* argc, CharType** argv) {
        -: 6627:  // We don't want to run the initialization code twice.
       1*: 6628:  if (GTestIsInitialized()) return;
        1: 6628-block  0
    %%%%%: 6628-block  1
        -: 6629:
       1*: 6630:  if (*argc <= 0) return;
        1: 6630-block  0
    %%%%%: 6630-block  1
        -: 6631:
        1: 6632:  g_argvs.clear();
        1: 6632-block  0
        4: 6633:  for (int i = 0; i != *argc; i++) {
        4: 6633-block  0
        3: 6634:    g_argvs.push_back(StreamableToString(argv[i]));
        3: 6634-block  0
        3: 6634-block  1
    $$$$$: 6634-block  2
        -: 6635:  }
        -: 6636:
        -: 6637:#if GTEST_HAS_ABSL
        -: 6638:  absl::InitializeSymbolizer(g_argvs[0].c_str());
        -: 6639:#endif  // GTEST_HAS_ABSL
        -: 6640:
        1: 6641:  ParseGoogleTestFlagsOnly(argc, argv);
        1: 6641-block  0
        1: 6642:  GetUnitTestImpl()->PostFlagParsingInit();
        -: 6643:}
------------------
        -: 6644:
        -: 6645:}  // namespace internal
        -: 6646:
        -: 6647:// Initializes Google Test.  This must be called before calling
        -: 6648:// RUN_ALL_TESTS().  In particular, it parses a command line for the
        -: 6649:// flags that Google Test recognizes.  Whenever a Google Test flag is
        -: 6650:// seen, it is removed from argv, and *argc is decremented.
        -: 6651://
        -: 6652:// No value is returned.  Instead, the Google Test flag variables are
        -: 6653:// updated.
        -: 6654://
        -: 6655:// Calling the function for the second time has no user-visible effect.
        1: 6656:void InitGoogleTest(int* argc, char** argv) {
        -: 6657:#if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
        -: 6658:  GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(argc, argv);
        -: 6659:#else  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
        1: 6660:  internal::InitGoogleTestImpl(argc, argv);
        1: 6660-block  0
        -: 6661:#endif  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
        1: 6662:}
        -: 6663:
        -: 6664:// This overloaded version can be used in Windows programs compiled in
        -: 6665:// UNICODE mode.
    #####: 6666:void InitGoogleTest(int* argc, wchar_t** argv) {
        -: 6667:#if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
        -: 6668:  GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(argc, argv);
        -: 6669:#else  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
    #####: 6670:  internal::InitGoogleTestImpl(argc, argv);
    %%%%%: 6670-block  0
        -: 6671:#endif  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
    #####: 6672:}
        -: 6673:
        -: 6674:// This overloaded version can be used on Arduino/embedded platforms where
        -: 6675:// there is no argc/argv.
    #####: 6676:void InitGoogleTest() {
        -: 6677:  // Since Arduino doesn't have a command line, fake out the argc/argv arguments
    #####: 6678:  int argc = 1;
    #####: 6679:  const auto arg0 = "dummy";
    #####: 6680:  char* argv0 = const_cast<char*>(arg0);
    #####: 6681:  char** argv = &argv0;
        -: 6682:
        -: 6683:#if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
        -: 6684:  GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(&argc, argv);
        -: 6685:#else  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
    #####: 6686:  internal::InitGoogleTestImpl(&argc, argv);
    %%%%%: 6686-block  0
        -: 6687:#endif  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
    #####: 6688:}
    %%%%%: 6688-block  0
        -: 6689:
    #####: 6690:std::string TempDir() {
        -: 6691:#if defined(GTEST_CUSTOM_TEMPDIR_FUNCTION_)
        -: 6692:  return GTEST_CUSTOM_TEMPDIR_FUNCTION_();
        -: 6693:#elif GTEST_OS_WINDOWS_MOBILE
        -: 6694:  return "\\temp\\";
        -: 6695:#elif GTEST_OS_WINDOWS
        -: 6696:  const char* temp_dir = internal::posix::GetEnv("TEMP");
        -: 6697:  if (temp_dir == nullptr || temp_dir[0] == '\0') {
        -: 6698:    return "\\temp\\";
        -: 6699:  } else if (temp_dir[strlen(temp_dir) - 1] == '\\') {
        -: 6700:    return temp_dir;
        -: 6701:  } else {
        -: 6702:    return std::string(temp_dir) + "\\";
        -: 6703:  }
        -: 6704:#elif GTEST_OS_LINUX_ANDROID
        -: 6705:  const char* temp_dir = internal::posix::GetEnv("TEST_TMPDIR");
        -: 6706:  if (temp_dir == nullptr || temp_dir[0] == '\0') {
        -: 6707:    return "/data/local/tmp/";
        -: 6708:  } else {
        -: 6709:    return temp_dir;
        -: 6710:  }
        -: 6711:#elif GTEST_OS_LINUX
    #####: 6712:  const char* temp_dir = internal::posix::GetEnv("TEST_TMPDIR");
    %%%%%: 6712-block  0
    #####: 6713:  if (temp_dir == nullptr || temp_dir[0] == '\0') {
    %%%%%: 6713-block  0
    #####: 6714:    return "/tmp/";
    %%%%%: 6714-block  0
    %%%%%: 6714-block  1
    $$$$$: 6714-block  2
    $$$$$: 6714-block  3
        -: 6715:  } else {
    #####: 6716:    return temp_dir;
    %%%%%: 6716-block  0
    %%%%%: 6716-block  1
    $$$$$: 6716-block  2
    $$$$$: 6716-block  3
        -: 6717:  }
        -: 6718:#else
        -: 6719:  return "/tmp/";
        -: 6720:#endif  // GTEST_OS_WINDOWS_MOBILE
        -: 6721:}
        -: 6722:
        -: 6723:// Class ScopedTrace
        -: 6724:
        -: 6725:// Pushes the given source file location and message onto a per-thread
        -: 6726:// trace stack maintained by Google Test.
    #####: 6727:void ScopedTrace::PushTrace(const char* file, int line, std::string message) {
    #####: 6728:  internal::TraceInfo trace;
    %%%%%: 6728-block  0
    %%%%%: 6728-block  1
    $$$$$: 6728-block  2
    #####: 6729:  trace.file = file;
    #####: 6730:  trace.line = line;
    #####: 6731:  trace.message.swap(message);
        -: 6732:
    #####: 6733:  UnitTest::GetInstance()->PushGTestTrace(trace);
    %%%%%: 6733-block  0
    #####: 6734:}
        -: 6735:
        -: 6736:// Pops the info pushed by the c'tor.
    #####: 6737:ScopedTrace::~ScopedTrace()
        -: 6738:    GTEST_LOCK_EXCLUDED_(&UnitTest::mutex_) {
    #####: 6739:  UnitTest::GetInstance()->PopGTestTrace();
    %%%%%: 6739-block  0
    #####: 6740:}
        -: 6741:
        -: 6742:}  // namespace testing
