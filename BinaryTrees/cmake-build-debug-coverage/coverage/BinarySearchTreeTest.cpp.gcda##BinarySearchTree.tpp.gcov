        -:    0:Source:/home/brownthedev/Documents/uLaval/Hiver2021/IFT-2008 Algorithmes et structures de données/BinaryTree/BinaryTree/src/main/BinarySearchTree.tpp
        -:    0:Graph:/home/brownthedev/Documents/uLaval/Hiver2021/IFT-2008 Algorithmes et structures de données/BinaryTree/BinaryTree/cmake-build-debug-coverage/CMakeFiles/BinaryTree_test.dir/src/test/BinarySearchTreeTest.cpp.gcno
        -:    0:Data:/home/brownthedev/Documents/uLaval/Hiver2021/IFT-2008 Algorithmes et structures de données/BinaryTree/BinaryTree/cmake-build-debug-coverage/CMakeFiles/BinaryTree_test.dir/src/test/BinarySearchTreeTest.cpp.gcda
        -:    0:Runs:1
        -:    1:#include "BinarySearchTree.h"
        -:    2:
        -:    3:template<typename Comparable>
       32:    4:BinarySearchTree<Comparable>::BinarySearchTree() : root{nullptr} {}
------------------
_ZN16BinarySearchTreeImEC2Ev:
       31:    4:BinarySearchTree<Comparable>::BinarySearchTree() : root{nullptr} {}
------------------
_ZN16BinarySearchTreeIiEC2Ev:
        1:    4:BinarySearchTree<Comparable>::BinarySearchTree() : root{nullptr} {}
------------------
        -:    5:
        -:    6:template<typename Comparable>
        1:    7:BinarySearchTree<Comparable>::BinarySearchTree(const BinarySearchTree& rhs) : root{nullptr} {
        1:    8:	root = clone(rhs.root);
        1:    8-block  0
        1:    9:}
        -:   10:
        -:   11:template<typename Comparable>
       21:   12:BinaryNode<Comparable>* BinarySearchTree<Comparable>::clone(BinaryNode<Comparable>* t) const {
       21:   13:	if (t==nullptr) {
       12:   14:		return nullptr;
        -:   15:	}
        9:   16:	return new BinaryNode<Comparable>{
        9:   17:		.element = t->element,
        -:   18:		.left = clone(t->left),
        -:   19:		.right = clone(t->right)
        9:   20:	};
        -:   21:}
------------------
_ZNK16BinarySearchTreeImE5cloneEP10BinaryNodeImE:
       12:   12:BinaryNode<Comparable>* BinarySearchTree<Comparable>::clone(BinaryNode<Comparable>* t) const {
       12:   13:	if (t==nullptr) {
       12:   13-block  0
        7:   14:		return nullptr;
        7:   14-block  0
        -:   15:	}
        5:   16:	return new BinaryNode<Comparable>{
        5:   16-block  0
        5:   17:		.element = t->element,
        -:   18:		.left = clone(t->left),
        -:   19:		.right = clone(t->right)
        5:   20:	};
        -:   21:}
------------------
_ZNK16BinarySearchTreeIiE5cloneEP10BinaryNodeIiE:
        9:   12:BinaryNode<Comparable>* BinarySearchTree<Comparable>::clone(BinaryNode<Comparable>* t) const {
        9:   13:	if (t==nullptr) {
        9:   13-block  0
        5:   14:		return nullptr;
        5:   14-block  0
        -:   15:	}
        4:   16:	return new BinaryNode<Comparable>{
        4:   16-block  0
        4:   17:		.element = t->element,
        -:   18:		.left = clone(t->left),
        -:   19:		.right = clone(t->right)
        4:   20:	};
        -:   21:}
------------------
        -:   22:
        -:   23:template<typename Comparable>
        -:   24:BinarySearchTree<Comparable>::BinarySearchTree(BinarySearchTree&& rhs): root{nullptr} {
        -:   25:	root = clone(rhs.root);
        -:   26:}
        -:   27:
        -:   28:template<typename Comparable>
       33:   29:BinarySearchTree<Comparable>::~BinarySearchTree() {
       33:   30:	makeEmpty();
       33:   31:}
------------------
_ZN16BinarySearchTreeImED2Ev:
       31:   29:BinarySearchTree<Comparable>::~BinarySearchTree() {
       31:   30:	makeEmpty();
       31:   30-block  0
       31:   31:}
------------------
_ZN16BinarySearchTreeIiED2Ev:
        2:   29:BinarySearchTree<Comparable>::~BinarySearchTree() {
        2:   30:	makeEmpty();
        2:   30-block  0
        2:   31:}
------------------
        -:   32:
        -:   33:template<typename Comparable>
       39:   34:void BinarySearchTree<Comparable>::makeEmpty() {
       39:   35:	makeEmpty(root);
       39:   36:}
------------------
_ZN16BinarySearchTreeIiE9makeEmptyEv:
        2:   34:void BinarySearchTree<Comparable>::makeEmpty() {
        2:   35:	makeEmpty(root);
        2:   35-block  0
        2:   36:}
------------------
_ZN16BinarySearchTreeImE9makeEmptyEv:
       37:   34:void BinarySearchTree<Comparable>::makeEmpty() {
       37:   35:	makeEmpty(root);
       37:   35-block  0
       37:   36:}
------------------
        -:   37:
        -:   38:template<typename Comparable>
      191:   39:void BinarySearchTree<Comparable>::makeEmpty(BinaryNode<Comparable>*& t) {
      191:   40:	if (t!=nullptr) {
       76:   41:		makeEmpty(t->left);
       76:   42:		makeEmpty(t->right);
       76:   43:		delete t;
        -:   44:	}
        -:   45:
      191:   46:	t = nullptr;
      191:   47:}
------------------
_ZN16BinarySearchTreeIiE9makeEmptyERP10BinaryNodeIiE:
       18:   39:void BinarySearchTree<Comparable>::makeEmpty(BinaryNode<Comparable>*& t) {
       18:   40:	if (t!=nullptr) {
       18:   40-block  0
        8:   41:		makeEmpty(t->left);
        8:   41-block  0
        8:   42:		makeEmpty(t->right);
        8:   43:		delete t;
        8:   43-block  0
        -:   44:	}
        -:   45:
       18:   46:	t = nullptr;
       18:   47:}
------------------
_ZN16BinarySearchTreeImE9makeEmptyERP10BinaryNodeImE:
      173:   39:void BinarySearchTree<Comparable>::makeEmpty(BinaryNode<Comparable>*& t) {
      173:   40:	if (t!=nullptr) {
      173:   40-block  0
       68:   41:		makeEmpty(t->left);
       68:   41-block  0
       68:   42:		makeEmpty(t->right);
       68:   43:		delete t;
       68:   43-block  0
        -:   44:	}
        -:   45:
      173:   46:	t = nullptr;
      173:   47:}
------------------
        -:   48:
        -:   49:template<typename Comparable>
       26:   50:bool BinarySearchTree<Comparable>::contains(const Comparable& x) const {
       26:   51:	return contains(x, root);
        -:   52:}
------------------
_ZNK16BinarySearchTreeIiE8containsERKi:
        4:   50:bool BinarySearchTree<Comparable>::contains(const Comparable& x) const {
        4:   51:	return contains(x, root);
        4:   51-block  0
        -:   52:}
------------------
_ZNK16BinarySearchTreeImE8containsERKm:
       22:   50:bool BinarySearchTree<Comparable>::contains(const Comparable& x) const {
       22:   51:	return contains(x, root);
       22:   51-block  0
        -:   52:}
------------------
        -:   53:
        -:   54:template<typename Comparable>
       55:   55:bool BinarySearchTree<Comparable>::contains(const Comparable& x, BinaryNode<Comparable>* t) const {
       55:   56:	if (t==nullptr) {
       7*:   57:		return false;
        -:   58:	}
       48:   59:	if (x < t->element) {
       17:   60:		return contains(x, t->left);
        -:   61:	}
       31:   62:	if (t->element < x) {
       12:   63:		return contains(x, t->right);
        -:   64:	}
       19:   65:	return true;
        -:   66:}
------------------
_ZNK16BinarySearchTreeIiE8containsERKiP10BinaryNodeIiE:
       10:   55:bool BinarySearchTree<Comparable>::contains(const Comparable& x, BinaryNode<Comparable>* t) const {
       10:   56:	if (t==nullptr) {
       10:   56-block  0
    #####:   57:		return false;
    %%%%%:   57-block  0
        -:   58:	}
       10:   59:	if (x < t->element) {
       10:   59-block  0
        4:   60:		return contains(x, t->left);
        4:   60-block  0
        -:   61:	}
        6:   62:	if (t->element < x) {
        6:   62-block  0
        2:   63:		return contains(x, t->right);
        2:   63-block  0
        -:   64:	}
        4:   65:	return true;
        4:   65-block  0
        -:   66:}
------------------
_ZNK16BinarySearchTreeImE8containsERKmP10BinaryNodeImE:
       45:   55:bool BinarySearchTree<Comparable>::contains(const Comparable& x, BinaryNode<Comparable>* t) const {
       45:   56:	if (t==nullptr) {
       45:   56-block  0
        7:   57:		return false;
        7:   57-block  0
        -:   58:	}
       38:   59:	if (x < t->element) {
       38:   59-block  0
       13:   60:		return contains(x, t->left);
       13:   60-block  0
        -:   61:	}
       25:   62:	if (t->element < x) {
       25:   62-block  0
       10:   63:		return contains(x, t->right);
       10:   63-block  0
        -:   64:	}
       15:   65:	return true;
       15:   65-block  0
        -:   66:}
------------------
        -:   67:
        -:   68:template<typename Comparable>
        3:   69:const Comparable& BinarySearchTree<Comparable>::findMin() const {
        3:   70:	if (root==nullptr) {
        3:   70-block  0
        1:   71:		throw std::logic_error{"Could not find min element of empty tree!"};
        1:   71-block  0
        1:   71-block  1
    $$$$$:   71-block  2
        -:   72:	}
        -:   73:
        2:   74:	return findMin(root)->element;
        2:   74-block  0
        2:   74-block  1
        -:   75:}
        -:   76:
        -:   77:template<typename Comparable>
        4:   78:BinaryNode<Comparable>* BinarySearchTree<Comparable>::findMin(BinaryNode<Comparable>* t) const {
        4:   79:	if (t->left==nullptr) {
        4:   79-block  0
        3:   80:		return t;
        3:   80-block  0
        -:   81:	}
        1:   82:	return findMin(t->left);
        1:   82-block  0
        -:   83:}
        -:   84:
        -:   85:template<typename Comparable>
        3:   86:const Comparable& BinarySearchTree<Comparable>::findMax() const {
        3:   87:	if (root==nullptr) {
        3:   87-block  0
        1:   88:		throw std::logic_error{"Could not find max element of empty tree!"};
        1:   88-block  0
        1:   88-block  1
    $$$$$:   88-block  2
        -:   89:	}
        -:   90:
        2:   91:	return findMax(root)->element;
        2:   91-block  0
        2:   91-block  1
        -:   92:}
        -:   93:
        -:   94:template<typename Comparable>
        4:   95:BinaryNode<Comparable>* BinarySearchTree<Comparable>::findMax(BinaryNode<Comparable>* t) const {
        4:   96:	while (t->right!=nullptr) {
        4:   96-block  0
        2:   97:		t = t->right;
        2:   97-block  0
        -:   98:	}
        2:   99:	return t;
        2:   99-block  0
        -:  100:}
        -:  101:
        -:  102:template<typename Comparable>
       39:  103:void BinarySearchTree<Comparable>::insert(const Comparable& x) {
       39:  104:	insert(x, root);
       38:  105:}
------------------
_ZN16BinarySearchTreeIiE6insertERKi:
        4:  103:void BinarySearchTree<Comparable>::insert(const Comparable& x) {
        4:  104:	insert(x, root);
        4:  104-block  0
        4:  105:}
------------------
_ZN16BinarySearchTreeImE6insertERKm:
       35:  103:void BinarySearchTree<Comparable>::insert(const Comparable& x) {
       35:  104:	insert(x, root);
       35:  104-block  0
       34:  105:}
------------------
        -:  106:
        -:  107:template<typename Comparable>
       90:  108:void BinarySearchTree<Comparable>::insert(const Comparable& x, BinaryNode<Comparable>*& t) {
       90:  109:	if (t==nullptr) {
       38:  110:		t = new BinaryNode<Comparable>{x, nullptr, nullptr};
       52:  111:	} else if (x < t->element) {
       31:  112:		insert(x, t->left);
       21:  113:	} else if (t->element < x) {
       20:  114:		insert(x, t->right);
        -:  115:	} else {
       1*:  116:		throw std::logic_error{"Element is already present in the tree!"};
        -:  117:	}
       89:  118:}
------------------
_ZN16BinarySearchTreeIiE6insertERKiRP10BinaryNodeIiE:
       10:  108:void BinarySearchTree<Comparable>::insert(const Comparable& x, BinaryNode<Comparable>*& t) {
       10:  109:	if (t==nullptr) {
       10:  109-block  0
        4:  110:		t = new BinaryNode<Comparable>{x, nullptr, nullptr};
        4:  110-block  0
        6:  111:	} else if (x < t->element) {
        6:  111-block  0
        4:  112:		insert(x, t->left);
        4:  112-block  0
        2:  113:	} else if (t->element < x) {
        2:  113-block  0
        2:  114:		insert(x, t->right);
        2:  114-block  0
        -:  115:	} else {
    #####:  116:		throw std::logic_error{"Element is already present in the tree!"};
    %%%%%:  116-block  0
    %%%%%:  116-block  1
    $$$$$:  116-block  2
        -:  117:	}
       10:  118:}
       10:  118-block  0
------------------
_ZN16BinarySearchTreeImE6insertERKmRP10BinaryNodeImE:
       80:  108:void BinarySearchTree<Comparable>::insert(const Comparable& x, BinaryNode<Comparable>*& t) {
       80:  109:	if (t==nullptr) {
       80:  109-block  0
       34:  110:		t = new BinaryNode<Comparable>{x, nullptr, nullptr};
       34:  110-block  0
       46:  111:	} else if (x < t->element) {
       46:  111-block  0
       27:  112:		insert(x, t->left);
       27:  112-block  0
       19:  113:	} else if (t->element < x) {
       19:  113-block  0
       18:  114:		insert(x, t->right);
       18:  114-block  0
        -:  115:	} else {
        1:  116:		throw std::logic_error{"Element is already present in the tree!"};
        1:  116-block  0
        1:  116-block  1
    $$$$$:  116-block  2
        -:  117:	}
       79:  118:}
       79:  118-block  0
------------------
        -:  119:
        -:  120:template<typename Comparable>
       36:  121:void BinarySearchTree<Comparable>::insert(Comparable&& x) {
       36:  122:	insert(std::move(x), root);
       36:  122-block  0
       36:  123:}
        -:  124:
        -:  125:template<typename Comparable>
       98:  126:void BinarySearchTree<Comparable>::insert(Comparable&& x, BinaryNode<Comparable>*& t) {
       98:  127:	if (t==nullptr) {
       98:  127-block  0
       36:  128:		t = new BinaryNode<Comparable>{std::move(x), nullptr, nullptr};
       36:  128-block  0
       62:  129:	} else if (x < t->element) {
       62:  129-block  0
       13:  130:		insert(std::move(x), t->left);
       13:  130-block  0
       49:  131:	} else if (t->element < x) {
       49:  131-block  0
       49:  132:		insert(std::move(x), t->right);
       49:  132-block  0
        -:  133:	} else {
    #####:  134:		throw std::logic_error{"Element is already present in the tree!"};
    %%%%%:  134-block  0
    %%%%%:  134-block  1
    $$$$$:  134-block  2
        -:  135:	}
       98:  136:}
       98:  136-block  0
        -:  137:
        -:  138:template<typename Comparable>
        8:  139:void BinarySearchTree<Comparable>::remove(const Comparable& x) {
        8:  140:	remove(x, root);
        8:  140-block  0
        8:  141:}
        -:  142:
        -:  143:template<typename Comparable>
       13:  144:void BinarySearchTree<Comparable>::remove(const Comparable& x, BinaryNode<Comparable>*& t) {
       13:  145:	if (t==nullptr) {
       13:  145-block  0
        1:  146:		return;
        1:  146-block  0
        -:  147:	}
        -:  148:
       12:  149:	if (x < t->element) {
       12:  149-block  0
        3:  150:		remove(x, t->left);
        3:  150-block  0
        9:  151:	} else if (t->element < x) {
        9:  151-block  0
        1:  152:		remove(x, t->right);
        1:  152-block  0
        8:  153:	} else if (has2Children(t)) {
        8:  153-block  0
        1:  154:		t->element = findMin(t->right)->element;
        1:  154-block  0
        1:  155:		remove(t->element, t->right);
        -:  156:	} else {
        7:  157:		BinaryNode<Comparable>* oldNode = t;
        7:  158:		t = (t->left!=nullptr) ? t->left : t->right;
        7:  158-block  0
        2:  158-block  1
        5:  158-block  2
        7:  159:		delete oldNode;
        7:  159-block  0
        7:  159-block  1
        -:  160:	}
        -:  161:}
        -:  162:
        -:  163:template<typename Comparable>
        8:  164:bool BinarySearchTree<Comparable>::has2Children(BinaryNode<Comparable>* const& t) const {
        8:  165:	return t->left!=nullptr && t->right!=nullptr;
        8:  165-block  0
        3:  165-block  1
        1:  165-block  2
        7:  165-block  3
        8:  165-block  4
        -:  166:}
        -:  167:
        -:  168:template<typename Comparable>
        6:  169:bool BinarySearchTree<Comparable>::isEmpty() const {
        6:  170:	return root==nullptr;
        6:  170-block  0
        -:  171:}
        -:  172:
        -:  173:template<typename Comparable>
        2:  174:BinarySearchTree<Comparable>& BinarySearchTree<Comparable>::operator=(const BinarySearchTree& rhs) {
        -:  175:
        2:  176:	if (this->root!=rhs.root) {
        2:  176-block  0
        2:  177:		makeEmpty();
        2:  177-block  0
        2:  178:		root = clone(rhs.root);
        -:  179:	}
        -:  180:
        2:  181:	return *this;
        2:  181-block  0
        -:  182:}
        -:  183:
        -:  184:template<typename Comparable>
        -:  185:BinarySearchTree<Comparable>& BinarySearchTree<Comparable>::operator=(BinarySearchTree&& rhs) {
        -:  186:
        -:  187:	if (this->root!=rhs.root) {
        -:  188:		makeEmpty();
        -:  189:		root = clone(rhs.root);
        -:  190:	}
        -:  191:
        -:  192:	return *this;
        -:  193:}
        -:  194:
        -:  195:template<typename Comparable>
        1:  196:void BinarySearchTree<Comparable>::printTreeInSymmetricOrder(std::ostream& out) const {
        1:  197:	printTreeInSymmetricOrder(root, out);
        1:  197-block  0
        1:  198:}
        -:  199:
        -:  200:template<typename Comparable>
       15:  201:void BinarySearchTree<Comparable>::printTreeInSymmetricOrder(BinaryNode<Comparable>* t, std::ostream& out) const {
       15:  202:	if(t ==nullptr) {
       15:  202-block  0
        8:  203:		return;
        8:  203-block  0
        -:  204:	}
        -:  205:
        7:  206:	printTreeInSymmetricOrder(t->left, out);
        7:  206-block  0
        -:  207:
        7:  208:	out << t->element << ";";
        -:  209:
        7:  210:	printTreeInSymmetricOrder(t->right, out);
        -:  211:}
        -:  212:
        -:  213:template <typename Comparable>
        1:  214:void BinarySearchTree<Comparable>::printTreeInPreOrder(std::ostream& out) const {
        1:  215:	printTreeInPreOrder(root, out);
        1:  215-block  0
        1:  216:}
        -:  217:
        -:  218:template<typename Comparable>
       15:  219:void BinarySearchTree<Comparable>::printTreeInPreOrder(BinaryNode<Comparable>* t, std::ostream& out) const {
       15:  220:	if(t ==nullptr) {
       15:  220-block  0
        8:  221:		return;
        8:  221-block  0
        -:  222:	}
        -:  223:
        7:  224:	out << t->element << ";";
        7:  224-block  0
        -:  225:
        7:  226:	printTreeInPreOrder(t->left, out);
        -:  227:
        7:  228:	printTreeInPreOrder(t->right, out);
        -:  229:}
        -:  230:
        -:  231:template <typename Comparable>
        1:  232:void BinarySearchTree<Comparable>::printTreeInPostOrder(std::ostream& out) const {
        1:  233:	printTreeInPostOrder(root, out);
        1:  233-block  0
        1:  234:}
        -:  235:
        -:  236:template<typename Comparable>
       15:  237:void BinarySearchTree<Comparable>::printTreeInPostOrder(BinaryNode<Comparable>* t, std::ostream& out) const {
       15:  238:	if(t ==nullptr) {
       15:  238-block  0
        8:  239:		return;
        8:  239-block  0
        -:  240:	}
        -:  241:
        7:  242:	printTreeInPostOrder(t->left, out);
        7:  242-block  0
        -:  243:
        7:  244:	printTreeInPostOrder(t->right, out);
        -:  245:
        7:  246:	out << t->element << ";";
        -:  247:}
